#include "DBMgr.h"
#include "Base.h"
#include "cocos2d.h"
#include "UiTools.h"
#include "ToolTip.h"
#include "SystemUi.h"
#include "stringMgr.h"
#include "MiniMapUi.h"
#include "cocos-ext.h"
#include "TCPClient.h"
#include "TradingUI.h"
#include "RechargeUi.h"
#include "UiManager.h"
#include "TradingUI.h"
#include "TradingMgr.h"
#include "SQLCommand.h"
#include "BaseDefine.h"
#include "localPlayer.h"
#include "RoleManager.h"
#include "TradingProto.h"
#include "TradingProto.h"
#include "PackageManager.h"
#include "ReceiveRewardUi.h"
#include "NumericalIniMgr.h"
#include "TradingGetItemList.h"
#include "TradingEquipItemTipUI.h"
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
#include "TradingBuyRightFinalItemList.h"
#include "SecondVerifyMgr.h"
#include "f_simple_res_guard.h"

#define MAX_GET_SEND_MAG_SIZE 20

using namespace cocos2d;
using namespace cocos2d::extension;

tagTradingItemDataMsg FindItemData::m_val;	
tagTradingGetItemDataMsg FindItemGetData::m_get_val;
tagTradingOntherItemDataMsg FindOntherItemData::m_onther_val;

TradingMgr::TradingMgr()
	:m_nOneClassId(0)
	,m_nTowClassId(0)
	,m_nLevel(ET_LEVEL_Begin)
	,m_nProfession(EV_Trading_Class_Begin)
	,m_bPriceState(true)
	,m_bLevelClick(false)
	,m_bProfessionClick(false)
	,m_bOneClassClick(false)
	,m_bTowClassClick(false)
	,m_bProfessionClass(false)
	,m_bLvClass(false)
	,m_nSearchSendMsgCount(0)
	,m_nSearchReceiveMsgCount(0)
	,m_bTradingSearch(false)
	,m_bTradingUpMsgIsReceive(true)
	,m_bTradingDownMsgIsReceive(true)
	,m_bTradingGetOneIsReceive(true)
	,m_bTradingGetAllIsReceive(true)
	,m_bTradingLoadDataIsReceive(true)
{
	getTradingInfo();
}

TradingMgr::~TradingMgr()
{

}

TradingMgr* TradingMgr::getInstance()
{
	static TradingMgr mgr;
	return &mgr; 
}

void TradingMgr::getTradingInfo()
{
	TradingData info;
	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM TradingData");
	c_sql_table* table = c_db_manager::getSingleton()->create_table();
	std::vector<std::string> vecSegId;
	std::vector<std::string> vecSegName;
	std::vector<std::string> vecSegIcon;
	while(table->retrieve_row())
	{
		unsigned int idx = table->get_index("oneclassId");
		info.oneclassId = table->get_integer32(idx);

		idx = table->get_index("labelIcon");
		info.labelIcon = table->get_text(idx);

		idx = table->get_index("towclassId");
		vecSegId.clear();
		part_string(table->get_text(idx).c_str(), vecSegId, ',');

		idx = table->get_index("towclassName");
		vecSegName.clear(); 
		part_string(table->get_text(idx).c_str(), vecSegName, ',');

		idx = table->get_index("towclassIcon");
		vecSegIcon.clear();
		part_string(table->get_text(idx).c_str(), vecSegIcon, ',');

		CCAssert(vecSegId.size() == vecSegName.size() && vecSegId.size() == vecSegIcon.size(),CCString::createWithFormat("TradingData fail oneclassId:%d",info.oneclassId)->getCString());

		info.vTowclassInfo.clear();
		for(size_t i = 0 ; i < vecSegId.size();i++)
		{
			TowclassInfo data;
			data.oneclassId = info.oneclassId;
			data.towclassId = boost::lexical_cast<int>(vecSegId[i].c_str());
			data.towclassName = vecSegName[i];
			data.towclassIcon = vecSegIcon[i];
			info.vTowclassInfo.push_back(data);
		}

		idx = table->get_index("professionClass");
		info.professionClass = table->get_boolean(idx);

		idx = table->get_index("lvClass");
		info.lvClass = table->get_boolean(idx);

		_TradingInfo.insert(std::make_pair(info.oneclassId,info));
	}

	c_db_manager::getSingleton()->destroy_table(table);
	c_db_manager::getSingleton()->end_operation(cmd);
}

void TradingMgr::SetDelayShow(bool value)
{
	TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
	if(NULL != ui)
		ui->SetDelayShow(value);
}

void TradingMgr::init()
{
	TCP_CLIENT->register_net_cmd("NET_G2C_Trading_Up",this,&TradingMgr::PushUpItem);
	TCP_CLIENT->register_net_cmd("NET_G2C_Load_Trading_Role_Up",this,&TradingMgr::InitAllUpItem);
	TCP_CLIENT->register_net_cmd("NET_G2C_Load_Trading_Buy_Item",this,&TradingMgr::UpdateBuyItem);
	TCP_CLIENT->register_net_cmd("NET_G2C_Delete_Trading_Role_Down",this,&TradingMgr::DeleteRoleTradingItem);  
	TCP_CLIENT->register_net_cmd("NET_G2C_Load_Trading_Role_Get_Item",this,&TradingMgr::InitGetTradingItem);
	TCP_CLIENT->register_net_cmd("NET_G2C_Trading_BuyItem",this,&TradingMgr::BuyTradingItem);
	TCP_CLIENT->register_net_cmd("NET_G2C_Trading_One_Get_Item",this,&TradingMgr::GetTradingOneItem);
	TCP_CLIENT->register_net_cmd("NET_G2C_Load_Trading_Onter_Buy_Item",this,&TradingMgr::UpdateOntherItem);
	TCP_CLIENT->register_net_cmd("NET_G2C_Trading_All_Get_Item",this,&TradingMgr::GetTradingAllItem);
	TCP_CLIENT->register_net_cmd("NET_G2C_remove_gem_result",this,&TradingMgr::RemoveItemGem);
	TCP_CLIENT->register_net_cmd("NET_G2C_update_trading_state",this,&TradingMgr::updateOverTimeState);
	TCP_CLIENT->register_net_cmd("NET_G2C_trading_Server_state",this,&TradingMgr::trading_Server_state);	
	TCP_CLIENT->register_net_cmd("NET_G2C_Trading_Load_Search_Item",this,&TradingMgr::UpdateSearchItem);	
	TCP_CLIENT->register_net_cmd("NET_G2C_Trading_Get_Search_Item",this,&TradingMgr::UpdateGetSearchItemInfo);	
}

void TradingMgr::destroy()
{
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Trading_Up",this,&TradingMgr::PushUpItem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Load_Trading_Role_Up",this,&TradingMgr::InitAllUpItem);
   	TCP_CLIENT->unregister_net_cmd("NET_G2C_Load_Trading_Buy_Item",this,&TradingMgr::UpdateBuyItem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Delete_Trading_Role_Down",this,&TradingMgr::DeleteRoleTradingItem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Load_Trading_Role_Get_Item",this,&TradingMgr::InitGetTradingItem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Trading_BuyItem",this,&TradingMgr::BuyTradingItem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Trading_One_Get_Item",this,&TradingMgr::GetTradingOneItem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Load_Trading_Onter_Buy_Item",this,&TradingMgr::UpdateOntherItem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Trading_All_Get_Item",this,&TradingMgr::GetTradingAllItem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_remove_gem_result",this,&TradingMgr::RemoveItemGem);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_update_trading_state",this,&TradingMgr::updateOverTimeState);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_trading_Server_state",this,&TradingMgr::trading_Server_state);
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Trading_Load_Search_Item",this,&TradingMgr::UpdateSearchItem);	
	TCP_CLIENT->unregister_net_cmd("NET_G2C_Trading_Get_Search_Item",this,&TradingMgr::UpdateGetSearchItemInfo);	
}

unsigned int TradingMgr::trading_Server_state(s_net_cmd* cmd)
{
	NET_G2C_trading_Server_state* msg = (NET_G2C_trading_Server_state*)cmd;	 

	ToolTip::getInstance()->push(GET_STR(9413));

	TradingMgr::getInstance()->m_bTradingGetAllIsReceive = true;
	TradingMgr::getInstance()->m_bTradingUpMsgIsReceive = true;
	TradingMgr::getInstance()->m_bTradingDownMsgIsReceive = true;
	TradingMgr::getInstance()->m_bTradingGetOneIsReceive = true;
	TradingMgr::getInstance()->m_bTradingLoadDataIsReceive = true;	

	return 0;
}

unsigned int TradingMgr::updateOverTimeState(s_net_cmd* cmd)
{
	NET_G2C_update_trading_state* msg = (NET_G2C_update_trading_state*)cmd;

	tagTradingGetItemDataMsg item;
	item.n64Serial = msg->n64Serial;
	tagTradingGetItemDataMsg *data = FindTradingGetItem(item);
	if(NULL == data) 
		return 0;

	data->nState = msg->nState;

	TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
	if(NULL != ui)
		ui->updateGetItemState(item.dwUpRoleID, msg->n64Serial,ETT_TradingOverTime);

	return 0;
}

unsigned int TradingMgr::RemoveItemGem(s_net_cmd* cmd)
{
	NET_G2C_remove_gem_result* msg = (NET_G2C_remove_gem_result*)cmd;
	if(E_trading_success == msg->errorInfo)
	{
		std::vector<remove_gemItem> recvInfo;
		recvInfo.clear();
		size_t size = msg->size - sizeof(s_net_cmd) - sizeof(DWORD);
		for(size_t i = 0; i < size / sizeof(remove_gemItem) ; i++)
		{
			recvInfo.push_back( msg->data_infos[i]);
		}

		std::vector<remove_gemItem>::iterator iter = recvInfo.begin();
		std::vector<remove_gemItem>::iterator iterend = recvInfo.end();
		for(; iter != iterend; iter++) 
		{
			if(0 < iter->itemid && 0 < iter->itemnum)
				ReceiveRewardUiMgr::GetInstance()->setItemData(iter->itemid, iter->itemnum);
		}

		ReceiveRewardUiMgr::GetInstance()->openRewardUi();

		TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
		if(NULL != ui)
			ui->updateSellRightItemList(false);
	}
	else if(E_Unbeset_Not_bag_free == msg->errorInfo)
		ToolTip::getInstance()->push(GET_STR(2027));

	return 0;
}

unsigned int TradingMgr::GetTradingAllItem(s_net_cmd* cmd)
{
   	NET_G2C_Trading_All_Get_Item* msg = (NET_G2C_Trading_All_Get_Item*)cmd;
	if(E_trading_success == msg->msgInfo)
	{
		m_vGetTradingInfo.clear();
		TradingUILayer* ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
		if(NULL != ui)
			ui->DeleteAllGetItemList();
	}
	else if(E_trading_not_gold == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR(2007));
	else if(E_trading_not_yuanbao == msg->msgInfo)
		RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
	else if(E_Con_NotEnoughSpace == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR(7280));

	/*MiniMapUi* ui = World::getInstance()->getMiniMapUi();
	if(	NULL != ui )
	{
		if(m_vGetTradingInfo.empty())
			ui->setTradingRedPoint(false);
		else
			ui->setTradingRedPoint(true);
	}*/
	setSystemRedFlag();

	m_bTradingGetAllIsReceive = true;

	return 0;
}

unsigned int TradingMgr::GetTradingOneItem(s_net_cmd* cmd)
{
	NET_G2C_Trading_One_Get_Item* msg = (NET_G2C_Trading_One_Get_Item*)cmd;

	if(E_trading_success == msg->msgInfo)
	{
		tagTradingGetItemDataMsg item;
		item.n64Serial	= msg->n64Serial;
		DeleteTradingGetItem(item);

		TradingUILayer* ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
		if(NULL != ui)
		{
			ui->DeleteGetItemListById(msg->n64Serial);
			ui->updateGetItemList();
		}
	}
	else if(E_trading_not_gold == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR(2007));
	else if(E_trading_not_yuanbao == msg->msgInfo)
		RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
	else if(E_Con_NotEnoughSpace == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR(7280));

	m_bTradingGetOneIsReceive = true;

	return 0;
}	

unsigned int TradingMgr::BuyTradingItem(s_net_cmd* cmd)
{
	NET_G2C_Trading_BuyItem* msg = (NET_G2C_Trading_BuyItem*)cmd;

	if(E_trading_success == msg->msgInfo)
	{
		ToolTip::getInstance()->push(GET_STR( 9342 ));
		PushTradingGetItem(&(msg->item));

		if(m_bTradingLoadDataIsReceive)
		{
			if(!TradingMgr::getInstance()->m_bTradingSearch)
			{
				const std::string strMsg = TradingMgr::getInstance()->GetTradingMsgString();	
				TradingMgr::getInstance()->GetLoadTradingBuyDataByMsg(strMsg);
			}
			else
				TradingMgr::getInstance()->GetLoadSearchTradingBuyDataByMsg();
		}
	}
	else if(E_trading_same_role == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR( 9304 ));
	if(E_trading_get_no_item == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR( 9307 ));
	else if(E_trading_get_container_count_fail == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR(9414));
	else if(E_trading_not_yuanbao == msg->msgInfo)
		RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
	else if(E_trading_already_buy_down == msg->msgInfo)
	{
		if(m_bTradingLoadDataIsReceive)
		{
			if(!TradingMgr::getInstance()->m_bTradingSearch)
			{
				const std::string strMsg = TradingMgr::getInstance()->GetTradingMsgString();	
				TradingMgr::getInstance()->GetLoadTradingBuyDataByMsg(strMsg);
			}
			else
				TradingMgr::getInstance()->GetLoadSearchTradingBuyDataByMsg();
		}

		ToolTip::getInstance()->push(GET_STR( 9307 ));
	}

	return 0;
}

unsigned int TradingMgr::InitGetTradingItem(s_net_cmd* cmd)
{
	NET_G2C_Load_Trading_Role_Get_Item *msg =  (NET_G2C_Load_Trading_Role_Get_Item*)cmd;

	m_vGetTradingInfo.clear();
	if(E_trading_success == msg->msgInfo)
	{
		size_t size = msg->size - sizeof(s_net_cmd) - sizeof(int);
		for(size_t i = 0; i < size / sizeof(tagTradingGetItemDataMsg); i++)
		{
			m_vGetTradingInfo.push_back(msg->item[i]);
		}
	}

	/*MiniMapUi* ui = World::getInstance()->getMiniMapUi();
	if(	NULL != ui )
	{
		if(m_vGetTradingInfo.empty())
			ui->setTradingRedPoint(false);
		else
			ui->setTradingRedPoint(true);
	}*/
	setSystemRedFlag();

	return 0;
}

unsigned int TradingMgr::PushUpItem(s_net_cmd* cmd)
{
	NET_G2C_Trading_Up* msg = (NET_G2C_Trading_Up*)cmd;

	if(E_trading_success == msg->msgInfo)
	{
		m_vRoleTradingInfo.push_back(msg->item);

		TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
		if(NULL != ui && IS_UI_OPEN(WCT_TradingUI))
		{
			ui->updateSellLeftItemList();
			ui->UpdatePushSellNum();
			if(!msg->bIsSplit)
			{
				if(0 < msg->nOld64_serial)
					ui->DeleteSellRightItemById(msg->nOld64_serial);
			}
			else
			{
				if(0 < msg->nOld64_serial)
					ui->DeleteSellRightItemById(msg->nOld64_serial);

				ui->updateSellRightItemList(false);
			}
		}

		ToolTip::getInstance()->push(GET_STR(9312));
	}
	else if(E_trading_not_gold == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR(2007));
	else if(E_trading_get_container_count_fail == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR(9414));
	else if(E_trading_not_yuanbao == msg->msgInfo)
		RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
	else if(E_trading_no_up == msg->msgInfo)
		ToolTip::getInstance()->push(GET_STR(9413));

	CLOSE_UI(WCT_TradingTipUI);	
	m_bTradingUpMsgIsReceive = true;
	return 0;
}

unsigned int TradingMgr::InitAllUpItem(s_net_cmd* cmd)
{
	NET_G2C_Load_Trading_Role_Up* msg = (NET_G2C_Load_Trading_Role_Up*)cmd;	

	m_vRoleTradingInfo.clear();
	size_t size = msg->size - sizeof(s_net_cmd);
	for(size_t i = 0; i < size / sizeof(tagTradingItemDataMsg); i++)
	{
	   	m_vRoleTradingInfo.push_back(msg->item[i]);
	}

	return 0;
}

unsigned int TradingMgr::UpdateOntherItem(s_net_cmd* cmd)
{
	NET_G2C_Load_Trading_Onter_Buy_Item* msg = (NET_G2C_Load_Trading_Onter_Buy_Item*)cmd;	

	m_vOntherTradingInfo.clear();
	if(E_trading_success == msg->msgInfo)
	{
		size_t size = msg->size - sizeof(s_net_cmd) - sizeof(int);
		for(size_t i = 0; i < size / sizeof(tagTradingOntherItemDataMsg); i++)
		{
			m_vOntherTradingInfo.push_back(msg->item[i]);
		}
	}

	TradingEquipItemTipUILayer * uitip = getUiNodeByTag<TradingEquipItemTipUILayer>(WCT_TradingTipUI);
	if(NULL != uitip)
		uitip->updateItemTipList();

	/*TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
	if(NULL != ui)
		ui->setSellRightTouchEnabled();*/

	return 0;
}

unsigned int TradingMgr::UpdateSearchItem(s_net_cmd* cmd)
{
	//NET_G2C_Trading_Load_Search_Item* msg = (NET_G2C_Trading_Load_Search_Item*)cmd;

	m_nSearchReceiveMsgCount++;
	if(m_nSearchSendMsgCount == m_nSearchReceiveMsgCount)
	{
		m_bTradingLoadDataIsReceive = true;
		m_nSearchSendMsgCount = 0;
		m_nSearchReceiveMsgCount = 0;
		SetDelayShow(false);
		TradingMgr::getInstance()->GetLoadSearchTradingBuyDataByMsg();
	}
	
	return 0;
}

unsigned int TradingMgr::UpdateGetSearchItemInfo(s_net_cmd* cmd)
{
	NET_G2C_Trading_Get_Search_Item* msg = (NET_G2C_Trading_Get_Search_Item*)cmd;	

	m_vBuyTradingInfo.clear();
	if(E_trading_success == msg->msgInfo)
	{
		size_t msgsize = msg->size - sizeof(s_net_cmd) - sizeof(int);
		for(size_t i = 0; i < msgsize / sizeof(tagTradingItemDataMsg); i++)
		{
			m_vBuyTradingInfo.push_back(msg->item[i]);
		}
	}

	TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
	if(NULL != ui)
		ui->updateBuyFinalItemRightList(msg->isHave);

	m_bTradingLoadDataIsReceive = true;

	SetDelayShow(false);

	return 0;
}

unsigned int TradingMgr::UpdateBuyItem(s_net_cmd* cmd)
{
	NET_G2C_Load_Trading_Buy_Item* msg = (NET_G2C_Load_Trading_Buy_Item*)cmd;	

	m_vBuyTradingInfo.clear();
	if(E_trading_success == msg->msgInfo)
	{
		size_t msgsize = msg->size - sizeof(s_net_cmd) - sizeof(int);
		for(size_t i = 0; i < msgsize / sizeof(tagTradingItemDataMsg); i++)
		{
			m_vBuyTradingInfo.push_back(msg->item[i]);
		}
	}

	TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
	if(NULL != ui)
		ui->updateBuyFinalItemRightList(msg->isHave);

	SetDelayShow(false);

	m_bTradingLoadDataIsReceive = true;
	return 0;
}

void TradingMgr::PushTradingBuyItem(tagTradingItemDataMsg item)
{
	FindItemData::SetTagTradingItem(item);
	tagTrading_item_vector::iterator iter = std::find_if(m_vBuyTradingInfo.begin(),m_vBuyTradingInfo.end(),FindItemData());
	if(iter == m_vBuyTradingInfo.end())
		m_vBuyTradingInfo.push_back(item);
}

tagTradingItemDataMsg* TradingMgr::FindTradingBuyItem(tagTradingItemDataMsg item)
{
	FindItemData::SetTagTradingItem(item);
	tagTrading_item_vector::iterator iter = std::find_if(m_vBuyTradingInfo.begin(),m_vBuyTradingInfo.end(),FindItemData());
	if(iter != m_vBuyTradingInfo.end())
		return &(*iter);

	return NULL;	
}

tagTradingGetItemDataMsg* TradingMgr::FindTradingGetItem(tagTradingGetItemDataMsg item)
{
	FindItemGetData::SetTagTradingItem(item);
	tagTrading_get_item_vector::iterator iter = std::find_if(m_vGetTradingInfo.begin(),m_vGetTradingInfo.end(),FindItemGetData());
	if(iter != m_vGetTradingInfo.end())
		return &(*iter);

	return NULL;	
}

void TradingMgr::PushTradingGetItem(tagTradingGetItemDataMsg *item)
{
	FindItemGetData::SetTagTradingItem(*item);
	tagTrading_get_item_vector::iterator iter = std::find_if(m_vGetTradingInfo.begin(),m_vGetTradingInfo.end(),FindItemGetData());
	if(iter == m_vGetTradingInfo.end())
	{
		m_vGetTradingInfo.push_back(*item);

		TradingUILayer* ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
		if(NULL != ui)
			ui->PushGetItemListByItem(item);
	}

	/*MiniMapUi* ui = World::getInstance()->getMiniMapUi();
	if(	NULL != ui )
	{
		if(m_vGetTradingInfo.empty())
			ui->setTradingRedPoint(false);
		else
			ui->setTradingRedPoint(true);
	}*/
	setSystemRedFlag();
}

void TradingMgr::DeleteTradingGetItem(tagTradingGetItemDataMsg item)
{
	FindItemGetData::SetTagTradingItem(item);
	tagTrading_get_item_vector::iterator iter = std::find_if(m_vGetTradingInfo.begin(),m_vGetTradingInfo.end(),FindItemGetData());
	if(iter != m_vGetTradingInfo.end())
	{
		m_vGetTradingInfo.erase(iter);
		TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
		if(NULL != ui)
		{
			ui->DeleteGetItemListById(item.n64Serial);
			ui->updateGetItemList();
		}
	}

	/*MiniMapUi* ui = World::getInstance()->getMiniMapUi();
	if(	NULL != ui )
	{
		if(m_vGetTradingInfo.empty())
			ui->setTradingRedPoint(false);
		else
			ui->setTradingRedPoint(true);
	}*/
	setSystemRedFlag();
}

void TradingMgr::PushTradingOntherItem(tagTradingOntherItemDataMsg item)
{
	FindOntherItemData::SetTagTradingItem(item);
	tagTrading_onther_item_vector::iterator iter = std::find_if(m_vOntherTradingInfo.begin(),m_vOntherTradingInfo.end(),FindOntherItemData());
	if(iter == m_vOntherTradingInfo.end())
		m_vOntherTradingInfo.push_back(item);
}

void TradingMgr::DeleteTradingOntherItem(tagTradingOntherItemDataMsg item)
{
	FindOntherItemData::SetTagTradingItem(item);
	tagTrading_onther_item_vector::iterator iter = std::find_if(m_vOntherTradingInfo.begin(),m_vOntherTradingInfo.end(),FindOntherItemData());
	if(iter != m_vOntherTradingInfo.end())
		m_vOntherTradingInfo.erase(iter);
}

unsigned int TradingMgr::DeleteRoleTradingItem(s_net_cmd* cmd)
{
	NET_G2C_Delete_Trading_Role_Down* msg = (NET_G2C_Delete_Trading_Role_Down*)cmd;	

	if(E_trading_success == msg->msgInfo || E_trading_uptime_to_overtime == msg->msgInfo)
	{
		tagTradingItemDataMsg item;
		item.m_ItemInfo.n64_serial = msg->n64Serial;
		FindItemData::SetTagTradingItem(item);
		tagTrading_item_vector::iterator iter = std::find_if(m_vRoleTradingInfo.begin(),m_vRoleTradingInfo.end(),FindItemData());
		if(iter != m_vRoleTradingInfo.end())
		{
			tagTradingGetItemDataMsg item;
			item.n64Serial		=	iter->m_ItemInfo.n64_serial;	
			item.dwItemId		=	iter->m_ItemInfo.dw_data_id;	
			item.dwUpRoleID		=	iter->dwUpRoleID;		
			item.dwBuyRoleID	=	iter->dwBuyRoleID;	
			item.nUnitPrice		=	iter->nUnitPrice;		
			item.nNumber		=	iter->nNumber;		
			item.nState			=	msg->nState;			
			item.tOvertime		=	msg->tOvertime;	

			PushTradingGetItem(&item);

			m_vRoleTradingInfo.erase(iter);

			if(ETT_TradingDown == msg->nState)
				ToolTip::getInstance()->push(GET_STR(9313));

			if(msg->isBuy)
				ToolTip::getInstance()->push(GET_STR(9366));

			TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
			if(NULL == ui)
				return -1;

			ui->updateSellLeftItemList();

			CLOSE_UI(WCT_TradingTipUI);
			NumKeypad::getInstance()->close();

			ui->UpdatePushSellNum();
		}
	}
	else if(ETT_TradingBuySell == msg->nState)
	{
		tagTradingItemDataMsg item;
		item.m_ItemInfo.n64_serial = msg->n64Serial;
		FindItemData::SetTagTradingItem(item);
		tagTrading_item_vector::iterator iter = std::find_if(m_vRoleTradingInfo.begin(),m_vRoleTradingInfo.end(),FindItemData());
		if(iter != m_vRoleTradingInfo.end())
		{
			tagTradingGetItemDataMsg item;
			item.n64Serial		=	iter->m_ItemInfo.n64_serial;	
			item.dwItemId		=	iter->m_ItemInfo.dw_data_id;	
			item.dwUpRoleID		=	iter->dwUpRoleID;		
			item.dwBuyRoleID	=	iter->dwBuyRoleID;	
			item.nUnitPrice		=	iter->nUnitPrice;		
			item.nNumber		=	iter->nNumber;		
			item.nState			=	iter->nState;			
			item.tOvertime		=	iter->tOvertime;	
			item.tUptime		=	iter->tUptime;	

			PushTradingGetItem(&item);

			m_vRoleTradingInfo.erase(iter);
		}
	}

	TradingMgr::getInstance()->m_bTradingDownMsgIsReceive = true;

	return 0;
}

void TradingMgr::SendTradingUpMsg(DWORD	dwClientRoleID,INT64 n64Serial, DWORD dwItemId, int nUnitPrice,int nNumber)
{		
	if(0 == nNumber || 	  
		0 == nUnitPrice ||	 
		0 >= dwClientRoleID ||
		0 >= n64Serial ||
		0 >= dwItemId)
		return ;

	NET_C2G_Trading_Up send;
	send.dwClientRoleID = dwClientRoleID;
	send.dwItemId		= dwItemId;
	send.n64Serial		= n64Serial;
	send.nUnitPrice		= nUnitPrice;
	send.nNumber		= nNumber ;

	m_bTradingUpMsgIsReceive = false;

	std::function<void(bool)> func = [send](bool isSuccess){
		if (isSuccess)
			TCP_CLIENT->send_net_cmd(&send , NP_NORMAL , false);
		else
			TradingMgr::getInstance()->m_bTradingUpMsgIsReceive = true;
	};
	SecondVerifyMgr::getInstance()->try_request_safe_verify(func);

	
}

// std::string TradingMgr::preSubLevelToMsg(int level)
// {		
// 	CC_ASSERT(0 < level && 100 >= level);
// 
// 	if(0 < level&& 20 >= level )
// 		return "1";
// 	else if(20 < level&& 30 >= level)
// 		return "2";
// 	else if(30 < level&& 40 >= level)
// 		return "3";
// 	else if(40 < level&& 50 >= level)
// 		return "4";
// 	else if(50 < level&& 60 >= level)
// 		return "5";
// 	else if(60 < level)
// 		return "6";
// }

int TradingMgr::preSellLeftItemNolist()
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return 0;

   int level = player->getLevel();
   //得到相应的开启格子数
   CC_ASSERT(0< level && 100 >= level);

   if(40 < level)
	   return 8;
   else if(37 < level )
	   return 7;
   else if(34 < level)
	   return 6;
   else if(31 < level)
	   return 5;
   else if(28 < level)
	   return 4;
   else if(25 < level)
	   return 3;
   else if(22 < level)
	   return 2;
   else if(0 < level)
	   return 1;
   else 
	   return 8;
}

std::string TradingMgr::preSellLeftItemNolistString( int index)
{	
	if(1 == index)
		return GET_STR(9315);
	else if(2 == index)
		return GET_STR(9316);
	else if(3 == index)
		return GET_STR(9317);
	else if(4 == index)
		return GET_STR(9318);
	else if(5 == index)
		return GET_STR(9319);
	else if(6 == index)
		return GET_STR(9320);
	else if(7 == index)
		return GET_STR(9321);

	return "";
}

const std::string TradingMgr::GetTradingMsgString()
{
	std::stringstream oneoss;
	oneoss << TradingMgr::getInstance()->m_nOneClassId;

	std::stringstream twooss;
	twooss << TradingMgr::getInstance()->m_nTowClassId;

	std::stringstream prooss;
	prooss << TradingMgr::getInstance()->m_nProfession;

	std::stringstream leveloss;
	leveloss << TradingMgr::getInstance()->m_nLevel;

	std::string preStr = oneoss.str() + twooss.str() + prooss.str() + leveloss.str();
	return preStr;
}

void TradingMgr::GetBuyItemByMsg(const string strMsg)
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	

	std::function<void(bool)> func = [strMsg,player](bool isSuccess){
		if (isSuccess)
		{
			wchar_t temp[512];
			memset(temp , 0 , 512*sizeof(wchar_t));
			Utf8ToUtf16(strMsg.c_str() , temp , 512 , strMsg.length());
			unsigned int utf_size = _utf_length(temp);
			if(0 == utf_size)
				return ;

			int size = (utf_size - 1) * sizeof(wchar_t) + sizeof(NET_C2G_Trading_BuyItem);
			if(sizeof(NET_C2G_Trading_BuyItem) > size)
				return ;

			unsigned char* pMsg = new unsigned char[size];
			NET_C2G_Trading_BuyItem* send = (NET_C2G_Trading_BuyItem*)pMsg;
			send->id = message_id_crc("NET_C2G_Trading_BuyItem");
			send->size = size;
			send->dwClientRoleID = player->getId();
			send->n64Serial = TradingBuyRightFinalItemList::m_n64_serial;
			send->dwYuanBao = TradingBuyRightFinalItemList::m_itemPriceNum * TradingBuyRightFinalItemList::m_itemNumber; 
			memcpy(send->Key,temp,utf_size*sizeof(wchar_t));
			TCP_CLIENT->send_net_cmd(send , NP_NORMAL , false);
			if (pMsg)
			{
				delete[] pMsg;
				pMsg = NULL;
			}
		}
	};
	SecondVerifyMgr::getInstance()->try_request_safe_verify(func);

	//TCP_CLIENT->send_net_cmd(send,NP_NORMAL, false);
	
}

void TradingMgr::GetLoadTradingOneDataByMsg()
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	if(m_vGetTradingInfo.empty())
	{
		ToolTip::getInstance()->push(GET_STR(9276));
		return ;
	}

	if(0 == TradingGetItemList::m_n64_serial)
	{
		ToolTip::getInstance()->push(GET_STR( 9275 ));
		return;
	}

	tagTradingGetItemDataMsg item;
	item.n64Serial = TradingGetItemList::m_n64_serial;
	tagTradingGetItemDataMsg *data = FindTradingGetItem(item);
	if(NULL == data)
		return ;

	//int grid = 0;
	if(ETT_TradingBuySell == data->nState)
	{
		if(data->dwUpRoleID != player->getId())
		{
			//const ItemTypeData& ItemType = PackageManager::getInstance()->getItemTypeData(data->dwItemId);
			int bagCount = PackageManager::getInstance()->getBlankCount();//获取玩家背包空格数
			if(bagCount < 1)
			{	//没有位置了
				ToolTip::getInstance()->push(GET_STR(7280));	//包裹已满请先清理包裹
				return ; 
			}
		}
	}
	else if(ETT_TradingSell != data->nState)
	{
		//const ItemTypeData& ItemType = PackageManager::getInstance()->getItemTypeData(data->dwItemId);
		int bagCount = PackageManager::getInstance()->getBlankCount();//获取玩家背包空格数
		if(bagCount < 1)
		{	//没有位置了
			ToolTip::getInstance()->push(GET_STR(7280));	//包裹已满请先清理包裹
			return ; 
		}
	}

	if(ETT_TradingOverTime == data->nState)
	{
		if(PackageManager::getInstance()->getJinBi() < NumericalIniMgr::getInstance()->Get_trading_over_time_money())
		{
			ToolTip::getInstance()->push(GET_STR(2007));	
			return ;
		}
		else
		{
			std::ostringstream ostr;
			ostr << NumericalIniMgr::getInstance()->Get_trading_over_time_money();
			std::string str = replaceStr(GET_STR(9274),"*",ostr.str());

			MessageBoxUi *msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
			msgUi->signalOkBtnPressed.connect(this,&TradingMgr::SendDeleteGetOneItemCallFun);
		}
	}
	else
		SendDeleteGetOneItemCallFun();
}

void TradingMgr::SendDeleteGetOneItemCallFun()
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	if( 0 < TradingGetItemList::m_n64_serial && 0 < TradingGetItemList::m_dwItemId && 0 < TradingGetItemList::m_nNum)
	{
		NET_C2G_Trading_One_Get_Item send;
		send.dwClientRoleID = player->getId();
		send.n64Serial = TradingGetItemList::m_n64_serial;
		send.dwItemId = TradingGetItemList::m_dwItemId;
		send.num = TradingGetItemList::m_nNum;
		TCP_CLIENT->send_net_cmd(&send,NP_NORMAL, false);

		m_bTradingGetOneIsReceive = false;
	}
}

void TradingMgr::GetLoadTradingAllDataByMsg()
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	if(m_vGetTradingInfo.empty())
	{
	  	ToolTip::getInstance()->push(GET_STR(9276));
		return ;
	}

	tagTrading_get_item_vector temp_vector;
	for(size_t i = 0; i < m_vGetTradingInfo.size(); i++)
	{
		if(ETT_TradingBuySell == m_vGetTradingInfo[i].nState)
		{
			if(player->getId() == m_vGetTradingInfo[i].dwUpRoleID)
				continue;
		}
		else if(ETT_TradingSell == m_vGetTradingInfo[i].nState)
			continue;

		  temp_vector.push_back(m_vGetTradingInfo[i]);
	}

	int bagCount = PackageManager::getInstance()->getBlankCount();//获取玩家背包空格数
	if(temp_vector.size() > (size_t)bagCount)
	{
		//没有位置了
		ToolTip::getInstance()->push(GET_STR(7280));	//包裹已满请先清理包裹
		return ;
	}
	
	if(0 >= m_vGetTradingInfo.size())
		return ;

	int money = 0;
	std::vector<tagTradingGetItemDataMsg>::iterator iterMoney = m_vGetTradingInfo.begin();
	std::vector<tagTradingGetItemDataMsg>::iterator iterMoneyEnd = m_vGetTradingInfo.end();
	for(;iterMoney != iterMoneyEnd ;++iterMoney)
	{
		if(iterMoney->nState == ETT_TradingOverTime)
			money++;
	}

	if(0 < money)
	{
		if(PackageManager::getInstance()->getJinBi() < money * NumericalIniMgr::getInstance()->Get_trading_over_time_money())
		{
			ToolTip::getInstance()->push(GET_STR(2007));	
			return ;
		}
		else
		{
			std::ostringstream ostr;
			ostr << money * NumericalIniMgr::getInstance()->Get_trading_over_time_money();
			std::string str = replaceStr(GET_STR(9274),"*",ostr.str());

			MessageBoxUi *msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
			msgUi->signalOkBtnPressed.connect(this,&TradingMgr::SendDeleteGetAllItemCallFun);
		}
	}
	else
		SendDeleteGetAllItemCallFun();
}

void TradingMgr::GetLoadSearchTradingBuyDataByMsg()
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	NET_C2G_Trading_Get_Search_Item send;
	
	send.ScrollIndex = TradingUILayer::m_ScrollViewIndex;
	send.bIsPrice = TradingMgr::getInstance()->m_bPriceState;
	send.dwClientRoleID = player->getId();

	TCP_CLIENT->send_net_cmd(&send, NP_NORMAL, false);

	m_bTradingLoadDataIsReceive = false;
	SetDelayShow(true);
}

void TradingMgr::GetLoadTradingSearchItemInfo(const string strMsg,std::vector<DWORD> &itemInfo)
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	if(itemInfo.empty() || strMsg.empty())
	{
		m_vBuyTradingInfo.clear();
		m_nSearchSendMsgCount = 0;
		m_nSearchReceiveMsgCount = 0;
		TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
		if(NULL != ui)
			ui->updateBuyFinalItemRightList(false);

		return ;
	}

	if(0 != m_nSearchSendMsgCount)
		return ;

	int count = 0;
	std::vector<DWORD> item_vector;
	std::vector<DWORD>::iterator iter = itemInfo.begin();
	std::vector<DWORD>::iterator iterEnd = itemInfo.end();
	std::vector<DWORD>::iterator iter_tmp = iter;
	while(iter_tmp != iterEnd)
	{	
		iter_tmp = iter++;
		item_vector.push_back(*iter_tmp);
		if( iter == iterEnd || (MAX_GET_SEND_MAG_SIZE - 1) == count)
		{
			int size = (((item_vector.size() - 1) * sizeof(DWORD)) + sizeof(NET_C2G_Trading_Load_Search_Item));
			if(sizeof(NET_C2G_Trading_Load_Search_Item) > size)
				return;

			unsigned char* pMsg = new unsigned char[size];
			GUARD_NEW_ARRAY_PTR(pMsg);
			NET_C2G_Trading_Load_Search_Item* send = (NET_C2G_Trading_Load_Search_Item*)pMsg;
			send->id = message_id_crc("NET_C2G_Trading_Load_Search_Item");
			send->size = size;
			send->dwClientRoleID = player->getId();
			send->bIsPrice = TradingMgr::getInstance()->m_bPriceState;
			send->bIsClear = (0 == m_nSearchSendMsgCount ? true : false);
			std::vector<DWORD>::iterator iter_v_Begin = item_vector.begin();
			std::vector<DWORD>::iterator iter_v_End = item_vector.end();
			for(int i = 0;iter_v_Begin != iter_v_End; iter_v_Begin++,i++)
			{
				send->dwItemId[i] = *iter_v_Begin;
			}

			m_nSearchSendMsgCount++;
			TCP_CLIENT->send_net_cmd(send,NP_NORMAL, false);
			//CC_SAFE_DELETE_ARRAY(pMsg);

			count = 0;
			item_vector.clear();
			if(iter == iterEnd)
				break;
		}
		else
			count++;
	}

	m_bTradingLoadDataIsReceive = false;
	SetDelayShow(true);
}

void TradingMgr::SendDeleteGetAllItemCallFun()
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	int count = 0;
	std::vector<tagTradingGetItemDataMsg> item_vector;
	std::vector<tagTradingGetItemDataMsg>::iterator iter = m_vGetTradingInfo.begin();
	std::vector<tagTradingGetItemDataMsg>::iterator iterEnd = m_vGetTradingInfo.end();
	std::vector<tagTradingGetItemDataMsg>::iterator iter_tmp = iter;
	while(iter_tmp != iterEnd)
	{	
		iter_tmp = iter++;
		item_vector.push_back(*iter_tmp);
		if( iter == iterEnd || (MAX_GET_SEND_MAG_SIZE  - 1) == count)
		{
			int size = ( (item_vector.size() - 1) * sizeof(GetitemData) + sizeof(NET_C2G_Trading_All_Get_Item));
			if(sizeof(NET_C2G_Trading_All_Get_Item) > size)
				return;

			unsigned char* pMsg = new unsigned char[size];
			GUARD_NEW_ARRAY_PTR(pMsg);
			NET_C2G_Trading_All_Get_Item* send = (NET_C2G_Trading_All_Get_Item*)pMsg;
			send->id = message_id_crc("NET_C2G_Trading_All_Get_Item");
			send->size = size;
			send->dwClientRoleID = player->getId();

			std::vector<tagTradingGetItemDataMsg>::iterator iter_v_Begin = item_vector.begin();
			std::vector<tagTradingGetItemDataMsg>::iterator iter_v_End = item_vector.end();
			for(int i = 0;iter_v_Begin != iter_v_End; iter_v_Begin++,i++)
			{
				tagTradingGetItemDataMsg item;
				item.n64Serial = iter_v_Begin->n64Serial;
				tagTradingGetItemDataMsg *data = FindTradingGetItem(item);
				if(NULL == data)
				{
					//CC_SAFE_DELETE_ARRAY(pMsg);
					return ;  
				}
				send->ItemData[i].dwItemId = data->dwItemId;
				send->ItemData[i].n64Serial = data->n64Serial;
				send->ItemData[i].nNum = data->nNumber;
				send->ItemData[i].dwUpRoleID = data->dwUpRoleID;
			}

			TCP_CLIENT->send_net_cmd(send,NP_NORMAL, false);
			//CC_SAFE_DELETE_ARRAY(pMsg);
			m_bTradingGetAllIsReceive = false;

			count = 0;
			item_vector.clear();
			if(iter == iterEnd)
				break;
		}
		else
			count++;
	}
}

//是否满足需要的格子数量
bool TradingMgr::IsHaveFreeSize(int size, const tagTrading_get_item_vector &ItemData,int bagCount)
{
	if(0 == size)
		return true;

	int grid = 0;//需要的格子数
	for(int i = 0; i < size; i++)
	{
		if(!MIsEquipment(ItemData[i].dwItemId))
		{
			const ItemTypeData& ItemType = PackageManager::getInstance()->getItemTypeData(ItemData[i].dwItemId);
			if(0 == ItemType.stackNumber)
				return false;

			int count = PackageManager::getInstance()->getItemNumber(EICT_Bag,ItemData[i].dwItemId);
			int remainder = count % ItemType.stackNumber;//剩余数

			if(0 >= ItemType.stackNumber)
				return false;

			int needNum  = (remainder + ItemData[i].nNumber) / ItemType.stackNumber;
			int remainder2 = (remainder + ItemData[i].nNumber) % ItemType.stackNumber;//剩余数

			if(0 < remainder2  / ItemType.stackNumber)
				grid += (needNum + 1);
			else
				grid += needNum;
		}
		else
			grid +=1;
	}

	return grid <= bagCount;
}

void TradingMgr::GetLoadTradingBuyDataByMsg(const string strMsg)
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	if(strMsg.empty())
		return ;

	wchar_t temp[512];
	memset(temp , 0 , 512*sizeof(wchar_t));
	Utf8ToUtf16(strMsg.c_str() , temp , 512 , strMsg.length());
	unsigned int utf_size = _utf_length(temp);
	if(0 == utf_size)
		return ;

	int size = (utf_size - 1) * sizeof(wchar_t) + sizeof(NET_C2G_Load_Trading_Buy_Item);

	if(sizeof(NET_C2G_Load_Trading_Buy_Item) > size)
		return ;

	unsigned char* pMsg = new unsigned char[size];
	GUARD_NEW_ARRAY_PTR(pMsg);
	NET_C2G_Load_Trading_Buy_Item* send = (NET_C2G_Load_Trading_Buy_Item*)pMsg;
	send->id = message_id_crc("NET_C2G_Load_Trading_Buy_Item");						
	send->ScrollIndex = TradingUILayer::m_ScrollViewIndex;
	send->bIsPrice = TradingMgr::getInstance()->m_bPriceState;
	send->size = size;
	send->dwClientRoleID = player->getId();
	memcpy(send->Key,temp,utf_size*sizeof(wchar_t));
	TCP_CLIENT->send_net_cmd(send, NP_NORMAL, false);
	//CC_SAFE_DELETE_ARRAY(pMsg);

	m_bTradingLoadDataIsReceive = false;
	SetDelayShow(true);
}

std::string TradingMgr::GetTradingOtherItemMsgString(const ItemTypeData data)
{
	std::stringstream oneoss;
	oneoss << data.oneclassId;

	std::stringstream twooss;
	twooss << data.towclassId;

	std::string preStr = oneoss.str() + twooss.str() + "0" + "0";
	return preStr;
}

void TradingMgr::GetLoadTradingBuyOtherDataByMsg(const string strMsg,INT64 n64Serial,DWORD dwItemId)
{
	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if(NULL == player)
		return ;

	wchar_t temp[512];
	memset(temp , 0 , 512*sizeof(wchar_t));
	Utf8ToUtf16(strMsg.c_str() , temp , 512 , strMsg.length());
	unsigned int utf_size = _utf_length(temp);
	if(0 == utf_size)
		return ;

	int size = (utf_size - 1) * sizeof(wchar_t) + sizeof(NET_C2G_Load_Trading_Onter_Buy_Item);
	if(sizeof(NET_C2G_Load_Trading_Onter_Buy_Item) > size)
		return ;

	unsigned char* pMsg = new unsigned char[size];
	GUARD_NEW_ARRAY_PTR(pMsg);
	NET_C2G_Load_Trading_Onter_Buy_Item* send = (NET_C2G_Load_Trading_Onter_Buy_Item*)pMsg;
	send->id = message_id_crc("NET_C2G_Load_Trading_Onter_Buy_Item");
	send->size = size;
	send->dwClientRoleID = player->getId();
	send->n64Serial = n64Serial;
	send->dwItemId = dwItemId;
	memcpy(send->Key,temp,utf_size*sizeof(wchar_t));
	TCP_CLIENT->send_net_cmd(send, NP_NORMAL, false);
	//CC_SAFE_DELETE_ARRAY(pMsg);
}

void TradingMgr::Destroy()
{
	m_vRoleTradingInfo.clear();
	m_vBuyTradingInfo.clear();
	m_vGetTradingInfo.clear();
	m_vOntherTradingInfo.clear();
}

void TradingMgr::ClearTradingState()
{
	m_nLevel = ET_LEVEL_Begin;
	m_nProfession = EV_Trading_Class_Begin;
	m_nOneClassId = 0;
	m_nTowClassId = 0;

	m_bProfessionClick = false;
	m_bOneClassClick = false;
	m_bLevelClick = false;
	m_bTowClassClick = false;

	m_bTradingGetAllIsReceive = true;
	m_bTradingUpMsgIsReceive = true;
	m_bTradingDownMsgIsReceive = true;
	m_bTradingGetOneIsReceive = true;
	m_bTradingLoadDataIsReceive = true;	

	m_nSearchSendMsgCount = 0;
	m_nSearchReceiveMsgCount = 0;
}
bool TradingMgr::getIsShowRedFlag()
{
	if(m_vGetTradingInfo.empty()){
		return false;
	}else{
		return true;
	}
}

void TradingMgr::setSystemRedFlag()
{
// 	if(	NULL != GET_UI(SystemUi, WCT_SystemUi) ){
// 		if(m_vGetTradingInfo.empty()){
// 			GET_UI(SystemUi, WCT_SystemUi)->revokeBtnHighLight(SystemUi::BT_JiaoyiHang);
// 		}else{
// 			GET_UI(SystemUi, WCT_SystemUi)->setBtnHighLight(SystemUi::BT_JiaoyiHang);;
// 		}
// 	}

	
	MiniMapUi *miniMapUi = World::getInstance()->getMiniMapUi();
	if(miniMapUi)
	{
		if(m_vGetTradingInfo.empty()){
			miniMapUi->revokeBtnHighLight(WCT_TradingUI);
		}else
		{
			miniMapUi->setBtnHighLight(WCT_TradingUI);
		}
	}

}
