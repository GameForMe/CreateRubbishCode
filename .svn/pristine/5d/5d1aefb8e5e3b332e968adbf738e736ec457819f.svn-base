#include "PackageManager.h"
#include "LoginProto.h"
#include "TCPClient.h"
#include "CmdAdapter.h"
#include "RoleInfoProto.h"
#include "DBMgr.h"
#include "CfgReader.h"
//#include "PackageProto.h"
#include "ChatMgr.h"
#include "PackageUi.h"
#include "RoleEquipUi.h"
#include "tools.h"
#include "ToolTip.h"
#include "World.h"
#include "RoleManager.h"
#include "LocalPlayer.h"
#include "ShortCutUi.h"
#include "StrengthenUi.h"
#include "IndifityUi.h"
#include "StoreUi.h"
#include "InlayUi.h"
#include "EquipLevelUpUi.h"
#include "StorageUi.h"
#include "StoreMgr.h"
#include "UiTools.h"
#include "CfgReader.h"
#include "StringMgr.h"
#include "MessageBoxUi.h"
#include "UiManager.h"
#include "cocos2d.h"
#include "ToolTip.h"
#include "TradingUI.h"
#include "AutoActionProto.h"
#include "SkillManager.h"
#include "ImmediateEquipUi.h"
#include "MountUi.h"
#include "ClientCfg.h"
#include "ConsumptionUi.h"
#include "InputSerialUi.h"
#include "MartialEquipUi.h"
#include "CoreTreeUi.h"
#include "MysteryBoxUi.h"
#include "RoleRingUi.h"
#include "GambleMgr.h"
#include "MiniMapUi.h"
#include "WuXueUi.h"
#include "cangjinggeui.h"
#include "NewStallUI.h"
#include "EquipFusionManager.h"
#include "NewPlayerGuide.h"
#include "UiResourceMgr.h"
#include "EquipLevelUpUiMgr.h"
#include "EquipUpStarUIMgr.h"
#include "WorldPacket.h"
#include "CommonMsgDefine.h"
#include "PlayerStallMgr.h"
#include "EquipShowUi.h"
#include "RewardUi.h"
#include "MessageDispatcher.h"
#include "Auto_ActionMgr.h"
#include "ForgingDecomUI.h"
#include "ReceiveRewardUi.h"
#include "ItemAutoUseDaojuTip.h"
#include "ItemTip.h"
#include "RoleHeadUi.h"
#include "ForgingDecomUI.h"
#include "ForgingMgr.h"
#include "FubenUI.h"
#include "Trading_Define.h"
#include "MysteryBoxUi.h"
#include "NameMgr2.h"
#include "MysteryShop.h"
#include "InstanceMgr.h"
#include "f_string_table.h"
#include "client_common_define.h"
#include "ZZZTitleTipsUI.h"
#include "ZZZAcquireLayer.h"
#include "PackageProto.h"
#include "f_string_util.h"
#include "SecondVerifyMgr.h"
#include "f_formula_helper.h"

#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID || CC_TARGET_PLATFORM == CC_PLATFORM_IOS)
#include "wzolJni.h"
#endif
using namespace cocos2d;

ItemTypeData ItemTypeData::INVALID_TYPE_DATA;
struct UpdateFusionFu;
PackageManager * PackageManager::getInstance()
{
	static PackageManager instance;
	return &instance;
}

PackageManager::PackageManager()
	: _init(false)
	, _canUseItem(true)
	, _yuanBao(0)
	, _diamond(0)
	, _jinBi(0)
	, _totalChargeYuanBao(0)
	, _TempItem(NULL)
	, _TempKungfuItemID_Dest(0)
	, _TempKungfuItemID_Src(0)
	, _TempKungfuMergeType(0)
	, _totalConsumeYuanbao(0)
	, _consumeReplyData(0)
	, m_bIsGongfaOneKey(false)
	, m_nSECount(0)
	,isClickBagDisplayTips(true)
	,isOpenBox(false)
	,isTenChouJiang(false)
	,bImmediateEqui(false)
	,_CurrentLockedConType(EICT_Null)
	,m_reoderGongFaItem(false)
	,m_is_open_recast(false)
	,m_is_open_limit_recast(false)
	,m_is_total_open(false)
	,m_recast_need_level(0)
	,m_recast_need_recharge(0)
	,m_open_behaviour(e_open_null)
	,m_recast_begin_time(INVALID)
	,m_recast_end_time(INVALID)
{
	memset(_conSize, 0, sizeof(_conSize));

	//[bing] 任务给的
	autoequipidarr.push_back(9131020);
	autoequipidarr.push_back(9231020);
	autoequipidarr.push_back(9331020);
	autoequipidarr.push_back(9130020);
	autoequipidarr.push_back(9230020);
	autoequipidarr.push_back(9330020);
	autoequipidarr.push_back(9119030);
	autoequipidarr.push_back(9219030);
	autoequipidarr.push_back(9319030);

	autoequipidarr.push_back(9131030);
	autoequipidarr.push_back(9231030);
	autoequipidarr.push_back(9331030);
	autoequipidarr.push_back(9130030);
	autoequipidarr.push_back(9230030);
	autoequipidarr.push_back(9330030);

	autoequipidarr.push_back(9082010);
	autoequipidarr.push_back(9172016);
	autoequipidarr.push_back(9272016);
	autoequipidarr.push_back(9372016);
	autoequipidarr.push_back(9062018);

	autoequipidarr.push_back(9052019);
	autoequipidarr.push_back(9052019);
	autoequipidarr.push_back(9199026);
	autoequipidarr.push_back(9299026);
	autoequipidarr.push_back(9399026);
	autoequipidarr.push_back(9149016);
	autoequipidarr.push_back(9249016);
	autoequipidarr.push_back(9349016);
	MySteryBoxList.clear();
	MySteryShopList.clear();
	MySteryShopGoodsList.clear();
	MySteryShopList1.clear();
	MySteryShopGoodsList1.clear();
	m_all_recast_item.clear();
	m_recast_data.clear();
	m_all_recast_rebate_map.clear();
	unFreshVersion = 2000;
	unMysteryOpen = 0;
	unGemOpen = 0;
	n64_lastUseItem = 0;

	memset(m_open_condition, 0, sizeof(open_condition_num));
	memset(m_open_condition_num, 0, sizeof(open_condition_num));

}

PackageManager::~PackageManager()
{
	autoequipidarr.clear();
	MySteryBoxList.clear();
	MySteryShopList.clear();
	MySteryShopGoodsList.clear();
	MySteryShopList1.clear();
	MySteryShopGoodsList1.clear();
	m_all_recast_item.clear();
	m_recast_data.clear();
	m_all_recast_rebate_map.clear();
	m_suit_map.clear();
	m_equip_suit_data.clear();
}

bool PackageManager::init()
{
	TCP_CLIENT->register_net_cmd("NET_SIS_get_role_init_state_item", this, &PackageManager::onInitLocalPlayerItem);
	TCP_CLIENT->register_net_cmd("NET_SIS_item_position_change", this, &PackageManager::onItemPositionChanged);
	TCP_CLIENT->register_net_cmd("NET_SIS_stack_item", this, &PackageManager::onItemStack);
	TCP_CLIENT->register_net_cmd("NET_SIS_item_reorder", this, &PackageManager::onReorderItem);
	TCP_CLIENT->register_net_cmd("NET_SIS_item_reorder_extend", this, &PackageManager::onReorderItemEx);
	TCP_CLIENT->register_net_cmd("NET_SIS_get_role_init_state_money", this, &PackageManager::onInitStateMoney);
	TCP_CLIENT->register_net_cmd("NET_SIS_bag_silver", this, &PackageManager::onMoneyChange);
	TCP_CLIENT->register_net_cmd("NET_SIS_baibao_yuanbao", this, &PackageManager::onBaibaoYuanbaoChange);
	TCP_CLIENT->register_net_cmd("NET_SIS_item_remove", this, &PackageManager::onItemRemove);
	TCP_CLIENT->register_net_cmd("NET_SIS_role_putdown_item", this, &PackageManager::onItemPutDown);
	TCP_CLIENT->register_net_cmd("NET_SIS_use_item", this, &PackageManager::onItemUsed);//使用物品
	TCP_CLIENT->register_net_cmd("NET_SIS_new_item_add", this, &PackageManager::onAddNewItem);//添加新物品
	TCP_CLIENT->register_net_cmd("NET_SIS_new_equip_add", this, &PackageManager::onAddNewEquitItem);//添加新装备
	TCP_CLIENT->register_net_cmd("NET_SIS_item_add", this, &PackageManager::onAddStackItem);   //增加堆叠物品
	TCP_CLIENT->register_net_cmd("NET_SIS_item_position_change_extend", this, &PackageManager::onItemPositionChangedEx);
	TCP_CLIENT->register_net_cmd("NET_SIS_equip", this, &PackageManager::onEquipItem);
	TCP_CLIENT->register_net_cmd("NET_SIS_unequip", this, &PackageManager::onUnEquipItem);
	TCP_CLIENT->register_net_cmd("NET_SIS_equip_change", this, &PackageManager::onEquipAttrChange);
	TCP_CLIENT->register_net_cmd("NET_SIS_identify_equip", this, &PackageManager::onEquipIndentify);
	TCP_CLIENT->register_net_cmd("NET_SIS_chisel", this, &PackageManager::onEquipChisel);
	TCP_CLIENT->register_net_cmd("NET_SIS_inlay", this, &PackageManager::onEquipInlay);
	TCP_CLIENT->register_net_cmd("NET_SIS_equip_type_change", this, &PackageManager::onEquipLevelUp);
	TCP_CLIENT->register_net_cmd("NET_SIS_newess_change", this, &PackageManager::onNewessChanged);
	TCP_CLIENT->register_net_cmd("NET_SIS_bag_extend", this, &PackageManager::onBagExtend);
	//TCP_CLIENT->register_net_cmd("NET_SIS_exploits", this, &PackageManager::onRongYuChange);
	TCP_CLIENT->register_net_cmd("NET_SIS_key_info", this, &PackageManager::onKeyInfo);
	TCP_CLIENT->register_net_cmd("NET_SIS_unbeset", this, &PackageManager::onUnBeset);
	TCP_CLIENT->register_net_cmd("NET_SIS_bag_yuanbao", this, &PackageManager::onDiamondChanged);
	TCP_CLIENT->register_net_cmd("NET_SIS_use_luck_you", this, &PackageManager::onEquipLuckChange);
	TCP_CLIENT->register_net_cmd("NET_SIS_AllUse_Good_Man_Card", this, &PackageManager::onAllUseGoodManCardResult); //批量使用好人卡
	TCP_CLIENT->register_net_cmd("NET_SIS_abrase_stone", this, &PackageManager::onUseRepairWaterResult); //使用修复神水结果
	TCP_CLIENT->register_net_cmd("NET_SIS_learn_skill", this, &PackageManager::onLeranSkillInfo);
	TCP_CLIENT->register_net_cmd("NET_SIS_Equip_ride", this, &PackageManager::onEquipRide);
	TCP_CLIENT->register_net_cmd("NET_SIS_UnEquip_ride", this, &PackageManager::onUnEquipRide);
	//功法相关
	TCP_CLIENT->register_net_cmd("NET_SIS_equip_kungfu", this, &PackageManager::onEquipKungfu);
	TCP_CLIENT->register_net_cmd("NET_SIS_unequip_kungfu", this, &PackageManager::onUnEquipKungfu);
	TCP_CLIENT->register_net_cmd("NET_SIS_Kungfu_Exp_Up", this, &PackageManager::onKungfuExpChange);
	//end
	//消费返利相关
	TCP_CLIENT->register_net_cmd("NET_SIS_totalconsume_yuanbao", this, &PackageManager::onTotalYBConsume);
	TCP_CLIENT->register_net_cmd("NET_SIS_update_role_script_data", this, &PackageManager::onConsumeYBReplyData);
	//end

	//装备替换时的宝石替换
	TCP_CLIENT->register_net_cmd("NET_SIS_gem_exchange",this,&PackageManager::onGemExchange);

	//摇钱树
	TCP_CLIENT->register_net_cmd("NET_SIS_recharge_feedback", this, &PackageManager::onGetRechargeFeedbackInfo);

	//锻造和分解
	TCP_CLIENT->register_net_cmd("NET_SIS_Forging_result", this, &PackageManager::onGetForingDataInfo);
	TCP_CLIENT->register_net_cmd("NET_SIS_Decompose_result", this, &PackageManager::onGetDecomPoseDataInfo);

	TCP_CLIENT->register_net_cmd("NET_SIS_GongFa_Lock", this, &PackageManager::on_server_gongfa_lock);
	TCP_CLIENT->register_net_cmd("NET_S2C_Suit_Init_Info", this, &PackageManager::onMessageEquipSuitInit);
	TCP_CLIENT->register_net_cmd("NET_SIS_suit_num", this, &PackageManager::onMessageEquipSuitChange);
	//end
	//开宝箱
	//	TCP_CLIENT->register_net_cmd("NET_SIS_Common_get_reward_info", this, &PackageManager::onServerOpenKenBox);		//【Ji:】宝箱
	//end
	//获取人物所有物品
	NET_SIC_get_role_init_state roleInitState;
	roleInitState.eType = ERIT_Item;
	TCP_CLIENT->send_net_cmd(&roleInitState, NP_NORMAL, false);
	//获取金钱等
	roleInitState.eType = ERIT_Money;
	TCP_CLIENT->send_net_cmd(&roleInitState, NP_NORMAL, false);
	TCP_CLIENT->register_net_cmd("NET_G2C_ROLE_UPDATE_CONTYPE_ITEM", \
		this, &PackageManager::on_NET_G2C_ROLE_UPDATE_CONTYPE_ITEM);
	//装备强化
	TCP_CLIENT->register_net_cmd("NET_SIS_shengxing", this, &PackageManager::onEquipStrengthenResult);
	TCP_CLIENT->register_net_cmd("NET_SIS_Equip_Recast_Activity", this, &PackageManager::onReciveRecastCondition);
	TCP_CLIENT->register_net_cmd("NET_SIS_Equip_Recast_Discount", this, &PackageManager::onReciveRecastInfo);
	TCP_CLIENT->register_net_cmd("NET_SIS_Equip_Recast", this, &PackageManager::onReciveRecastBack);

	REG_NAME_CB(this , &PackageManager::onGetName);

	_recharge_period = 0;
	_recharge_feedback = 0;
	_feedback_times = 0;
	m_CurBoxGamle_RewardIdx = 0;
	m_cCurBoxType = NULL;
	m_bIsBoxOK = true;

	_conSize[EICT_KungfuBag] = MAX_KUNGFU_BAG_NUM;
	_conSize[EICT_KungfuTemp] = MAX_KUNFFU_TEMP_NUM;
	_conSize[EICT_KungfuWare] = MAX_KUNGFU_WARE_NUM;
	_conSize[EICT_KungfuEquip] = /*MAX_GONGFA_EQUIP_NUM*/f_formula_helper::get_magic_soul_slot_max_num();
	// 	std::string sSEDir = CFGReader::instance()->get_profile_string("Art", "Effect", "");
	// 	std::string sSESelect = sSEDir + "E1_54.plist";
	// 	_plist.insert(sSESelect);
	// 	UiResourceMgr::getInstance()->retainPlistFile(_plist);
	// 	CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFramesWithFile(sSESelect.c_str());
	initCostYB();
	send_get_recast_item_rebate();
	initEquipShowInfo();

	return true;
}

bool PackageManager::destroy()
{
	destroyAllIconFrames();
	destoryCon(EICT_Bag);
	destoryCon(EICT_Equip);
	destoryCon(EICT_RoleWare);
	destoryCon(EICT_KungfuEquip);//gx add 2014.2.11
	destoryCon(EICT_KungfuBag);
	destoryCon(EICT_KungfuWare);
	destoryCon(EICT_KungfuTemp);
	destoryCon(EICT_StallItem);
	destoryCon(EICT_EquipShow);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_get_role_init_state_item", this, &PackageManager::onInitLocalPlayerItem);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_item_position_change", this, &PackageManager::onItemPositionChanged);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_stack_item", this, &PackageManager::onItemStack);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_item_reorder", this, &PackageManager::onReorderItem);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_item_reorder_extend", this, &PackageManager::onReorderItemEx);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_get_role_init_state_money", this, &PackageManager::onInitStateMoney);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_bag_silver", this, &PackageManager::onMoneyChange);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_baibao_yuanbao", this, &PackageManager::onBaibaoYuanbaoChange);//
	TCP_CLIENT->unregister_net_cmd("NET_SIS_item_remove", this, &PackageManager::onItemRemove);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_role_putdown_item", this, &PackageManager::onItemPutDown);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_use_item", this, &PackageManager::onItemUsed);//使用物品
	TCP_CLIENT->unregister_net_cmd("NET_SIS_new_item_add", this, &PackageManager::onAddNewItem);//添加新物品
	TCP_CLIENT->unregister_net_cmd("NET_SIS_new_equip_add", this, &PackageManager::onAddNewEquitItem);//添加装备
	TCP_CLIENT->unregister_net_cmd("NET_SIS_item_add", this, &PackageManager::onAddStackItem);//增加堆叠物品
	TCP_CLIENT->unregister_net_cmd("NET_SIS_item_position_change_extend", this, &PackageManager::onItemPositionChangedEx);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_equip", this, &PackageManager::onEquipItem);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_unequip", this, &PackageManager::onUnEquipItem);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_equip_change", this, &PackageManager::onEquipAttrChange);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_identify_equip", this, &PackageManager::onEquipIndentify);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_chisel", this, &PackageManager::onEquipChisel);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_inlay", this, &PackageManager::onEquipInlay);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_equip_type_change", this, &PackageManager::onEquipLevelUp);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_newess_change", this, &PackageManager::onNewessChanged);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_bag_extend", this, &PackageManager::onBagExtend);
	//TCP_CLIENT->unregister_net_cmd("NET_SIS_exploits", this, &PackageManager::onRongYuChange);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_key_info", this, &PackageManager::onKeyInfo);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_unbeset", this, &PackageManager::onUnBeset);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_bag_yuanbao", this, &PackageManager::onDiamondChanged);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_use_luck_you", this, &PackageManager::onEquipLuckChange);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_AllUse_Good_Man_Card", this, &PackageManager::onAllUseGoodManCardResult); //批量使用好人卡
	TCP_CLIENT->unregister_net_cmd("NET_SIS_abrase_stone", this, &PackageManager::onUseRepairWaterResult); //使用修复神水结果
	TCP_CLIENT->unregister_net_cmd("NET_SIS_learn_skill", this, &PackageManager::onLeranSkillInfo);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_Equip_ride", this, &PackageManager::onEquipRide);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_UnEquip_ride", this, &PackageManager::onUnEquipRide);

	//功法相关
	TCP_CLIENT->unregister_net_cmd("NET_SIS_equip_kungfu", this, &PackageManager::onEquipKungfu);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_unequip_kungfu", this, &PackageManager::onUnEquipKungfu);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_Kungfu_Exp_Up", this, &PackageManager::onKungfuExpChange);
	//end
	//消费返利相关
	TCP_CLIENT->unregister_net_cmd("NET_SIS_totalconsume_yuanbao", this, &PackageManager::onTotalYBConsume);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_update_role_script_data", this, &PackageManager::onConsumeYBReplyData);
	//end
	//摇钱树
	TCP_CLIENT->unregister_net_cmd("NET_SIS_recharge_feedback", this, &PackageManager::onGetRechargeFeedbackInfo); 

	//锻造和分解
	TCP_CLIENT->unregister_net_cmd("NET_SIS_Forging_result", this, &PackageManager::onGetForingDataInfo);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_Decompose_result", this, &PackageManager::onGetDecomPoseDataInfo);

	TCP_CLIENT->unregister_net_cmd("NET_G2C_ROLE_UPDATE_CONTYPE_ITEM", \
		this, &PackageManager::on_NET_G2C_ROLE_UPDATE_CONTYPE_ITEM);

	//装备替换时的宝石替换
	TCP_CLIENT->unregister_net_cmd("NET_SIS_gem_exchange",this,&PackageManager::onGemExchange);

	TCP_CLIENT->unregister_net_cmd("NET_SIS_shengxing", this, &PackageManager::onEquipStrengthenResult);

	TCP_CLIENT->unregister_net_cmd("NET_SIS_Equip_Recast_Activity", this, &PackageManager::onReciveRecastCondition);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_Equip_Recast_Discount", this, &PackageManager::onReciveRecastInfo);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_Equip_Recast", this, &PackageManager::onReciveRecastBack);

	TCP_CLIENT->unregister_net_cmd("NET_SIS_GongFa_Lock", this, &PackageManager::on_server_gongfa_lock);
	TCP_CLIENT->unregister_net_cmd("NET_S2C_Suit_Init_Info", this, &PackageManager::onMessageEquipSuitInit);
	TCP_CLIENT->unregister_net_cmd("NET_SIS_suit_num", this, &PackageManager::onMessageEquipSuitChange);

	UNREG_NAME_CB(this , &PackageManager::onGetName);
	//end
	//开宝箱
	//	TCP_CLIENT->unregister_net_cmd("NET_SIS_Common_get_reward_info", this, &PackageManager::onServerOpenKenBox);			//【Ji：】宝箱
	//end
	_tmpKungfuIDMap.clear();
	// 	if (!_plist.empty())
	// 	{
	// 		UiResourceMgr::getInstance()->releasePlistFile(_plist);
	// 		_plist.clear();
	// 	}
	mneedCostYBTable.clear();
	MySteryBoxList.clear();
	MySteryShopList.clear();
	MySteryShopGoodsList.clear();
	MySteryShopList1.clear();
	MySteryShopGoodsList1.clear();
	return true;
}

void PackageManager::loadDataFromXML()
{
	init_recast_data_table();
	init_equip_suit_table();
	initEquipDataMapFromXML();
}

void PackageManager::initEquipDataMapFromXML()
{
	f_data_set dataset;
	std::list<std::string> fields;
	bool ret = dataset.load("Config/db/EquipData.xml","typeId",&fields);
	CC_ASSERT(ret);
	EquipTypeData data;
	EquipBaseAttr att_data;
	string t_str = "";
	_equipData.clear();
	_equipAttData.clear();
	std::for_each(fields.begin(),fields.end(),[&](std::string const& one)
	{
		data.typeId = dataset.get_int("typeId",one.c_str(),0);
		data.levelUpId = dataset.get_int("levelUpId",one.c_str(),0);
		for(int i = 0;i < LEVEL_UP_MATERIAL_NUMBER;++i){
			safe_sprintf(t_str,"%s%d%s","stuff",i+1,"Id");
			data.stuffId[i] = dataset.get_int(t_str.c_str(),one.c_str(),0);
			safe_sprintf(t_str,"%s%d%s","stuff",i+1,"Num");
			data.stuffNum[i] = dataset.get_int(t_str.c_str(),one.c_str(),0);
		}
		data.name = dataset.get_string("Name",one.c_str(),"");
		data.profession = dataset.get_string("Profession",one.c_str(),"");
		data.level = dataset.get_int("Level",one.c_str(),0);
		data.jewel_limit = dataset.get_int("jewel_limit",one.c_str(),0);
		data.durability = dataset.get_int("Durability",one.c_str(),0);
		data.pos = dataset.get_string("Pos",one.c_str(),"");
		data.posIndex = (EEquipPos)dataset.get_int("PosIndex",one.c_str(),0);
		data.bySex = dataset.get_int("Sex",one.c_str(),0);
		data.luck = dataset.get_int("Luck",one.c_str(),0);
		data.equipDesc = dataset.get_string("Desc",one.c_str(),"");
		data.equipQuality = (EItemQuality)dataset.get_int("quality",one.c_str(),0);
		data.explodeId = dataset.get_int("explodeId",one.c_str(),0);
		data.profession2 = dataset.get_int("Profession2",one.c_str(),0);
		for(int i = 0; i <LEVEL_NAME; ++i){
			safe_sprintf(t_str,"%s%d","starName",(i+1));
			data.LevelName[i] = dataset.get_string(t_str.c_str(),one.c_str(),"");
		}
		data.gemHole = dataset.get_int("gemHole",one.c_str(),0);
		data.isAutoExplode = dataset.get_int("isautoExplode",one.c_str(),0);
		data.minUseLevel = dataset.get_int("use_level_min",one.c_str(),0);
		data.maxUseLevel = dataset.get_int("use_level_max",one.c_str(),0);
		data.showTest = dataset.get_int("showTest",one.c_str(),0);
		data.equipSign = dataset.get_int("equipSign",one.c_str(),0);
		data.suit_id = dataset.get_int("suitId",one.c_str(),0);
		data.equipGrade = dataset.get_int("equipGrade",one.c_str(),0);
		data.referLv = dataset.get_int("referLv",one.c_str(),0);
		data.qualityLv = dataset.get_int("qualityLv",one.c_str(),0);
		data.quality_modify = dataset.get_int("quality_modify",one.c_str(),0);

		_equipData[data.typeId] = data;

		att_data.data[EquipBaseAttr::EBA_ZAtcMin] = dataset.get_int("ZAtcMin",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_ZAtcMax] = dataset.get_int("ZActMax",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_FAtcMin] = dataset.get_int("FAtcMin",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_FAtcMax] = dataset.get_int("FAtcMax",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_DAtcMin] = dataset.get_int("DAtcMin",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_DAtcMax] = dataset.get_int("DAtcMiax",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_WFangMax] = dataset.get_int("WFangMax",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_WFangMin] = dataset.get_int("WFangMin",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_MFangMax] = dataset.get_int("MFangMax",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_MFangMin] = dataset.get_int("MFangMin",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_Life] = dataset.get_int("Life",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_Mana] = dataset.get_int("Mana",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_Hit] = dataset.get_int("Hit",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_Miss] = dataset.get_int("Miss",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_Baoji] = dataset.get_int("Baoji",one.c_str(),0);
		att_data.data[EquipBaseAttr::EBA_MianBao] = dataset.get_int("Mianbao",one.c_str(),0);
		_equipAttData[data.typeId] = att_data;

	});

}

void PackageManager::update( float dt )
{

}
void PackageManager::loadPackageDataProto()
{
	_itemData.clear();

	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData");
	c_sql_table* table = c_db_manager::getSingleton()->create_table();

	while(table->retrieve_row())
	{
		ItemTypeData proto;
		std::string strName;
		std::string strDesc;
		unsigned int idx = table->get_index("TypeId");
		proto.typeId = table->get_integer32(idx);
		idx = table->get_index("Name");
		proto.name = table->get_text(idx);
		idx = table->get_index("Type");
		proto.type = (ePackageItemType)table->get_integer32(idx);
		idx = table->get_index("CD");
		proto.cdTime = table->get_integer32(idx);
		idx = table->get_index("Icon");
		proto.icon = table->get_text(idx);
		idx = table->get_index("Desc");
		proto.desc = table->get_text(idx);
		idx = table->get_index("Species");
		proto.spcialType = table->get_integer32(idx);
		idx = table->get_index("autoSell");
		proto.bAutoSell = table->get_integer32(idx);
		idx = table->get_index("UseTime");
		proto.useTime = table->get_integer32(idx);
		idx = table->get_index("StackNumber");
		proto.stackNumber = table->get_integer32(idx);
		idx = table->get_index("cansell");
		proto.canSell = table->get_integer32(idx);
		idx = table->get_index("uselv");
		proto.level = table->get_integer32(idx);
		idx = table->get_index("period");
		proto.period = table->get_integer32(idx);
		idx = table->get_index("special_value_1");
		proto.special_value_1 = table->get_integer32(idx);
		idx = table->get_index("compose_id");
		proto.dwCompose_id = table->get_integer32(idx);
		idx = table->get_index("tipsBtnIdx");
		proto.byTipsBtnIdx = table->get_integer32(idx);
		idx = table->get_index("quality");
		proto.byQuality = table->get_integer32(idx);
		idx = table->get_index("price");
		proto.dwPrice = table->get_integer32(idx);
		idx = table->get_index("moveSound");
		proto.moveSound = table->get_text(idx);
		idx = table->get_index("pickSound");
		proto.pickSound = table->get_text(idx);
		idx = table->get_index("useSound");
		proto.useSound = table->get_text(idx);
		idx = table->get_index("vocation_limit");
		proto.profession = table->get_integer32(idx);
		idx = table->get_index("putawayBool");
		proto.putawayBool = table->get_boolean(idx);
		idx = table->get_index("recommendedPrice");
		proto.recommendedPrice = table->get_integer32(idx);
		idx = table->get_index("oneclassId");
		proto.oneclassId = table->get_integer32(idx);
		idx = table->get_index("towclassId");
		proto.towclassId = table->get_integer32(idx);
		idx = table->get_index("bottomPrice");
		proto.bottomPrice = table->get_integer32(idx);
		idx = table->get_index("maxPrice");
		proto.maxPrice = table->get_integer32(idx);
		idx = table->get_index("isFaceDeal");
		proto.isFaceDeal = table->get_boolean(idx);
		idx = table->get_index("Kind");
		proto.goods_kind = table->get_integer32(idx);
		_itemData[proto.typeId] = proto;
	}

	c_db_manager::getSingleton()->destroy_table(table);
	c_db_manager::getSingleton()->end_operation(cmd);
}
unsigned int PackageManager::on_NET_G2C_ROLE_UPDATE_CONTYPE_ITEM( s_net_cmd* cmd )
{
	WorldPacket msg((const void*)cmd);
	int size;
	int contype;
	msg >> size;
	msg >> contype;
	char byItemType;
	for (int i = 0; i < size; ++i)
	{
		msg >> byItemType;
		f_item* item = 0;
		if(byItemType == 0)
		{
			tagItem tmptagItem;
			msg >> tmptagItem;
			item = new f_item(tmptagItem);
		}
		else
		{
			tagEquip tmptagEquip;
			msg >> tmptagEquip;
			item = new f_equipment(tmptagEquip);
		}
		if (contype != -1)
			item->set_container_type((EItemConType)contype);
		item->set_pos(i);
		addNewItem(item);//调用添加一个新物品
	}
	return 0;
}

unsigned int PackageManager::onInitLocalPlayerItem( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_get_role_init_state_item"))
	{
		NET_SIS_get_role_init_state_item *msg = (NET_SIS_get_role_init_state_item*)cmd;
		_conSize[EICT_Bag] = msg->n16SzBag;
		_conSize[EICT_RoleWare] = msg->n16SzRoleWare;
		for(int i=0,pos=0; i<msg->n_num; ++i)
		{
			tagItem item;
			//int size = sizeof(tagItem);
			//int size2 = sizeof(tagEquip);
			memcpy(&item, msg->byData+pos, sizeof(tagItem));
			if(MIsEquipment(item.dw_data_id))
			{
				tagEquip equip;
				memcpy(&equip, msg->byData+pos, sizeof(tagEquip));
				pos += sizeof(tagEquip);
				f_equipment* pEquip = new f_equipment(equip);
				addNewItem(pEquip);//调用添加一个新物品
			}
			else
			{
				pos += sizeof(tagItem);
				f_item* pItem = new f_item(item);
				addNewItem(pItem);//调用添加一个新物品
			}
		}
		if (msg->b_Over > 0)
		{
			_init = true;
			//更新packageUi;
			GET_UI(Package, WCT_PACKAGEUI)->updateData();
			GET_UI(Storage, WCT_StorageUi)->updateData();

			//更新保存主界面药品,传送石;
			GET_UI(ShortCutUi, WCT_ShorCutUi)->updateMedicineAndRandtran();

			//更新装备UI
			GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI)->updateEquipment();

			//更新戒指UI
			GET_UI(RoleRingUi,WCT_ROLERINGUI)->updateEquipment();

			//更新功法UI
			GET_UI(WuXueUi,WCT_WUXUEUI)->updateMartialData();

			//获取快捷键信息
			NET_SIC_key_info keyInfoCmd;
			TCP_CLIENT->send_net_cmd(&keyInfoCmd, NP_IDLE, false);

			LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
			if (!ploc)
			{
				return -1;
			}
			//ploc->updateLocalSBKMasterEffect(RoleManager::getInstance()->getLocalPlayer()->getId());
			ploc->updateSBKMasterEffect(wearSBKMasterEquip());
			ploc->updateGongFaRealmEffect(GambleMgr::getInstance()->m_curGongFaRealm);
			ForgingMgr::getInstance()->judgeForgingByItem();
			ForgingMgr::getInstance()->judgeDecomposeByEquip();

			wear_change_event event;
			SEND_EVENT(&event);

			return 0;
		}
	}

	return 0;
}

//此接口主要是操作远程玩家容易，自己容器慎用
void PackageManager::removeByConType(EItemConType con,INT64 itemId)
{
	ItemMap *map = getItemMap(con);
	if (map)
	{
		removeItem(*map,itemId);
	}
}

bool PackageManager::removeItem( ItemMap &itemMap, short index )
{
	ItemMap::iterator iter = itemMap.find(index);
	if(iter != itemMap.end())
	{
		f_item* item = iter->second;
		checkFusionItemUpdateifNess(item);
		checkSBKEquipUpdateIfNess(item);

		item_num_change evt;
		evt.item_type_id  =  item->get_item_type_id();


		delete iter->second;
		itemMap.erase(iter);

		SEND_EVENT(&evt);
		return true;
	}

	return false;
}

bool PackageManager::removeItem(ItemMap &itemMap, INT64 itemId )
{
	return removeItem(itemMap, getItemPos(itemMap, itemId));
}

f_item* PackageManager::remove(ItemMap &itemMap, short index)
{
	f_item* pItem = NULL;
	ItemMap::iterator iter = itemMap.find(index);
	if(iter != itemMap.end())
	{
		pItem = iter->second;

		checkFusionItemUpdateifNess(pItem);
		checkSBKEquipUpdateIfNess(pItem);

		item_num_change evt;
		evt.item_type_id  =  pItem->get_item_type_id();

		itemMap.erase(iter);

		SEND_EVENT(&evt);
	}

	return pItem;
}

f_item* PackageManager::remove(ItemMap &itemMap, INT64 itemId)
{
	return remove(itemMap, getItemPos(itemMap, itemId));
}


void PackageManager::addNewItem( f_item *item )//添加一个新物品 
{
	ItemMap *itemMap = getItemMap(item->get_container_type());
	if (itemMap)
	{
		(*itemMap)[item->m_data.n16Index] = item;
	}

	item_num_change evt;
	evt.item_type_id = item->get_item_type_id();
	SEND_EVENT(&evt);

	add_new_item evt2;
	evt2.item_id = item->get_item_id();
	SEND_EVENT(&evt2);

	if(item->get_item_type_id() == Item_shoeId)
	{
		RoleHeadUi* roleui = World::getInstance()->getRoleHeadUi();
		unsigned int curMapId = MapManager::getInstance()->getCurMapId();
		//unsigned int nopassId =  name_crc32(convertWName(std::string("m9")));
		if (MapManager::getInstance()->getCurSceneType(curMapId) == 0   || 
			MapManager::getInstance()->getCurSceneType(curMapId) == 2   ||
			MapManager::getInstance()->getCurSceneType(curMapId) == 14  )
		{
			if(NULL != roleui)
			{
				if (RoleManager::getInstance()->getLocalPlayer()->getAutoRunState())
					roleui->SetShowShoe(true);
				else
					roleui->SetShowShoe(false);
			}
		}
		else
		{ 
			if(NULL != roleui) 
				roleui->SetShowShoe(false);
		}
	}
	onPackageItemChanged(item->get_item_type_id());
	NewPlayerGuider::getInstance()->onBagItemAdd(item);
}

void PackageManager::addNewItem( ItemMap &itemMap, f_item *item )//添加一个新物品
{
	itemMap[item->m_data.n16Index] = item;

	checkFusionItemUpdateifNess(item);

	item_num_change evt;
	evt.item_type_id = item->get_item_type_id();
	SEND_EVENT(&evt);

	add_new_item evt2;
	evt2.item_id = item->get_item_id();
	SEND_EVENT(&evt2);
}

f_item* PackageManager::getItem( ItemMap &itemMap, short index )
{
	ItemMap::iterator iter = itemMap.find(index);
	if(iter != itemMap.end())
	{
		return iter->second;
	}

	return NULL;
}

f_item* PackageManager::getItem( ItemMap &itemMap, INT64 id )
{
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_id() == id)
			return item;
	}

	return NULL;
}


f_item * PackageManager::getItem( EItemConType con, short index )
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		return getItem(*itemMap, index);
	}

	return NULL;
}

f_item * PackageManager::getItem( EItemConType con, INT64 id )
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		return getItem(*itemMap, id);
	}

	return NULL;
}
f_item * PackageManager::getBindItem( EItemConType con, unsigned int typeId )
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		return getBindItem(*itemMap, typeId);
	}

	return NULL;
}
f_item * PackageManager::getUnBindItem( EItemConType con, unsigned int typeId )
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		return getUnBindItem(*itemMap, typeId);
	}

	return NULL;
}
f_item* PackageManager::getBindItem( ItemMap &itemMap, unsigned int typeId )
{
	//找到最小数量的堆返回 gx modify 2013.10.29
	f_item *minItem = NULL;
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_type_id() == typeId)
		{
			if (item->get_item_bind_status())//若还没获得初始化值;
			{
				minItem = item;
				break;;
			}
		}
	}

	return minItem;
}
f_item* PackageManager::getUnBindItem( ItemMap &itemMap, unsigned int typeId )
{
	//找到最小数量的堆返回 gx modify 2013.10.29
	f_item *minItem = NULL;
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_type_id() == typeId)
		{
			if (!item->get_item_bind_status())//若还没获得初始化值;
			{
				minItem = item;
				break;;
			}
		}
	}

	return minItem;
}
f_item* PackageManager::getItem( ItemMap &itemMap, unsigned int typeId )
{
	//找到最小数量的堆返回 gx modify 2013.10.29
	int num = 0;
	f_item *minItem = NULL;
	bool bInit = false;
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_type_id() == typeId)
		{
			if (!bInit)//若还没获得初始化值;
			{
				minItem = item;
				num = item->get_item_number();
				bInit = true;
			}
			else
			{
				if (item->get_item_number() < num)
				{
					minItem = item;
					num = item->get_item_number();
				}
			}
		}
	}

	return minItem;
}

f_item * PackageManager::getItem( EItemConType con, unsigned int typeId )
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		return getItem(*itemMap, typeId);
	}

	return NULL;
}

f_item * PackageManager::getItem( INT64 id )
{
	f_item *item = getItem(EICT_Bag, id);
	if(item != NULL)
		return item;

	item = getItem(EICT_Equip, id);
	if(item != NULL)
		return item;

	item = getItem(EICT_RoleWare, id);
	if(item != NULL)
		return item;

	item = getItem(EICT_KungfuEquip,id);
	if(item != NULL)
		return item;

	item = getItem(EICT_KungfuBag,id);
	if(item != NULL)
		return item;

	item = getItem(EICT_KungfuTemp,id);
	if(item != NULL)
		return item;

	item = getItem(EICT_KungfuWare,id);
	if(item != NULL)
		return item;

	return NULL;
}
//返回容器中绑定或非绑定的最小堆数
//使用方法：若bBind为true，则优先返回容器中最小的绑定堆，若不存在绑定的，则返回容器中最小的堆；
//			反之亦然。
f_item *PackageManager::getItem(EItemConType con, unsigned int typeId,bool bBind)
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		f_item *pItem = getItem(*itemMap, typeId,bBind);
		if (pItem)
		{
			return pItem;
		}
		else
		{
			return getItem(*itemMap,typeId);
		}
	}
	return NULL;
}
f_item *PackageManager::getItem(ItemMap &itemMap, unsigned int typeId,bool bBind)
{
	//找到最小数量的堆返回
	int num = 0;
	f_item *minItem = NULL;
	bool bInit = false;
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_type_id() == typeId && item->is_item_binded() == bBind)
		{
			if (!bInit)//若还没获得初始化值
			{
				minItem = item;
				num = item->get_item_number();
				bInit = true;
			}
			else
			{
				if (item->get_item_number() < num)
				{
					minItem = item;
					num = item->get_item_number();
				}
			}
		}
	}

	return minItem;
}

f_item * PackageManager::getItem( EItemConType con, unsigned int typeId, EItemQuality eItemQuality )
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		f_item *tempItem = getItem(*itemMap, typeId);
		if (tempItem)
		{
			f_equipment *tempEquip = dynamic_cast<f_equipment*>(tempItem);
			if (tempEquip)
			{
				if (tempEquip->get_item_quality() == eItemQuality)
					return tempEquip;
			}
			ItemTypeData tempItemTypeData = getItemTypeData(tempItem->get_item_type_id());
			if (tempItemTypeData.byQuality == eItemQuality)
				return tempItem;
		}
	}

	return NULL;
}

void PackageManager::ChangeMysteryShopGoodsList(unsigned int uIndex,unsigned int uCanBuyNum,unsigned int nTotalNum,unsigned int nTip)
{
	if(MySteryShopGoodsList.size()> uIndex)
	{
		MySteryShopGoodsList[uIndex].nCanbuyNum = uCanBuyNum;
		MySteryShopGoodsList[uIndex].nItemNum = nTotalNum;
		MySteryShopGoodsList[uIndex].nTipType = nTip;
	}
}
UINT PackageManager::getItemNumber_Stack(EItemConType con, unsigned int dwTypeId)
{
	UINT ret = 0;
	ItemMap *itemMap = getItemMap(con);
	getItemNumber(*itemMap, dwTypeId,ret);
	return ret;
}

int PackageManager::getUnBindItemNumber(EItemConType con, unsigned int dwTypeId)
{
	ItemMap *itemMap = getItemMap(con);
	return getUnBindItemNumber(*itemMap, dwTypeId);
}
int PackageManager::getBindItemNumber(EItemConType con, unsigned int dwTypeId)
{
	ItemMap *itemMap = getItemMap(con);
	return getBindItemNumber(*itemMap, dwTypeId);
}
//end
int PackageManager::getItemNumber(EItemConType con, unsigned int dwTypeId)
{
	ItemMap *itemMap = getItemMap(con);
	UINT ret = 0;
	return getItemNumber(*itemMap, dwTypeId,ret);
}
void PackageManager::onGetName( unsigned int roleid , const std::string& name )
{
	MysteryBoxUi* ui = GET_UI(MysteryBoxUi, WCT_MysteryBoxUi);
	if(ui != NULL)
	{
		ui->updateRoleName(roleid,name);
	}
	MysteryShopUi* ui1 = GET_UI(MysteryShopUi, WCT_MysteryShopUi);
	if(ui1 != NULL)
	{
		ui1->updateRoleName(roleid,name);
	}
}

int PackageManager::getUnBindItemNumber(ItemMap &itemMap, unsigned int dwTypeId)
{
	int num = 0;
	//f_item *maxItem = NULL;
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_type_id() == dwTypeId)
		{
			if(!item->get_item_bind_status())
			{
				num += item->get_item_number();
			}

		}
	}

	return num;
}
int PackageManager::getBindItemNumber(ItemMap &itemMap, unsigned int dwTypeId)
{
	int num = 0;
	//f_item *maxItem = NULL;
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_type_id() == dwTypeId)
		{
			if(item->get_item_bind_status())
			{
				num += item->get_item_number();
			}

		}
	}

	return num;
}
int PackageManager::getItemNumber(ItemMap &itemMap, unsigned int dwTypeId, UINT& stackNum)
{
	int num = 0;
	//f_item *maxItem = NULL;
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_type_id() == dwTypeId)
		{
			num += item->get_item_number();
			stackNum++;
		}
	}

	return num;
}

short PackageManager::getItemPos( ItemMap &itemMap, INT64 itemId )
{
	for(ItemMap::iterator iter = itemMap.begin(); iter != itemMap.end(); ++ iter)
	{
		f_item *item = iter->second;
		if(item->get_item_id() == itemId)
			return iter->first;
	}

	return -1;
}
void PackageManager::getKindItemMap(EItemConType con,unsigned int typeId,ItemMap& _map)
{
	if ((unsigned int)INVALID == typeId)
		return;
	if (EICT_Bag == con)
	{
		ItemMap::iterator iter = _pocket.begin();
		for (;iter != _pocket.end();++iter)
		{
			f_item* pitem = iter->second;
			if (!pitem)
				continue;
			if (typeId == iter->second->get_item_type_id())
			{
				_map.insert(make_pair(iter->first,iter->second));
			}
		}
	}
}
PackageManager::ItemMap * PackageManager::getItemMap( EItemConType type )
{
	switch(type)
	{
	case EICT_Bag:
		return &_pocket;
		break;
	case EICT_Equip:
		return &_equipment;
		break;
	case EICT_RoleWare:
		return &_storage;
		break;
	case EICT_KungfuBag:
		return &_gongfabag;
		break;
	case EICT_KungfuTemp:
		return &_gongfatmp;
		break;
	case EICT_KungfuWare:
		return &_gongfaware;
		break;
	case EICT_KungfuEquip:
		return &_kungfu;
		break;
	case EICT_StallItem:
		return &_stall;
		break;
	case EICT_EquipShow:
		return &_equip_show;
	case EICT_Inlay:
		return &_equip_show;
	default:
		return NULL;
		break;
	}
}

std::string PackageManager::getIconFrameName( unsigned int dataId )
{
	std::string iconFile = getItemTypeData(dataId).icon;
	if(iconFile.empty())
	{
		//CC_ASSERT(0);
		return "rendui_yuanhunhbtn";//TODO 修改为默认值
	}
	else
	{
		//if(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(iconFile.c_str()) == NULL)
		//{
		//	std::string fileName = CFGReader::instance()->get_profile_string("Art", "ICON", "") + iconFile + std::string(".png");
		//	CCImage image;
		//	image.initWithImageFile(fileName.c_str());
		//	CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addUIImage(&image, iconFile.c_str());
		//	CCSpriteFrame *frame = CCSpriteFrame::createWithTexture(texture, CCRect(0.0, 0.0, texture->getPixelsWide(), texture->getPixelsHigh()));
		//	CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFrame(frame, iconFile.c_str());
		//}
		getIconFrameByName(iconFile);
		return iconFile;
	}
}

CCSpriteFrame* PackageManager::getIconSpriteFrame( unsigned int dataId )
{
	std::string iconFile = getItemTypeData(dataId).icon;
	if(iconFile.empty())
		iconFile = "huodong_hyd03";//TODO 修改为默认值
	return getIconFrameByName(iconFile);
}

CCSpriteFrame * PackageManager::getIconFrameByName( const std::string &name )
{
	CCSpriteFrame *spriteFrame = CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(name.c_str());
	if(spriteFrame == NULL)
	{
		//ZHJL： UI读CCBI的，直接用32位图片格式
		CCTexture2DPixelFormat currentFormat = CCTexture2D::defaultAlphaPixelFormat();
		CCTexture2D::setDefaultAlphaPixelFormat(kCCTexture2DPixelFormat_RGBA8888);

		std::string fileName = CFGReader::instance()->get_profile_string("Art", "ICON", "") + name + std::string(".png");
		CCImage image;
		image.initWithImageFile(fileName.c_str());
		CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addUIImage(&image, name.c_str());
		CCSpriteFrame *frame = CCSpriteFrame::createWithTexture(texture, CCRect(0.0, 0.0, texture->getPixelsWide(), texture->getPixelsHigh()));
		CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFrame(frame, name.c_str());
		//暂时替换，以后再改
		spriteFrame = CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(name.c_str());

		//ZHJL： UI读CCBI的，直接用32位图片格式，用完再设回来
		CCTexture2D::setDefaultAlphaPixelFormat(currentFormat);
	}
	CC_ASSERT(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(name.c_str()) != NULL);
	return spriteFrame;
}

CCSpriteFrame *PackageManager::getFrameByName(const std::string &name, const char* pFileFolder, const char* pFileType)
{
	CCSpriteFrame *spriteFrame = CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(name.c_str());
	if(spriteFrame == NULL)
	{
		std::string fileName = CFGReader::instance()->get_profile_string("Art", pFileFolder, "") + name + "." + std::string(pFileType);
		CCSprite* pSprite = CCSprite::create(fileName.c_str());
		if(!pSprite)
			return NULL;

		spriteFrame = pSprite->displayFrame();
		CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFrame(spriteFrame, name.c_str());
	}
	CC_ASSERT(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(name.c_str()) != NULL);
	return spriteFrame;
}

std::string PackageManager::getBlockFrameName()
{
	std::string iconFile = "rendui_icon_block";
	/*getIconFrameByName(iconFile);*/
	//if(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(iconFile.c_str()) == NULL)
	//{
	//	std::string fileName = CFGReader::instance()->get_profile_string("Art", "ICON", "") + iconFile + std::string(".png");
	//	CCImage image;
	//	image.initWithImageFile(fileName.c_str());
	//	CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addUIImage(&image, iconFile.c_str());
	//	CCSpriteFrame *frame = CCSpriteFrame::createWithTexture(texture, CCRect(0.0, 0.0, texture->getPixelsWide(), texture->getPixelsHigh()));
	//	CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFrame(frame, iconFile.c_str());
	//}
	return iconFile;
}

std::string PackageManager::getSelectFrameName()
{
	std::string iconFile = "icon_package_select";
	if(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(iconFile.c_str()) == NULL)
	{
		std::string fileName = CFGReader::instance()->get_profile_string("Art", "ICON", "") + iconFile + std::string(".png");
		CCImage image;
		image.initWithImageFile(fileName.c_str());
		CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addUIImage(&image, iconFile.c_str());
		CCSpriteFrame *frame = CCSpriteFrame::createWithTexture(texture, CCRect(0.0, 0.0, texture->getPixelsWide(), texture->getPixelsHigh()));
		CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFrame(frame, iconFile.c_str());
	}
	return iconFile;
}

std::string PackageManager::getLockFrameName()
{
	std::string iconFile = "rendui_icon_lock";
	/*if(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(iconFile.c_str()) == NULL)
	{
	std::string fileName = CFGReader::instance()->get_profile_string("Art", "ICON", "") + iconFile + std::string(".png");
	CCImage image;
	image.initWithImageFile(fileName.c_str());
	CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addUIImage(&image, iconFile.c_str());
	CCSpriteFrame *frame = CCSpriteFrame::createWithTexture(texture, CCRect(0.0, 0.0, texture->getPixelsWide(), texture->getPixelsHigh()));
	CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFrame(frame, iconFile.c_str());
	}*/
	return iconFile;
}

std::string PackageManager::getBindFrameName(int type)
{
	std::string iconFile = type == 0?"icon_bind":"icon_bindmohun";
	getIconFrameByName(iconFile);
	//if(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(iconFile.c_str()) == NULL)
	//{
	//	std::string fileName = CFGReader::instance()->get_profile_string("Art", "ICON", "") + iconFile + std::string(".png");
	//	CCImage image;
	//	image.initWithImageFile(fileName.c_str());
	//	CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addUIImage(&image, iconFile.c_str());
	//	CCSpriteFrame *frame = CCSpriteFrame::createWithTexture(texture, CCRect(0.0, 0.0, texture->getPixelsWide(), texture->getPixelsHigh()));
	//	CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFrame(frame, iconFile.c_str());
	//}
	return iconFile;
}

std::string PackageManager::getQualityFramName( EItemQuality itemQuality )
{
	std::string iconFile;
	switch (itemQuality)
	{
	case EIQ_Null:
		iconFile = "icon_equip_normal";
		break;
	case EIQ_Quality0:
		iconFile = "icon_equip_normal";
		break;
	case EIQ_Quality1:
		iconFile = "icon_equip_youxiu";
		break;
	case EIQ_Quality2:
		iconFile = "icon_equip_zhuoyue";
		break;
	case EIQ_Quality3:
		iconFile = "icon_equip_wanmei";
		break;
	case EIQ_Quality4:
		iconFile = "icon_equip_shishi";
		break;
	case EIQ_Quality5:
		iconFile = "icon_equip_chuanshuo";
		break;
	}
	PackageManager::getIconFrameByName(iconFile);
	//if(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(iconFile.c_str()) == NULL)
	//{
	//	std::string fileName = CFGReader::instance()->get_profile_string("Art", "ICON", "") + iconFile + std::string(".png");
	//	CCImage image;
	//	image.initWithImageFile(fileName.c_str());
	//	CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addUIImage(&image, iconFile.c_str());
	//	CCSpriteFrame *frame = CCSpriteFrame::createWithTexture(texture, CCRect(0.0, 0.0, texture->getPixelsWide(), texture->getPixelsHigh()));
	//	CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFrame(frame, iconFile.c_str());
	//}
	return iconFile;
}

std::string PackageManager::getIconIdName(unsigned int dataId)
{
	ItemData::iterator iter = _itemData.find(dataId);
	if(iter != _itemData.end())
	{
		const ItemTypeData &data = iter->second;
		return data.icon;
	}
	//从数据库中查找
	std::string iconFile = "";
	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData WHERE TypeId = ?1");
	cmd->set_integer32(1 , dataId);
	c_sql_table* table = c_db_manager::getSingleton()->create_table(); //单例对象调用函数  创建表
	while(table->retrieve_row())    //把数据在表中取出放到typedata中
	{
		unsigned int idx = table->get_index("Icon");
		iconFile = table->get_text(idx);
	}
	c_db_manager::getSingleton()->destroy_table(table);
	c_db_manager::getSingleton()->end_operation(cmd);

	if(iconFile.empty())
		iconFile = "huodong_hyd03";//TODO 修改为默认值
	return iconFile;
}

GameActionNode* PackageManager::getSurrundSuperEffect()
{
	GameActionNode* surrundAcNode = GameActionNode::create();
	// 	for (int j = 1; j < 99; ++j)
	// 	{
	// 		CCString* seNameStr = CCString::createWithFormat("%s%02d", "E1_39", j);
	// 		if (!surrundAcNode->AddTexture(seNameStr->getCString(), "Effect", "png"))
	// 			break;
	// 	}
	surrundAcNode->InitTextureWithSpriteFrame("E1_39");

	return surrundAcNode;
}

void PackageManager::destroyAllIconFrames()
{
	//for(IconFrames::iterator iter = _iconFrames.begin(); iter != _iconFrames.end(); iter ++)
	//{
	//	std::string frameName = iter->second;
	//	if(!frameName.empty())
	//	{
	//		CCSpriteFrameCache::sharedSpriteFrameCache()->removeSpriteFrameByName(frameName.c_str());
	//		CCTextureCache::sharedTextureCache()->removeTextureForKey(frameName.c_str());
	//	}
	//}
	//_iconFrames.clear();
}

void PackageManager::changeItemPosition( EItemConType conType, short src, short dest, int num /*= 0*/ )  //同一容器中物品的移动 交换位置
{
	AudioPlayer::getSigletonPtr()->playerSoundUIEffect(SOUND_23);//13
	if(src == dest)
		return;

	int count = _conSize[conType];//得到容器中有效（解锁）个数;

	int index = count - 1;
	if (src > index || dest > index)
		return;

	ItemMap *itemMap = getItemMap(conType);
	if(itemMap == NULL)
		return;

	f_item *srcItem = getItem(*itemMap, src);
	f_item *desItem = getItem(*itemMap,dest);//游戏中单堆物品类

	//锁定物品不可移动 //add by XSea 2014.11.21
	if( srcItem != NULL  )
	{
		if( srcItem->is_locked() )
			return;
	}
	if( desItem != NULL  )
	{
		if( desItem->is_locked() )
			return;
	}

	//先找物品类别
	const ItemTypeData &typeData = PackageManager::getInstance()->getItemTypeData(srcItem->get_item_type_id());
	ePackageItemType eItemType = typeData.type;

	//如果类别是功法
	if( eItemType == PIT_Kungfu || eItemType == PIT_KungfuExp)
	{
		if(desItem == NULL)
		{
			lockItem(conType, src, false);
			lockItem(conType, dest);

			ePackageItemType nTypeSrc = PIT_INVALID;
			ePackageItemType nTypeDest = PIT_INVALID;
			if (EICT_Bag == conType)
			{
				if (srcItem)
				{
					const ItemTypeData &typeData = getItemTypeData(srcItem->get_item_type_id());//gx add
					nTypeSrc = typeData.type;
				}
				if (desItem)
				{
					const ItemTypeData &typeData = getItemTypeData(desItem->get_item_type_id());//gx add
					nTypeDest = typeData.type;
				}
			}

			NET_SIC_item_position_change cmd;
			cmd.n64_serial = srcItem->get_item_id();
			cmd.n16Num = num;
			cmd.eConType = conType;
			cmd.n16PosDst =dest;

			cmd.dwNPCID = get_npc_id_by_cnt_type(conType);
// 			if(conType == EICT_RoleWare)
// 				cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
// 			else
// 				cmd.dwNPCID = (unsigned int)-1;
			TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, false);
			return;
		}

		if(conType == EICT_Equip)
		{
			if(src + dest != EEP_Finger1 + EEP_Finger2 &&
				src + dest != EEP_Wrist1 + EEP_Wrist2)
				return;
		}
		//gx add 背包中的移动的目标位置上的物品不能为锁定状态;
		if (EICT_Bag == conType)
		{
			if (desItem != NULL)//若目标位置非空;
			{
				if(desItem->is_locked())//若已处于锁定状态，则禁止移动;
					return;
			}

		}
		//判断谁吞噬谁后发布信息
		f_equipment *tempsrcItem = dynamic_cast<f_equipment*>(srcItem);
		f_equipment *tempdesItem = dynamic_cast<f_equipment*>(desItem);
		//双方武学的类型
// 		int tempSrcType = 0;
// 		int tempDesType = 0;
// 		//武学双方的类型
// 		c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData WHERE typeId = ?1");
// 		cmd->set_integer32(1 , srcItem->get_item_type_id());
// 		c_sql_table* table = c_db_manager::getSingleton()->create_table();
// 
// 		while(table->retrieve_row())
// 		{
// 			unsigned int idx = table->get_index("Type");
// 			tempSrcType = table->get_integer32(idx);
// 		}
// 		c_db_manager::getSingleton()->destroy_table(table);
// 		c_db_manager::getSingleton()->end_operation(cmd);
// 
// 		c_sql_command* cmd_2 = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData WHERE typeId = ?1");
// 		cmd_2->set_integer32(1 , desItem->get_item_type_id());
// 		c_sql_table* table_2 = c_db_manager::getSingleton()->create_table();
// 
// 		while(table_2->retrieve_row())
// 		{
// 			unsigned int idx = table_2->get_index("Type");
// 			tempDesType = table_2->get_integer32(idx);
// 		}
// 		c_db_manager::getSingleton()->destroy_table(table_2);
// 		c_db_manager::getSingleton()->end_operation(cmd_2);

		std::string msgFirstName;
		std::string msgSecondName;//被吞噬的武学
		int firstLv = 0;
		int secondLv = 0;
		unsigned char ignore_state=0;
		if(!check_absorb(tempsrcItem,tempdesItem,msgFirstName,msgSecondName,firstLv,secondLv,ignore_state))
			return;
// 		if((tempsrcItem->get_item_quality() == EIQ_Quality0 && tempdesItem->get_item_quality() == EIQ_Quality0) ||
// 			(tempSrcType == PIT_KungfuExp && tempDesType == PIT_KungfuExp))
// 		{//2个都是普通武学或经验珠
// 			if (tempSrcType == EIT_KungfuExp)
// 			{//经验珠
// 				//经验珠之间不能进行融合
// 
// 				MessageBoxUi *messageBox = MessageBoxUi::createWithOneBtn("",STRING_TABLE["gongfa_string14"], TEXT_UTF8_QUEDING);
// 				World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 			} 
// 			else
// 			{//普通武学
// 				//普通功法之间不能进行融合
// 				MessageBoxUi *messageBox = MessageBoxUi::createWithOneBtn("",STRING_TABLE["gongfa_string20"], TEXT_UTF8_QUEDING);
// 				World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 			}
// 			return;
// 		}
// 		else if((tempsrcItem->get_item_quality() == EIQ_Quality0 && tempDesType == PIT_KungfuExp ||
// 			(tempSrcType == PIT_KungfuExp && tempdesItem->get_item_quality() == EIQ_Quality0)))
// 		{
// 			//品质普卡武学不能与经验珠融合
// 			MessageBoxUi *messageBox = MessageBoxUi::createWithOneBtn("",STRING_TABLE["gongfa_string21"], TEXT_UTF8_QUEDING);//普通功法之间不能进行融合
// 			World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 			return;
// 		}
// 		else if((tempsrcItem->get_item_quality() == EIQ_Quality0 && tempdesItem->get_item_quality() != EIQ_Quality0)||
// 			(tempSrcType == PIT_KungfuExp && tempDesType != PIT_KungfuExp))
// 		{
// 			msgSecondName = tempsrcItem->GetItemName();
// 			msgFirstName = tempdesItem->GetItemName();
// 			firstLv = tempdesItem->get_equip()->nLevel;
// 			secondLv = tempsrcItem->get_equip()->nLevel;
// 		}
// 		else if((tempsrcItem->get_item_quality() != EIQ_Quality0 && tempdesItem->get_item_quality() == EIQ_Quality0)||
// 			(tempSrcType != PIT_KungfuExp && tempDesType == PIT_KungfuExp))
// 		{
// 			msgFirstName = tempsrcItem->GetItemName();
// 			msgSecondName = tempdesItem->GetItemName();
// 			firstLv = tempsrcItem->get_equip()->nLevel;
// 			secondLv = tempdesItem->get_equip()->nLevel;
// 		}
// 		else
// 		{
// 			if (tempsrcItem->get_modified_quanlity() < tempdesItem->get_modified_quanlity())//1、判断品质
// 			{
// 				msgFirstName = tempdesItem->GetItemName();
// 				msgSecondName = tempsrcItem->GetItemName();
// 				firstLv = tempdesItem->get_equip()->nLevel;
// 				secondLv = tempsrcItem->get_equip()->nLevel;
// 			}
// 			else if (tempsrcItem->get_modified_quanlity() == tempdesItem->get_modified_quanlity())
// 			{//品质相等接下来判断物品等级
// 				if (tempsrcItem->get_equip()->nLevel <= tempdesItem->get_equip()->nLevel)
// 				{
// 					msgFirstName = tempdesItem->GetItemName();
// 					msgSecondName = tempsrcItem->GetItemName();
// 					firstLv = tempdesItem->get_equip()->nLevel;
// 					secondLv = tempsrcItem->get_equip()->nLevel;
// 				}
// 				else
// 				{
// 					msgFirstName = tempsrcItem->GetItemName();
// 					msgSecondName = tempdesItem->GetItemName();
// 					firstLv = tempsrcItem->get_equip()->nLevel;
// 					secondLv = tempdesItem->get_equip()->nLevel;
// 				}
// 			}
// 			else
// 			{
// 				msgFirstName = tempsrcItem->GetItemName();
// 				msgSecondName = tempdesItem->GetItemName();
// 				firstLv = tempsrcItem->get_equip()->nLevel;
// 				secondLv = tempdesItem->get_equip()->nLevel;
// 			}
// 		}

		//end

		lockItem(conType, src, false);
		lockItem(conType, dest);

		ePackageItemType nTypeSrc = PIT_INVALID;
		ePackageItemType nTypeDest = PIT_INVALID;
		ItemTypeData typeSrcData;
		ItemTypeData typeDestData;
		//if (EICT_Bag == conType)
		//{
			if (srcItem)
			{
				typeSrcData = getItemTypeData(srcItem->get_item_type_id());//gx add
				nTypeSrc = typeData.type;
			}
			if (desItem)
			{
				typeDestData = getItemTypeData(desItem->get_item_type_id());//gx add
				nTypeDest = typeData.type;
			}
		//}
		m_WuxueData.n16Index = srcItem->get_item_id();
		m_WuxueData.num = num;
		m_WuxueData.conType = conType;
		m_WuxueData.src = src;
		m_WuxueData.dest =dest;
		//武学背包融合
 		CCString tempMsg = CCString::createWithFormat("%d%s%s%s%d%s%s",firstLv,GET_STR(77).c_str(),msgFirstName.c_str(),"\xE6\x98\xAF\xE5\x90\xA6\xE5\x90\x9E\xE5\x99\xAC",secondLv,GET_STR(77).c_str(),msgSecondName.c_str())->getCString();
// 		MessageBoxUi *msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,
// 			tempMsg.getCString(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
		bool t_srcVerify = typeSrcData.byQuality >= 3 && typeSrcData.type != PIT_KungfuExp;
		bool t_tarVerify = typeDestData.byQuality >= 3 && typeDestData.type != PIT_KungfuExp;
		if ( t_srcVerify || t_tarVerify)
		{
			std::function<void(bool)> func = [tempMsg,this](bool isSuccess){
				if (isSuccess)
				{
					MessageBoxUi *msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,
						tempMsg.getCString(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
					World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
					msgUi->signalOkBtnPressed.connect(this, &PackageManager::onWuxueFusionOk);
					msgUi->signalCancelBtnPressed.connect(this , &PackageManager::onWuxueFusionClannel);
				}
				else
				{
					PackageManager::getInstance()->onWuxueFusionClannel();
				}
			};
			SecondVerifyMgr::getInstance()->try_request_safe_verify(func);
		}
		else
		{
			MessageBoxUi *msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,
				tempMsg.getCString(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
			msgUi->signalOkBtnPressed.connect(this, &PackageManager::onWuxueFusionOk);
			msgUi->signalCancelBtnPressed.connect(this , &PackageManager::onWuxueFusionClannel);
		}

		
	}
	else
	{
		lockItem(conType, src, false);
		lockItem(conType, dest);

		//ePackageItemType nTypeSrc = PIT_INVALID;
		//ePackageItemType nTypeDest = PIT_INVALID;
		if (EICT_Bag == conType)
		{
			// 			if (srcItem)
			// 			{
			// 				const ItemTypeData &typeData = getItemTypeData(srcItem->get_item_type_id());//gx add
			// 				//nTypeSrc = typeData.type;
			// 			}
			// 			if (desItem)
			// 			{
			// 				const ItemTypeData &typeData = getItemTypeData(desItem->get_item_type_id());//gx add
			// 				//nTypeDest = typeData.type;
			// 			}
		}
		//是否一个绑定一个不绑定
		//是否类型相同
		if (desItem != NULL)
		{
			if ((onIsItemStackable(desItem->get_item_type_id()) != desItem->get_item_number()) &&
				(onIsItemStackable(srcItem->get_item_type_id()) != srcItem->get_item_number()))
			{
				if (srcItem->get_item_type_id() == desItem->get_item_type_id() &&
					(onIsItemStackable(desItem->get_item_type_id()) != 1) &&
					((srcItem->get_item_bind_status() != 0 && desItem->get_item_bind_status() == 0)||
					(srcItem->get_item_bind_status() == 0 && desItem->get_item_bind_status() != 0)))
				{
					// 					m_bindingItemData.src = src;
					// 					m_bindingItemData.dest = dest;
					// 					m_bindingItemData.srcItemId = srcItem->get_item_id();
					// 					m_bindingItemData.num = num;
					//m_bindingItemData.eConType = m_bindingItemData.destEConType = conType;
					// 					m_bindingItemData.n16PosDst =dest;
					saveBindingItemData(src,dest,srcItem,num,dest,conType,conType);
					//绑定和不绑定物品合并的提示
					MessageBoxUi *msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,GET_STR(2384).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
					World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
					msgUi->signalOkBtnPressed.connect(this, &PackageManager::onItemMergeOk);
					msgUi->signalCancelBtnPressed.connect(this, &PackageManager::onItemMergeClannel);
					return;
				}
			}
		}
		NET_SIC_item_position_change cmd;
		cmd.n64_serial = srcItem->get_item_id();
		cmd.n16Num = num;
		cmd.eConType = conType;
		cmd.n16PosDst =dest;
		cmd.dwNPCID = get_npc_id_by_cnt_type(conType);
// 		if(conType == EICT_RoleWare)
// 			cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
// 		else
// 			cmd.dwNPCID = (unsigned int)-1;
		TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, false);
	}
}

void PackageManager::saveBindingItemData(short src,short dest,f_item *item,int num,short posDes,EItemConType cntType,EItemConType detType)
{
	m_bindingItemData.src = src;
	m_bindingItemData.dest = dest;
	m_bindingItemData.srcItemId = item->get_item_id();
	m_bindingItemData.num = num;
	m_bindingItemData.n16PosDst =posDes;
	m_bindingItemData.eConType = cntType;
	m_bindingItemData.destEConType=detType;
}
short PackageManager::onIsItemStackable(unsigned int itemId)
{
	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData WHERE TypeId = ?1");
	cmd->set_integer32(1 , itemId);
	c_sql_table* table = c_db_manager::getSingleton()->create_table();
	int StackNumber = 0;
	while(table->retrieve_row())
	{
		unsigned int idx = table->get_index("StackNumber");
		StackNumber = table->get_integer32(idx);
	}
	c_db_manager::getSingleton()->destroy_table(table);
	c_db_manager::getSingleton()->end_operation(cmd);

	return StackNumber;
}

void PackageManager::onItemMergeOk()
{
	NET_SIC_item_position_change cmd;
	cmd.n64_serial = m_bindingItemData.srcItemId;
	cmd.n16Num = m_bindingItemData.num;
	cmd.eConType = m_bindingItemData.eConType;
	cmd.n16PosDst = m_bindingItemData.n16PosDst;
	cmd.dwNPCID = get_npc_id_by_cnt_type(m_bindingItemData.eConType);
// 	if(m_bindingItemData.eConType == EICT_RoleWare)
// 		cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
// 	else
// 		cmd.dwNPCID = (unsigned int)-1;
	TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, false);
}

void PackageManager::onEICT_RoleWareItemMergeOk()
{
	NET_SIC_item_position_change_extend cmd;
	cmd.eConTypeSrc = m_bindingItemData.eConType;
	cmd.eConTypeDst = m_bindingItemData.destEConType;
	cmd.n64Serial1 = m_bindingItemData.srcItemId;
	cmd.n16PosDst = m_bindingItemData.dest;
	cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
	TCP_CLIENT->send_net_cmd(&cmd, NP_IDLE, false);
	lockItem(m_bindingItemData.eConType, m_bindingItemData.src);
	lockItem(m_bindingItemData.destEConType, m_bindingItemData.dest);
}

void PackageManager::onItemMergeClannel()
{
	unLockItem(m_bindingItemData.eConType, m_bindingItemData.src, false);
	unLockItem(m_bindingItemData.eConType, m_bindingItemData.dest);
}

void PackageManager::onWuxueFusionOk()
{
	NET_SIC_item_position_change cmd;
	cmd.n64_serial = m_WuxueData.n16Index;
	cmd.n16Num = m_WuxueData.num;
	cmd.eConType = m_WuxueData.conType;
	cmd.n16PosDst =m_WuxueData.dest;
	cmd.dwNPCID = get_npc_id_by_cnt_type(m_WuxueData.conType);
// 	if(m_WuxueData.conType == EICT_RoleWare)
// 		cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
// 	else
// 		cmd.dwNPCID = (unsigned int)-1;
	TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, false);
}

void PackageManager::onWuxueFusionClannel()
{
	unLockItem(m_WuxueData.conType, m_WuxueData.src, false);
	unLockItem(m_WuxueData.conType, m_WuxueData.dest);
}
int PackageManager::changeDest(f_item *item)
{
	if(item == NULL || item->is_locked())
	{
		return 0;
	}
	int posIndex = 0;
// 修改完成	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM EquipData WHERE typeId = ?1");
// 	cmd->set_integer32(1 , item->get_item_type_id());
// 	c_sql_table* table = c_db_manager::getSingleton()->create_table();
// 	while(table->retrieve_row())
// 	{
// 		unsigned int idx = table->get_index("PosIndex");
// 		posIndex = table->get_integer32(idx);
// 	}
// 	c_db_manager::getSingleton()->destroy_table(table);
// 	c_db_manager::getSingleton()->end_operation(cmd);
	EquipData::iterator iter = _equipData.find(item->get_item_type_id());
	if (iter != _equipData.end())
	{
		posIndex = iter->second.posIndex;
	}

	if(posIndex == EEP_Ride)
	{
		PackageManager::getInstance()->equipRide(item->get_item_id());
	}
	else
	{
		//如果是戒指或护腕，则找到一个空位或低级别的替换
		if(posIndex == EEP_Finger1 || posIndex == EEP_Wrist1)
		{
			f_item *equipItem1 = PackageManager::getInstance()->getItem(EICT_Equip, (short)posIndex);
			f_item *equipItem2 = PackageManager::getInstance()->getItem(EICT_Equip, (short)(posIndex + 1));
			if(equipItem1 != NULL)
			{
				if(equipItem2 == NULL)
				{
					posIndex += 1;
				}
				else
				{
					f_equipment* equipTypeData1 = dynamic_cast<f_equipment*>(equipItem1);
					f_equipment* equipTypeData2 = dynamic_cast<f_equipment*>(equipItem2);
					if(equipTypeData1->get_equip()->nRating > equipTypeData2->get_equip()->nRating)
						posIndex += 1;
				}
			}
		}
	}
	return posIndex;
}

void PackageManager::changeItemPosition( EItemConType srcConType, EItemConType destConType, short src, short dest, int num /*= 0*/ )  //不同容器间的物品移动  背包和仓库
{
	AudioPlayer::getSigletonPtr()->playerSoundUIEffect(SOUND_13);//add by vvv 2015.01.30
	CC_ASSERT(srcConType != destConType);
	
	//特殊魔魂的判断
	if (check_full_special_magic_soul(srcConType,destConType,src,dest)) return;

	//int srcCount = _conSize[srcConType];
	int destCount = _conSize[destConType];
	//int srcIndex = srcCount - 1;
	int destIndex = destCount - 1;

	//锁定的物品不可移动 //add by XSea 2014.11.21
	f_item *tmpSrcItem = NULL;
	if( srcConType == EICT_Bag  )
	{
		tmpSrcItem = getItem(srcConType, src);
		if( tmpSrcItem != NULL )
		{
			if( tmpSrcItem->is_locked() )
				return;
		}
	}

	if (srcConType == EICT_Bag && destConType == EICT_StallItem)
	{
		PlayerStallMgr::getInstance()->bag2stall(srcConType,destConType,src,dest,num);
		return;
	}

	if(srcConType == EICT_Equip || destConType == EICT_Equip)
	{//和装备栏相关的操作;
		if(srcConType == EICT_Equip)
		{
			if(destConType == EICT_Bag)
			{
				f_item *srcItem = getItem(srcConType, src);
				f_item *destItem = getItem(destConType, dest);
				if(destItem == NULL && srcItem != NULL)
				{//目标为空，才能够脱装备;
					INT64 itemId = srcItem->get_item_id();
					NET_SIC_unequip cmd;
					cmd.n64_serial = itemId;
					cmd.n16PosDst = dest;
					TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, false);
					lockItem(srcConType, src);
					lockItem(destConType, dest);
				}
			}
		}
		else if(destConType == EICT_Equip)
		{
			_srcEquip = dynamic_cast<f_equipment*>(getItem(srcConType, src));
			_descEquip = dynamic_cast<f_equipment*>(getItem(destConType,dest));
			if(_srcEquip != NULL)
			{
				replace_jewel(_srcEquip,_descEquip);
// 				if(MIsEquipment(_srcEquip->get_item_type_id()))
// 				{
// 					if((_descEquip != NULL) && (_descEquip->get_equip_gem_num() > 0) && (_srcEquip->get_equip_gem_num() == 0) && (_srcEquip->get_equip_max_hole_num() != 0))
// 					{
// 						const EquipTypeData& srcEquipData=getEquipTypeData(_srcEquip->get_item_type_id());
// 						const EquipTypeData& descEquipData=getEquipTypeData(_descEquip->get_item_type_id());
// 						string srcProfession = srcEquipData.profession.substr(0,srcEquipData.profession.size() - 6);//这里减6是因为只有减6才能够成功判断职业
// 						string descProfession = descEquipData.profession.substr(0,descEquipData.profession.size() - 6);
// 						if((srcEquipData.posIndex == descEquipData.posIndex)&&(srcProfession == descProfession))
// 						{ //职业相同则替换，职业不同则不替换
// 							bool canInlay = false;
// 							for(int i = 0; i < _descEquip->get_equip_max_hole_num(); ++i)//判断目标装备上是否有合适的宝石，如果有则镶嵌，否则不镶嵌
// 							{
// 								unsigned int typeId = _descEquip->get_equip_hold_gem_id(i);
// 								const ItemTypeData& gem = getItemTypeData(typeId);
// 								if(gem.special_value_1 <= srcEquipData.jewel_limit)
// 								{
// 									canInlay = true;
// 									break;
// 								}
// 							}
// 							if(canInlay)
// 							{
// 								MessageBoxUi *repairSignUI = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, TEXT_UTF8_REPLACETEXT, TEXT_UTF8_REPLACE,TEXT_UTF8_NOREPLACE);
// 								World::getInstance()->getScene()->addChild(repairSignUI, WZ_MESSAGEBOX);
// 								repairSignUI->signalOkBtnPressed.connect(this,&PackageManager::replaceGem);
// 								repairSignUI->signalCancelBtnPressed.connect(this,&PackageManager::changePositionForDressEquip);
// 							}
// 							else
// 							{
// 								changePositionForDressEquip();
// 							}
// 						}
// 					}
// 					else
// 					{
// 						changePositionForDressEquip();
// 					}
// 				}
			}
			//changePositionForDressEquip(src,dest);
		}
	}
	else if(srcConType == EICT_RoleWare || destConType == EICT_RoleWare)
	{//和仓库相关的操作
		f_item *item = getItem(srcConType, src);
		if (dest > destIndex)
			return;
		f_item *destItem = getItem(destConType, dest);
		if (destItem && item)
		{
			//是否一个绑定一个不绑定
			//是否类型相同
			if ((onIsItemStackable(destItem->get_item_type_id()) != destItem->get_item_number()) &&
				(onIsItemStackable(item->get_item_type_id()) != item->get_item_number()))
			{
				if (item->get_item_type_id() == destItem->get_item_type_id() &&
					(onIsItemStackable(destItem->get_item_type_id()) != 1) &&
					((item->get_item_bind_status() != 0 && destItem->get_item_bind_status() == 0)||
					(item->get_item_bind_status() == 0 && destItem->get_item_bind_status() != 0)))
				{
					// 					m_bindingItemData.src = src;
					// 					m_bindingItemData.dest = dest;
					// 					m_bindingItemData.eConType = srcConType;
					//					m_bindingItemData.destEConType = destConType;
					// 					m_bindingItemData.srcItemId = item->get_item_id();
					// 					m_bindingItemData.n16PosDst = dest;
					saveBindingItemData(src,dest,item,NULL,dest,srcConType,destConType);
					//绑定和不绑定物品合并的提示
					MessageBoxUi *msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,
						GET_STR(2384).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
					World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
					msgUi->signalOkBtnPressed.connect(this, &PackageManager::onEICT_RoleWareItemMergeOk);
					msgUi->signalCancelBtnPressed.connect(this, &PackageManager::onItemMergeClannel);
					return;
				}
			}
		}

		if(item != NULL)
		{
			NET_SIC_item_position_change_extend cmd;
			cmd.eConTypeSrc = srcConType;
			cmd.eConTypeDst = destConType;
			cmd.n64Serial1 = item->get_item_id();
			cmd.n16PosDst = dest;
			cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
			TCP_CLIENT->send_net_cmd(&cmd, NP_IDLE, false);
			lockItem(srcConType, src);
			lockItem(destConType, dest);
		}
	}
	//[bing] 功法装备直接走容器移动就行了 服务器统一判断是移动还是融合
	/*
	else if(EICT_KungfuBag == srcConType && EICT_KungfuEquip == destConType)
	{
	//若目标功法槽为空，则只是穿上该功法；若非空，则是融合的操作。
	f_item *destItem = getItem(destConType, dest);
	if (!destItem)//若功法槽为空
	{
	f_item *srcItem = getItem(srcConType, src);
	INT64 itemId = srcItem->get_item_id();
	NET_SIC_equip_kungfu cmd;
	cmd.n64_serial = itemId;
	cmd.ePosDst = (EKungfuEquipPos)(dest);
	TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);
	lockItem(srcConType, src);
	lockItem(destConType, dest);
	_tmpKungfuData[itemId] = (EKungfuEquipPos)dest;
	}
	}
	*/
	//[bing] 应该是通用容器互换了
	else
	{
		f_item *item = getItem(srcConType, src);
		if(item)
		{
			ItemMap *itemMapSrc = getItemMap(srcConType);
			ItemMap *itemMapdes = getItemMap(destConType);
			if(itemMapSrc == NULL)
				return;
			if (itemMapdes == NULL)
				return;
			//判断谁吞噬谁后发布信息
			f_item *srcItem = getItem(*itemMapSrc, src);
			f_item *desItem = getItem(*itemMapdes,dest);
			bool t_bIsIgore = false;
			if (desItem == NULL)
			{
				if (destConType == EICT_KungfuEquip)
				{
					f_equipment *tempsrcItem = dynamic_cast<f_equipment*>(srcItem);
					if (tempsrcItem->get_item_quality() == EIQ_Quality0)
					{//品质为普通 gongfa_string15
						ToolTip::getInstance()->push(STRING_TABLE["gongfa_string15"]);
						return;
					}
					int tempItemType = 0;
					c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData WHERE typeId = ?1");
					cmd->set_integer32(1 , srcItem->get_item_type_id());
					c_sql_table* table = c_db_manager::getSingleton()->create_table();

					while(table->retrieve_row())
					{
						unsigned int idx = table->get_index("Type");
						tempItemType = table->get_integer32(idx);
					}
					c_db_manager::getSingleton()->destroy_table(table);
					c_db_manager::getSingleton()->end_operation(cmd);

					if (tempItemType == PIT_KungfuExp)
					{//经验珠
						ToolTip::getInstance()->push(STRING_TABLE["gongfa_string15"]);
						return;
					}
				}

				NET_SIC_item_position_change_extend cmd;
				cmd.eConTypeSrc = srcConType;
				cmd.eConTypeDst = destConType;
				cmd.n64Serial1 = srcItem->get_item_id();
				cmd.n16PosDst = dest;
				cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
				TCP_CLIENT->send_net_cmd(&cmd, NP_IDLE, false);
				lockItem(srcConType, src);
				lockItem(destConType, dest);
			}
			else
			{
				f_equipment *tempsrcItem = dynamic_cast<f_equipment*>(srcItem);
				f_equipment *tempdesItem = dynamic_cast<f_equipment*>(desItem);
				if (tempsrcItem == NULL)
					return;
				if (tempdesItem == NULL)
					return;

				//双方武学的类型
// 				int tempSrcType = 0;
// 				int tempDesType = 0;
// 				//武学双方的类型
// 				c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData WHERE typeId = ?1");
// 				cmd->set_integer32(1 , srcItem->get_item_type_id());
// 				c_sql_table* table = c_db_manager::getSingleton()->create_table();
// 
// 				while(table->retrieve_row())
// 				{
// 					unsigned int idx = table->get_index("Type");
// 					tempSrcType = table->get_integer32(idx);
// 				}
// 				c_db_manager::getSingleton()->destroy_table(table);
// 				c_db_manager::getSingleton()->end_operation(cmd);
// 
// 				c_sql_command* cmd_2 = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData WHERE typeId = ?1");
// 				cmd_2->set_integer32(1 , desItem->get_item_type_id());
// 				c_sql_table* table_2 = c_db_manager::getSingleton()->create_table();
// 
// 				while(table_2->retrieve_row())
// 				{
// 					unsigned int idx = table_2->get_index("Type");
// 					tempDesType = table_2->get_integer32(idx);
// 				}
// 				c_db_manager::getSingleton()->destroy_table(table_2);
// 				c_db_manager::getSingleton()->end_operation(cmd_2);

				std::string msgFirstName;
				std::string msgSecondName;//被吞噬的武学
				int firstLv = 0;
				int secondLv = 0;
				unsigned char ignore_state=0;
				if (!check_absorb(tempsrcItem,tempdesItem,msgFirstName,msgSecondName,firstLv,secondLv,ignore_state)) return;

// 				if((tempsrcItem->get_item_quality() == EIQ_Quality0 && tempdesItem->get_item_quality() == EIQ_Quality0) ||
// 					(tempSrcType == PIT_KungfuExp && tempDesType == PIT_KungfuExp))
// 				{//2个都是普通武学或经验珠
// 					if (tempSrcType == EIT_KungfuExp)
// 					{//经验珠
// 						MessageBoxUi *messageBox = MessageBoxUi::createWithOneBtn("",STRING_TABLE["gongfa_string20"], TEXT_UTF8_QUEDING);//普通功法之间不能进行融合
// 						World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 					} 
// 					else
// 					{//普通武学
// 						MessageBoxUi *messageBox = MessageBoxUi::createWithOneBtn("",STRING_TABLE["gongfa_string8"], TEXT_UTF8_QUEDING);
// 						World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 					}
// 					return;
// 				}
// 				else if((tempsrcItem->get_item_quality() == EIQ_Quality0 && tempdesItem->get_item_quality() != EIQ_Quality0)||
// 					(tempSrcType == PIT_KungfuExp && tempDesType != PIT_KungfuExp))
// 				{
// 					msgSecondName = tempsrcItem->GetItemName();
// 					msgFirstName = tempdesItem->GetItemName();
// 					firstLv = tempdesItem->get_equip()->nLevel;
// 					secondLv = tempsrcItem->get_equip()->nLevel;
// 				}
// 				else if((tempsrcItem->get_item_quality() != EIQ_Quality0 && tempdesItem->get_item_quality() == EIQ_Quality0)||
// 					(tempSrcType != PIT_KungfuExp && tempDesType == PIT_KungfuExp))
// 				{
// 					msgFirstName = tempsrcItem->GetItemName();
// 					msgSecondName = tempdesItem->GetItemName();
// 					firstLv = tempsrcItem->get_equip()->nLevel;
// 					secondLv = tempdesItem->get_equip()->nLevel;
// 				}
// 				else
// 				{
// 					if (tempsrcItem->get_modified_quanlity() < tempdesItem->get_modified_quanlity())//1、判断品质
// 					{
// 						msgFirstName = tempdesItem->GetItemName();
// 						msgSecondName = tempsrcItem->GetItemName();
// 						firstLv = tempdesItem->get_equip()->nLevel;
// 						secondLv = tempsrcItem->get_equip()->nLevel;
// 						t_bIsIgore = srcConType == EICT_KungfuEquip;
// 					}
// 					else if (tempsrcItem->get_modified_quanlity() == tempdesItem->get_modified_quanlity())
// 					{//品质相等接下来判断物品等级
// 						if (tempsrcItem->get_equip()->nLevel <= tempdesItem->get_equip()->nLevel)
// 						{
// 							msgFirstName = tempdesItem->GetItemName();
// 							msgSecondName = tempsrcItem->GetItemName();
// 							firstLv = tempdesItem->get_equip()->nLevel;
// 							secondLv = tempsrcItem->get_equip()->nLevel;
// 							t_bIsIgore = srcConType == EICT_KungfuEquip;
// 						}
// 						else
// 						{
// 							msgFirstName = tempsrcItem->GetItemName();
// 							msgSecondName = tempdesItem->GetItemName();
// 							firstLv = tempsrcItem->get_equip()->nLevel;
// 							secondLv = tempdesItem->get_equip()->nLevel;
// 							t_bIsIgore = srcConType != EICT_KungfuEquip;
// 						}
// 					}
// 					else
// 					{
// 						msgFirstName = tempsrcItem->GetItemName();
// 						msgSecondName = tempdesItem->GetItemName();
// 						firstLv = tempsrcItem->get_equip()->nLevel;
// 						secondLv = tempdesItem->get_equip()->nLevel;
// 						t_bIsIgore = srcConType != EICT_KungfuEquip;
// 					}
// 				}
				if (ignore_state)
					t_bIsIgore = ignore_state==1?srcConType == EICT_KungfuEquip:srcConType != EICT_KungfuEquip;

				if (t_bIsIgore)
				{
					MessageBoxUi* msgUi = MessageBoxUi::createWithOneBtn(TEXT_UTF8_TISHI,STRING_TABLE["mohun_cannot_swallow"], TEXT_UTF8_QUEDING);
					World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
// 					msgUi->signalOkBtnPressed.connect(this, &PackageManager::onEquipWuxueFusionOk);
// 					msgUi->signalCancelBtnPressed.connect(this, &PackageManager::onEquipWuxueFusionClannel);
					return;
				}
				m_WuxueData.n16Index = srcItem->get_item_id();
				m_WuxueData.n16IndexTar = desItem->get_item_id();
				m_WuxueData.num = num;
				m_WuxueData.conType = srcConType;
				m_WuxueData.destConType = destConType;
				m_WuxueData.dest = dest;
				m_WuxueData.src = src;
				//武学背包融合
				CCString tempMsg;
				if ((srcConType == EICT_KungfuBag && destConType == EICT_KungfuWare) || (srcConType == EICT_KungfuWare && destConType == EICT_KungfuBag) )
				{
					tempMsg = CCString::createWithFormat("%s%d%s%s%s%d%s%s%s","\xE6\x98\xAF\xE5\x90\xA6\xE4\xBA\xA4\xE6\x8D\xA2",firstLv,GET_STR(77).c_str(),msgFirstName.c_str(),
						"\xE5\x92\x8C",secondLv,GET_STR(77).c_str(),msgSecondName.c_str(),"\xE7\x9A\x84\xE4\xBD\x8D\xE7\xBD\xAE")->getCString();
				}
				else
				{
					tempMsg = CCString::createWithFormat("%d%s%s%s%d%s%s",firstLv,GET_STR(77).c_str(),msgFirstName.c_str(),
						"\xE6\x98\xAF\xE5\x90\xA6\xE5\x90\x9E\xE5\x99\xAC",secondLv,GET_STR(77).c_str(),msgSecondName.c_str())->getCString();
				}
				
				if (tempsrcItem->get_item_quality() >= 3 || tempdesItem->get_item_quality() >= 3)
				{
					std::function<void(bool)> func = [tempMsg,this](bool isSuccess){
						if (isSuccess)
						{
							MessageBoxUi* msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,tempMsg.getCString(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
							World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
							msgUi->signalOkBtnPressed.connect(this, &PackageManager::onEquipWuxueFusionOk);
							msgUi->signalCancelBtnPressed.connect(this, &PackageManager::onEquipWuxueFusionClannel);
						}
					};
					SecondVerifyMgr::getInstance()->try_request_safe_verify(func);
				}
				else
				{
					MessageBoxUi* msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,tempMsg.getCString(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
					World::getInstance()->getScene()->addChild(msgUi, WZ_MESSAGEBOX);
					msgUi->signalOkBtnPressed.connect(this, &PackageManager::onEquipWuxueFusionOk);
					msgUi->signalCancelBtnPressed.connect(this, &PackageManager::onEquipWuxueFusionClannel);
				}	
			}
		}
	}
}

void PackageManager::onEquipWuxueFusionOk()
{
	//身上装备合成
	NET_SIC_item_position_change_extend cmd;
	cmd.eConTypeSrc = m_WuxueData.conType;
	cmd.eConTypeDst = m_WuxueData.destConType;
	cmd.n64Serial1 = m_WuxueData.n16Index;
	cmd.n16PosDst = m_WuxueData.dest;
	cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
	TCP_CLIENT->send_net_cmd(&cmd, NP_IDLE, false);
	lockItem(m_WuxueData.conType, m_WuxueData.src);
	lockItem(m_WuxueData.destConType, m_WuxueData.dest);
}

void PackageManager::onEquipWuxueFusionClannel()
{
	unLockItem(m_WuxueData.conType, m_WuxueData.src, false);
	unLockItem(m_WuxueData.conType, m_WuxueData.dest);
}

unsigned int PackageManager::onItemPositionChanged( s_net_cmd *cmd )//物品交换位置函数
{
	if(cmd->id == message_id_crc("NET_SIS_item_position_change"))
	{
		NET_SIS_item_position_change *msg = (NET_SIS_item_position_change*)cmd;

		if(msg->dw_error_code == E_Item_Place_NotFree)
		{
			unLockItem(msg->eConType, msg->n16PosDst1, false);
			unLockItem(msg->eConType, msg->n16PosDst2, false);
			GET_UI(Package, WCT_PACKAGEUI)->updateData();
			GET_UI(Storage, WCT_StorageUi)->updateData();
			ToolTip::getInstance()->push(GET_STR(9446).c_str());
			return NULL;
		}
		//bool bRet = true;

		//查找所在容器，没有则返回
		ItemMap *itemMap = getItemMap(msg->eConType);
		if(itemMap == NULL)
			return false;

		//创建几个临时变量
		f_item* pItem1 = NULL;
		f_item* pItem2 = NULL;
		f_item* pTempItem = NULL;
		//unsigned int dwTypeID1 = -1;
		//unsigned int dwTypeID2 = -1;
		//物品一没有找到
		pItem1 = getItem(*itemMap, msg->n64Serial1);
		if(pItem1 == NULL)
			return false;

		//dwTypeID1 = pItem1->get_item_type_id();

		if(-1 == msg->n64Serial2)
		{
			//dwTypeID2 = dwTypeID1;

			pTempItem = remove(*itemMap, pItem1->get_pos());
			if(pTempItem != pItem1)
				return false;

			if(0 == msg->n16Num1)//如果数量为零直接删除
			{
				delete pItem1;
				pItem1 = NULL;
			}
			else
			{
				pItem1->set_pos(msg->n16PosDst1);
				pItem1->set_item_number(msg->n16Num1);
				addNewItem(*itemMap, pItem1);//添加一个新物品
			}
		}
		else
		{
			if(msg->bCreateItem)
			{

				pTempItem = remove(*itemMap, pItem1->get_pos());
				if(pTempItem != pItem1)
					return false;

				if(0 == msg->n16Num1)//如果数量为零直接删除
				{
					delete pItem1;
					pItem1 = NULL;
				}
				else
				{
					pItem1->set_pos(msg->n16PosDst1);
					addNewItem(*itemMap, pItem1);//添加一个新物品
					pItem1->set_item_number(msg->n16Num1);
				}
				//根据物品一创造物品二;
				if(MIsEquipment(pItem1->get_item_type_id()))
				{
					pItem2 = new f_equipment(*((f_equipment*)pItem1));
				}
				else
				{
					pItem2 = new f_item(*pItem1);
				}

				//dwTypeID2 = pItem2->get_item_type_id();

				pItem2->set_item_id(msg->n64Serial2);
				pItem2->set_pos(msg->n16PosDst2);	
				addNewItem(*itemMap, pItem2);//添加一个新物品
				pItem2->set_item_number(msg->n16Num2);
			}
			else
			{
				pItem2 = getItem(*itemMap, msg->n64Serial2);
				if(pItem2 == NULL)
					return false;

				//dwTypeID2 = pItem2->get_item_type_id();

				f_item* pTempItem = remove(*itemMap, pItem1->get_pos());
				if(pTempItem != pItem1)
					return false;
				pTempItem = remove(*itemMap, pItem2->get_pos());
				if(pTempItem != pItem2)
					return false;

				if(0 == msg->n16Num1)//如果数量为零直接删除;
				{
					//if (msg->eConType == EICT_Bag)
					//{
					//	s_notify_stall_item_remove evt(_T("notify_for_stall_remove"),NULL);
					//	evt.server_id = pItem1->get_item_id();
					//	SEND_EVENT(&evt);
					//}

					//SAFE_DELETE(pItem1);
					delete pItem1;
					pItem1 = NULL;
				}
				else
				{
					pItem1->set_pos(msg->n16PosDst1);
					pItem1->set_item_number(msg->n16Num1);
					addNewItem(*itemMap, pItem1);//添加一个新物品
					//bRet = bRet && pItemCon->add(pItem1);
				}

				pItem2->set_pos(msg->n16PosDst2);
				pItem2->set_item_number(msg->n16Num2);
				//bRet = bRet && pItemCon->add(pItem2);
				addNewItem(*itemMap, pItem2);//添加一个新物品
			}
		}

		unLockItem(msg->eConType, msg->n16PosDst1, false);
		unLockItem(msg->eConType, msg->n16PosDst2, false);
		GET_UI(Package, WCT_PACKAGEUI)->updateData();
		GET_UI(Storage, WCT_StorageUi)->updateData();

		//[bing] todo: 先mark下 若出现多次调用在考虑优化
		if( msg->eConType == EICT_KungfuBag )
			GET_UI(WuXueUi,WCT_WUXUEUI)->updateMartialData();
		else if( msg->eConType == EICT_KungfuWare )
			GET_UI(WuXueUi,WCT_WUXUEUI)->updateWare();
		else if( msg->eConType == EICT_KungfuEquip )
			GET_UI(WuXueUi,WCT_WUXUEUI)->updateEquip();
		else if( msg->eConType == EICT_KungfuTemp )
			GET_UI(CangJingGeUi,WCT_CangJingGeUi)->updateGongFaTemp();
	}
	return 0;
}

unsigned int PackageManager::onItemPositionChangedEx( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_item_position_change_extend"))
	{
		NET_SIS_item_position_change_extend *msg = (NET_SIS_item_position_change_extend*)cmd;

		if(msg->eConTypeDst1 == EICT_Equip)
		{//特殊处理
			unLockItem(msg->eConTypeDst1, msg->n64Serial2);
		}

		//bool bRet = true;

		ItemMap* pItemConSrc1 = getItemMap(msg->eConTypeSrc1);
		ItemMap* pItemConSrc2 = getItemMap(msg->eConTypeSrc2);
		ItemMap* pItemConDst1 = getItemMap(msg->eConTypeDst1);
		ItemMap* pItemConDst2 = getItemMap(msg->eConTypeDst2);
		if( pItemConSrc1 == NULL || pItemConSrc2 == NULL
			|| pItemConDst1 == NULL || pItemConDst2 == NULL )
			return false;

		f_item* pItem1 = NULL;
		f_item* pItem2 = NULL;
		f_item* pTempItem = NULL;
		//unsigned int dwTypeID1 = (unsigned int)-1;
		//unsigned int dwTypeID2 = (unsigned int)-1;
		//short n16Index1 = 0;
		//short n16Index2 = 0;

		if(-1 != msg->n64Serial1)
		{
			pItem1 = getItem(*pItemConSrc1, msg->n64Serial1);
			if(pItem1 == NULL)
				return false;

			pTempItem = remove(*pItemConSrc1, pItem1->get_pos());
			if(pTempItem != pItem1)
				return false;

			//dwTypeID1 = pItem1->get_item_type_id();
			//n16Index2 = pItem1->get_pos();

			//[bing] 摆摊下架物品同时删除额外数据
			if(msg->eConTypeSrc1 == EICT_StallItem )
			{
				GET_UI(NewStallUi, WCT_NEW_STALLUI)->DelStallItem(pItem1->get_pos(), false);
			}
		}

		if(-1 != msg->n64Serial2)
		{
			pItem2 = getItem(*pItemConSrc2, msg->n64Serial2);
			if(pItem2 == NULL)
				return false;

			pTempItem = remove(*pItemConSrc2, pItem2->get_pos());
			if(pTempItem != pItem2)
				return false;

			//dwTypeID2 = pItem2->get_item_type_id();
			//	n16Index1 = pItem2->get_pos();
		}

		if(0 == msg->n16Num1)//如果数量为零直接删除
		{
			if (pItem1 != NULL)
			{
				delete pItem1;
				pItem1 = NULL;
			}
		}

		if(pItem1 != NULL)
		{
			pItem1->set_container_type(msg->eConTypeDst1);
			pItem1->set_pos(msg->n16PosDst1);
			pItem1->set_item_number(msg->n16Num1);
			//bRet = bRet && pItemConDst1->add(pItem1); 

			addNewItem(pItem1);//添加一个新物品

			//[bing] 如果目标容器是摆摊 则要判断是否弹出摆摊界面3
			if(msg->eConTypeDst1 == EICT_StallItem )
			{
				GET_UI(NewStallUi, WCT_NEW_STALLUI)->AddStallItem(pItem1);
			}
		}

		if(pItem2 != NULL)
		{
			pItem2->set_container_type(msg->eConTypeDst2);
			pItem2->set_pos(msg->n16PosDst2);
			pItem2->set_item_number(msg->n16Num2);
			addNewItem(pItem2);//添加一个新物品
		}

		unLockItem(msg->eConTypeDst1, msg->n16PosDst1, false);
		unLockItem(msg->eConTypeDst2, msg->n16PosDst2, false);

		//更新ui
		updateUiWithConType(msg->eConTypeDst1);
		updateUiWithConTypeEx(msg->eConTypeDst2, msg->n16PosDst2);
		GET_UI(ShortCutUi, WCT_ShorCutUi)->updateUsedItem();
		if (msg->eConTypeDst1 == EICT_Equip || msg->eConTypeDst2 == EICT_Equip)
		{
			ForgingMgr::getInstance()->judgeForgingByItem();
			if (IS_UI_OPEN(WCT_ForgingDecomUI))
			{
				GET_UI(ForgingDecomUI, WCT_ForgingDecomUI)->getUiLayer()->updateRedPointShow();
			}
		}
	}
	return 0;
}

void PackageManager::reorderPackage(EItemConType conType)
{
	if(hasLockItem(conType))
	{
		//TODO: 提示信息
		return;
	}

	//首先锁定所有物品
	lockItem(conType);

	NET_SIC_stack_item cmd;
	cmd.eConType = conType;
	TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, false);
}

INT64 PackageManager::CalcItemWeight( f_item *pItem )
{
	INT64 nRet = 0;
	INT64 nTypeID = (INT64)pItem->get_item_type_id();

	if( 1310001 == nTypeID )
	{
		nRet = pItem->get_pos();
	}
	else if( 1009999 >= nTypeID)
	{
		nRet = nTypeID * 1000 + pItem->get_pos();
	}
	else if( 1109999 >= nTypeID)
	{
		nRet = nTypeID * 1000 + pItem->get_pos();
	}
	else if( MIsEquipment(nTypeID))
	{
		nRet = nTypeID * 1000 + pItem->get_pos();
	}
	else
	{
		nRet = nTypeID * 1000 + pItem->get_pos() + 10000000000; 
	}

	return nRet;
}

unsigned int PackageManager::onItemStack( s_net_cmd *cmd )
{
	//if(cmd->id == message_id_crc("NET_SIS_stack_item"))
	//{
		NET_SIS_stack_item *msg = (NET_SIS_stack_item*)cmd;
		
 		ItemMap *itemMap = getItemMap(msg->eConType);
 		if(itemMap != NULL)
 		{
			try_to_arrange_package(msg->eConType);
// 			int nMax = itemMap->size()*sizeof(tagItemOrder) + sizeof(NET_SIC_item_reorder_extend);
// 			unsigned char* pMsg = new unsigned char[nMax];
// 
// 			NET_SIC_item_reorder_extend* pCmd1 = (NET_SIC_item_reorder_extend*)pMsg;
// 			pCmd1->id = message_id_crc("NET_SIC_item_reorder_extend");
// 			if(msg->eConType == EICT_RoleWare)
// 				pCmd1->dwNPCID = StoreMgr::getInstance()->getNpcServerId();
// 			else
// 				pCmd1->dwNPCID = (unsigned int)-1;
// 			pCmd1->n16ItemNum = 0;
// 			size_t nSize = 0;
// 			short nPos = 0;
// 
// 
// 
// 			
// 			sorted_map_list need_sync;
// 
// 			if (msg->eConType  == EICT_KungfuBag)
// 			{
// 				//根据锁定和非锁定的分别处理
// 				std::map<INT64, f_item*> unbind_item_sort_result_map;
// 				std::vector<f_item*> need_sort;
// 				get_item_list(itemMap,true,need_sort);
// 				sort_items(need_sort,bind_item_sort_result_map);
// 				need_sync.push_back(bind_item_sort_result_map);
// 
// 				need_sort.clear();
// 				get_item_list(itemMap,false,need_sort);
// 				sort_items(need_sort,unbind_item_sort_result_map);
// 				need_sync.push_back(unbind_item_sort_result_map);
// 
// 				cal_ex_pair(bind_item_sort_result_map,nPos,nSize);
// 				cal_ex_pair(unbind_item_sort_result_map,nPos,nSize);
// 
// 			
// 				//make_msg_pack_ex(bind_item_sort_result_map,nSize,nPos);
// 				//make_msg_pack_ex(unbind_item_sort_result_map,nSize,nPos);
// 			}
// 			else
// 			{
// 				// 锁定所有物品,并计算物品的权重
// 				std::map<INT64, f_item*> tmpMap;
// 				for(ItemMap::iterator iter = itemMap->begin(); iter != itemMap->end(); ++ iter)
// 				{
// 					f_item *item = iter->second;
// 					//item->set_operable(false);
// 					tmpMap[CalcItemWeight(item)] = item;
// 				}
// 				cal_ex_pair(bind_item_sort_result_map,nPos,nSize);
// 				//make_msg_pack_ex(tmpMap,nSize,nPos);
// 			}
// 
// 			if(nSize == 0)// 如果没有数据则不发送排序消息
// 			{
// 				unLockItem(msg->eConType);
// 
// 				delete []pMsg;
// 				if(msg->eConType==EICT_KungfuBag||msg->eConType==EICT_KungfuTemp)
// 				{
// 					GambleMgr::getInstance()->showOneKeyLevelUpEffect();//功法背包,不需要排序直接显示升级特效
// 				}
// 				return 0;
// 			}
// 
// 			size_t no_ex_size = itemMap->size()*sizeof(short);
// 			if(nSize >= no_ex_size)
// 			{
// 				//使用整包
// 				int nMax = (itemMap->size()-1)* sizeof(short)+ sizeof(NET_SIC_item_reorder);
// 				MAKE_MSG_PACKAGE_AUTO_RELEASE(NET_SIC_item_reorder,short,itemMap->size());
// 				switch( msg->eConType )
// 				{
// 				case EICT_KungfuBag:
// 					p_send->by_type = 2;
// 					m_reoderGongFaItem=true;//记录下是否需要排序，服务器没法处理，只好用全局变量记录
// 					break;
// 				case EICT_KungfuTemp:
// 					p_send->by_type = 3;
// 					m_reoderGongFaItem=true;
// 					break;
// 				case EICT_RoleWare:
// 					p_send->by_type = 4;
// 					break;
// 				}
// 
// 				if(msg->eConType == EICT_RoleWare)
// 					p_send->dwNPCID = StoreMgr::getInstance()->getNpcServerId();
// 				else
// 					p_send->dwNPCID = INVALID;
// 
// 				p_send->n16ItemNum = short(itemMap->size());
// 				
// 				//std::copy(player_list.begin(),player_list.end(),&p_send->roldId[0]);
// 				//unsigned char* pMsg = new unsigned char[nMax];
// 			}
// 			else
// 			{
// 
// 			}
// 
// 			switch( msg->eConType )
// 			{
// 			case EICT_KungfuBag:
// 				pCmd1->by_type = 2;
// 				m_reoderGongFaItem=true;//记录下是否需要排序，服务器没法处理，只好用全局变量记录
// 				break;
// 			case EICT_KungfuTemp:
// 				pCmd1->by_type = 3;
// 				m_reoderGongFaItem=true;
// 				break;
// 			case EICT_RoleWare:
// 				pCmd1->by_type = 4;
// 				break;
// 			}
// 
// 			int nMaxSize = itemMap->size()*sizeof(short);
// 			if(nSize >= nMaxSize)
// 			{
// 				NET_SIC_item_reorder* pCmd2 = (NET_SIC_item_reorder*)pMsg;
// 				pCmd2->id = message_id_crc("NET_SIC_item_reorder");
// 				
// 				nPos = 0;
// 				if()
// 				make_msg_pack(pCmd2->n16Index,nPos,);
// 			}
// 			else
// 			{
// 				pCmd1->size = sizeof(NET_SIC_item_reorder_extend) + nSize - sizeof(unsigned char);
// // 				//给功法临时背包加个整理 add by XSea 2014.09.20
// // 				pCmd1->by_type = 0; //默认为0 背包
// // 				switch( msg->eConType )
// // 				{
// // 				case EICT_KungfuBag:
// // 					pCmd1->by_type = 2;
// // 					m_reoderGongFaItem=true;
// // 					break;
// // 				case EICT_KungfuTemp:
// // 					pCmd1->by_type = 3;
// // 					m_reoderGongFaItem=true;
// // 					break;
// // 				case EICT_RoleWare:
// // 					pCmd1->by_type = 4;
// // 					break;
// // 				}
// 
// 				//pCmd1->by_type = msg->eConType == EICT_KungfuBag ? 2 : 0;
// 
// 				TCP_CLIENT->send_net_cmd(pCmd1, NP_NORMAL, false);
// 			}
// 
// 
// 			if (msg->eConType  == EICT_KungfuBag)
// 			{
// 				//根据锁定和非锁定的分别处理
// 				std::map<INT64, f_item*> bind_item_sort_result_map;
// 				std::map<INT64, f_item*> unbind_item_sort_result_map;
// 				std::vector<f_item*> need_sort;
// 				get_item_list(itemMap,true,need_sort);
// 				sort_items(need_sort,bind_item_sort_result_map);
// 
// 				need_sort.clear();
// 				get_item_list(itemMap,false,need_sort);
// 				sort_items(need_sort,unbind_item_sort_result_map);
// 
// 				make_msg_pack_ex(bind_item_sort_result_map,nSize,nPos);
// 				make_msg_pack_ex(unbind_item_sort_result_map,nSize,nPos);
// 			}
// 			else
// 			{
// 				// 锁定所有物品,并计算物品的权重
// 				std::map<INT64, f_item*> tmpMap;
// 				for(ItemMap::iterator iter = itemMap->begin(); iter != itemMap->end(); ++ iter)
// 				{
// 					f_item *item = iter->second;
// 					//item->set_operable(false);
// 					tmpMap[CalcItemWeight(item)] = item;
// 				}
// 
// 				//int nMax = itemMap->size()*sizeof(tagItemOrder) + sizeof(NET_SIC_item_reorder_extend);
// 				//unsigned char* pMsg = new unsigned char[nMax];
// 				// 发送网络消息
// 				f_item *pItem = NULL;
// 
// 				for(std::map<INT64, f_item*>::iterator iter = tmpMap.begin(); iter != tmpMap.end(); ++ iter)
// 				{
// 					pItem = iter->second;
// 					if(pItem->get_pos() != nPos)
// 					{
// 						tagItemOrder m;			
// 						m.n16OldIndex = pItem->get_pos();
// 						m.n16NewIndex = nPos;
// 						memcpy(pCmd1->byData+nSize, &m, sizeof(tagItemOrder));
// 						pCmd1->n16ItemNum++;
// 						nSize += sizeof(tagItemOrder);
// 					}
// 					nPos++;
// 				}
// 
// 				if(nSize <= 0)// 如果没有数据则不发送排序消息
// 				{
// 
// 					unLockItem(msg->eConType);
// 
// 					delete []pMsg;
// 					if(msg->eConType==EICT_KungfuBag||msg->eConType==EICT_KungfuTemp)
// 					{
// 						GambleMgr::getInstance()->showOneKeyLevelUpEffect();//功法背包,不需要排序直接显示升级特效
// 					}
// 					return 0;
// 				}
// 
// 				// 如果可变序列所占长度超出总体序列，则直接发送整体序列
// 				int nMaxSize = itemMap->size()*sizeof(short);
// 				if(nSize >= nMaxSize)
// 				{
// 					NET_SIC_item_reorder* pCmd2 = (NET_SIC_item_reorder*)pMsg;
// 					pCmd2->id = message_id_crc("NET_SIC_item_reorder");
// 					if(msg->eConType == EICT_RoleWare)
// 						pCmd2->dwNPCID = StoreMgr::getInstance()->getNpcServerId();
// 					else
// 						pCmd2->dwNPCID = (unsigned int)-1;
// 					//给功法临时背包加个整理 add by XSea 2014.09.20
// 					pCmd2->by_type = 0; //默认为0 背包
// 					switch( msg->eConType )
// 					{
// 					case EICT_KungfuBag:
// 						pCmd2->by_type = 2;
// 						m_reoderGongFaItem=true;//记录下是否需要排序，服务器没法处理，只好用全局变量记录
// 						break;
// 					case EICT_KungfuTemp:
// 						pCmd2->by_type = 3;
// 						m_reoderGongFaItem=true;
// 						break;
// 					case EICT_RoleWare:
// 						pCmd2->by_type = 4;
// 						break;
// 					}
// 					//pCmd2->by_type = msg->eConType == EICT_KungfuBag ? 2 : 0;
// 					pCmd2->n16ItemNum = itemMap->size();
// 					nSize = 0;
// 					for(std::map<INT64, f_item*>::iterator iter = tmpMap.begin(); iter != tmpMap.end(); ++ iter)
// 					{
// 						pItem = iter->second;
// 						short n16Pos= pItem->get_pos();
// 						memcpy(((unsigned char*)pCmd2->n16Index)+nSize, &n16Pos, sizeof(short));
// 						nSize += sizeof(short); 
// 					}
// 
// 					pCmd2->size = sizeof(NET_SIC_item_reorder) + nSize - sizeof(short);
// 					TCP_CLIENT->send_net_cmd(pCmd2, NP_NORMAL, false);
// 				}
// 				else
// 				{
// 
// 					pCmd1->size = sizeof(NET_SIC_item_reorder_extend) + nSize - sizeof(unsigned char);
// 					//给功法临时背包加个整理 add by XSea 2014.09.20
// 					pCmd1->by_type = 0; //默认为0 背包
// 					switch( msg->eConType )
// 					{
// 					case EICT_KungfuBag:
// 						pCmd1->by_type = 2;
// 						m_reoderGongFaItem=true;
// 						break;
// 					case EICT_KungfuTemp:
// 						pCmd1->by_type = 3;
// 						m_reoderGongFaItem=true;
// 						break;
// 					case EICT_RoleWare:
// 						pCmd1->by_type = 4;
// 						break;
// 					}
// 
// 					//pCmd1->by_type = msg->eConType == EICT_KungfuBag ? 2 : 0;
// 
// 					TCP_CLIENT->send_net_cmd(pCmd1, NP_NORMAL, false);
// 				}
// 
// 				
// 			}
// 			delete []pMsg;
		}
		else			// 整理出错或数据出错，此时背包类型可能传递的是错误的值，直接用_CurrentLockedConType解锁
		{
			unLockItem(_CurrentLockedConType);
		}
	//}

	return 0;
}

unsigned int PackageManager::onReorderItem( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_item_reorder"))
	{
		NET_SIS_item_reorder *msg = (NET_SIS_item_reorder*)cmd;
		ItemMap *itemMap = getItemMap(msg->eConType);
		if(itemMap != NULL)
		{
			unLockItem(msg->eConType);

			if(E_Success == msg->dw_error_code)
			{
				ItemMap tempMap;
				int pos = 0;
				for(int i=0; i<msg->n16ItemNum; ++i)
				{
					short n16OldPos;
					memcpy(&n16OldPos, msg->n16OldIndex+pos, sizeof(short));
					f_item* pItem = getItem(*itemMap, n16OldPos);
					itemMap->erase(n16OldPos);
					if(pItem != NULL)
					{
						pItem->set_pos(pos);
						tempMap[n16OldPos] = pItem;
					}
					pos++;
				}

				f_item* pTemp = NULL;
				//short n16Pos = 0;
				for(ItemMap::iterator iter = tempMap.begin(); iter != tempMap.end(); ++ iter)
				{
					pTemp = iter->second;
					(*itemMap)[pTemp->get_pos()] = pTemp;
				}

				if(msg->eConType == EICT_KungfuBag)
				{
					GET_UI(WuXueUi, WCT_WUXUEUI)->updateMartialData();
					if(m_reoderGongFaItem)
					{
						m_reoderGongFaItem=false;
						GambleMgr::getInstance()->showOneKeyLevelUpEffect();
					}
				}
				else if( msg->eConType == EICT_KungfuTemp )
				{
					GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();
					if(m_reoderGongFaItem)
					{
						m_reoderGongFaItem=false;
						GambleMgr::getInstance()->showOneKeyLevelUpEffect();
					}

				}
				else
				{
					GET_UI(Package, WCT_PACKAGEUI)->updateData();
					GET_UI(Storage, WCT_StorageUi)->updateData();
				}
			}
		}
		else			// 排序出错或数据出错，此时背包类型可能传递的是错误的值，直接用_CurrentLockedConType解锁
		{
			unLockItem(_CurrentLockedConType);
		}
	}
	return 0;
}

unsigned int PackageManager::onReorderItemEx( s_net_cmd *cmd )
{
	//if(cmd->id == message_id_crc("NET_SIS_item_reorder_extend"))
	{
		NET_SIS_item_reorder_extend *msg = (NET_SIS_item_reorder_extend*)cmd;
		if(E_Success == msg->dw_error_code)
		{
			ItemMap *itemMap = getItemMap(msg->eConType);
			if(itemMap != NULL)
			{
				ItemMap tempMap;
				int pos = 0;
				for(int i=0; i<msg->n16ItemNum; ++i)
				{
					tagItemOrder& m = msg->byData[i];
					//memcpy(&m, msg->byData+pos, sizeof(tagItemOrder));
					f_item* pItem = getItem(*itemMap, m.n16OldIndex);
					itemMap->erase(m.n16OldIndex);
					if(pItem != NULL)
					{
						pItem->set_pos(m.n16NewIndex);
						tempMap[m.n16OldIndex] = pItem;
					}

					pos += sizeof(tagItemOrder);
				}

				f_item* pTemp = NULL;
				//short n16Pos = 0;
				for(ItemMap::iterator iter = tempMap.begin(); iter != tempMap.end(); ++ iter)
				{
					pTemp = iter->second;
					(*itemMap)[pTemp->get_pos()] = pTemp;
				}

				if(msg->eConType == EICT_KungfuBag)
				{
					GET_UI(WuXueUi, WCT_WUXUEUI)->updateMartialData();
				}
				else if( msg->eConType == EICT_KungfuTemp )
				{
					GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();
				}
				else
				{
					GET_UI(Package, WCT_PACKAGEUI)->updateData();
					GET_UI(Storage, WCT_StorageUi)->updateData();
				}
			}

			unLockItem(msg->eConType);
		}
		else			// 排序出错或数据出错，此时背包类型可能传递的是错误的值，直接用_CurrentLockedConType解锁
		{
			unLockItem(_CurrentLockedConType);
		}

	}

	return 0;
}

unsigned int PackageManager::onInitStateMoney( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_get_role_init_state_money"))
	{
		NET_SIS_get_role_init_state_money *msg = (NET_SIS_get_role_init_state_money*)cmd;
		_yuanBao = msg->nBaiBaoYuanBao;
		_diamond = msg->nBagDiamond;
		_jinBi = msg->n64BagSilver;

		GET_UI(Package, WCT_PACKAGEUI)->updateJinqian();
		GET_UI(StoreUi, WCT_STOREUI)->updateMoney();
		GET_UI(StoreUi,WCT_STOREUI)->updateDiamond();
		GET_UI(MountUi, WCT_MountUi)->updateData();
		GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateMoney();
	}
	return 0;
}

unsigned int PackageManager::onMoneyChange( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_bag_silver"))
	{
		NET_SIS_bag_silver *msg = (NET_SIS_bag_silver*)cmd;

		//为了屏蔽服务器可能发来的绑定金币的消耗消息
		if (1 == msg->bBind)
			return 0;
		_jinBi = msg->n64CurSilver;
		if (_jinBi >= MAX_PACKAGE_JINGBI)
		{
			ToolTip::getInstance()->push("\xE6\x82\xA8\xE6\x89\x80\xE6\x90\xBA\xE5\xB8\xA6\xE7\x9A\x84\xE9\x87\x91\xE5\xB8\x81\xE5\xB7\xB2\xE8\xBE\xBE\xE4\xB8\x8A\xE9\x99\x90\xEF\xBC\x8C\xE5\xB0\x86\xE4\xB8\x8D\xE5\x86\x8D\xE5\xA2\x9E\xE5\x8A\xA0");
		}
		GET_UI(Package, WCT_PACKAGEUI)->updateJinqian();
		GET_UI(MountUi, WCT_MountUi)->updateData();
		GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateMoney();
		//给提示
		if (msg->n64ChangeSilver > 0)//获得金币
		{
			s_receive_chat_info info;
			info.send_channel = ESCC_System;
			std::stringstream ss;
			ss<<msg->n64ChangeSilver;
			std::string str = replaceStr(GET_STR(2034),"**",ss.str());
			info.chat_text = str;
			ChatMgr::getInstance()->ShowInfoByChatChannel(info);
			AudioPlayer::getSigletonPtr()->playerSoundUIEffect(GOLD);
		}
		else if(msg->n64ChangeSilver < 0)//失去金币
		{
			s_receive_chat_info info;
			info.send_channel = ESCC_System;
			std::stringstream ss;
			ss<<-(msg->n64ChangeSilver);
			std::string str = replaceStr(GET_STR(2035),"**",ss.str());
			info.chat_text = str;
			ChatMgr::getInstance()->ShowInfoByChatChannel(info);
		}
		else
		{
			//do nothing
		}
	}
	return 0;
}
void PackageManager::RemoveFirstOfMysteryShopList()  
{ 
	if(MySteryShopList.size()==0)
	{
		return;
	}
	MySteryShopList.erase(MySteryShopList.begin());

}
void PackageManager::RemoveFirstOfMysteryShopList1()  
{ 
	if(MySteryShopList1.size()==0)
	{
		return;
	}
	MySteryShopList1.erase(MySteryShopList1.begin());

}
void PackageManager::RemoveFirstOfMysteryList()  
{ 
	if(MySteryBoxList.size()==0)
	{
		return;
	}
	MySteryBoxList.erase(MySteryBoxList.begin());

}
unsigned int PackageManager::onBaibaoYuanbaoChange(s_net_cmd *cmd)
{
	NET_SIS_baibao_yuanbao* msg = (NET_SIS_baibao_yuanbao*)cmd;
	_yuanBao = msg->nCurYuanBao;

	GET_UI(Package, WCT_PACKAGEUI)->updateJinqian();
	GET_UI(StoreUi, WCT_STOREUI)->updateMoney();
	GET_UI(StoreUi,WCT_STOREUI)->updateDiamond();
	GET_UI(MountUi, WCT_MountUi)->updateData();
	GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateMoney();
	//若是增加元宝，则给提示
	if (msg->nChangeYuanBao > 0 && msg->dw_cmd_id != 22)//22摇钱树
	{	//获得元宝
		s_receive_chat_info info;
		info.send_channel = ESCC_System;
		std::stringstream ss;
		ss<<msg->nChangeYuanBao;
		std::string str = replaceStr(GET_STR(2032),"**",ss.str());
		info.chat_text = str;
		ChatMgr::getInstance()->ShowInfoByChatChannel(info);
		//ToolTip::getInstance()->push(str); //获得元宝飘绿字显示 //add by XSea 2014.12.08
		ToolTip::getInstance()->pushMessage(ss.str(),"\xE8\x8E\xB7\xE5\xBE\x97",2,3);
		//首冲
		if (msg->dw_cmd_id == 1721)
		{
			ToolTip::getInstance()->push(GET_STR(9430));
		}

#ifdef _USE_SDK
		if (msg->bBillYuanbao)
		{
			WzolJni *jni = WzolJni::getInstance();
			jni->postPaySuccessLog(msg->nChangeYuanBao / 10);
		}
#endif
	}
	else if(msg->nChangeYuanBao < 0)//失去元宝
	{
		//先注掉，需要时再放开 add by XSea 2014.10.21
		/*s_receive_chat_info info;
		info.send_channel = ESCC_System;
		std::stringstream ss;
		ss<<-(msg->nChangeYuanBao);
		std::string str = replaceStr(GET_STR(2371),"**",ss.str());
		info.chat_text = str;
		ChatMgr::getInstance()->ShowInfoByChatChannel(info);*/
	}
	//判断是否是充值增加的
	// 	if (msg->bBillYuanbao && msg->nChangeYuanBao > 0)//防止异常
	// 	{
	// 		_totalChargeYuanBao += msg->nChangeYuanBao;
	// 	}

	TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
	if(NULL != ui && IS_UI_OPEN(WCT_TradingUI))
		ui->UpdateCommonYuanBao();

	return 0;
}

unsigned int PackageManager::onDiamondChanged( s_net_cmd *cmd )
{
	NET_SIS_bag_yuanbao *msg = (NET_SIS_bag_yuanbao*)cmd;
	_diamond = msg->nCurYuanBao;
	GET_UI(Package, WCT_PACKAGEUI)->updateJinqian();
	GET_UI(StoreUi, WCT_STOREUI)->updateMoney();
	GET_UI(StoreUi,WCT_STOREUI)->updateDiamond();
	GET_UI(MountUi, WCT_MountUi)->updateData();
	GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateMoney();
	//若是增加钻石，则给提示
	if (msg->nChangeYuanBao > 0)
	{
		s_receive_chat_info info;
		info.send_channel = ESCC_System;
		std::stringstream ss;
		ss<<msg->nChangeYuanBao;
		std::string str = replaceStr(GET_STR(2033),"**",ss.str());
		info.chat_text = str;
		ChatMgr::getInstance()->ShowInfoByChatChannel(info);
		//ToolTip::getInstance()->push(str); //获得钻石飘绿字显示 //add by XSea 2014.12.25
		if (!FubenMgr::GetInstance().getIsOneSaodang() && !FubenMgr::GetInstance().getIsTenSaodang())
		{
			ToolTip::getInstance()->pushMessage(ss.str(),"\xE8\x8E\xB7\xE5\xBE\x97",2,2);
		}
	}
	else if(msg->nChangeYuanBao < 0)
	{
		s_receive_chat_info info;
		info.send_channel = ESCC_System;
		std::stringstream ss;
		ss<<-(msg->nChangeYuanBao);
		std::string str = replaceStr(GET_STR(2372),"**",ss.str());
		info.chat_text = str;
		ChatMgr::getInstance()->ShowInfoByChatChannel(info);
	}
	return 0;
}

void PackageManager::useBagItem( short index )//使用背包物品
{
	f_item *item = getItem(_pocket, index);	
	if (item && item->get_item_type_id() == 1102012)
	{
		WanMeiGiftUiMgr::GetInstance()->SetItemId(item->get_item_id());
		WanMeiGiftUiMgr::GetInstance()->openWanMeiGiftUi();
		return;
	}


	useBagItem(item);
}

void PackageManager::useBagItem( INT64 id )//使用背包物品  id
{
	f_item *item = getItem(_pocket, id);		//通过id在背包找到物品
	useBagItem(item);
}

int PackageManager::getspecial_value_1(INT64 id)
{
	f_item *item = getItem(_pocket, id);		//通过id在背包找到物品
	if(NULL == item)
		return 0;

	ItemTypeData typeData = getItemTypeData(item->get_item_type_id());//gx add
	return typeData.special_value_1;
}

void PackageManager::useBagItem( f_item *item )//使用背包物品  
{
	if(item == NULL)
		return;


	const ItemTypeData &typeData = getItemTypeData(item->get_item_type_id());//gx add
	ePackageItemType eItemType = typeData.type;
	//ePackageItemType eItemType = getItemTypeData(item->get_item_type_id()).type;
	if ( PIT_BagExtand == eItemType)
	{
		//extendPackage(item->get_item_id(), 0);
	}
	else if(PIT_Mystery == eItemType)
	{

		OPEN_UI(WCT_MysteryBoxUi);
		f_item* AnotherBoxItem = NULL;
		if(item->get_item_bind_status())
		{
			AnotherBoxItem =PackageManager::getInstance()->getUnBindItem(EICT_Bag,1102255);
		}
		else
		{
			AnotherBoxItem =PackageManager::getInstance()->getBindItem(EICT_Bag,1102255);
		}
		if(AnotherBoxItem != NULL)
		{
			GET_UI(MysteryBoxUi,WCT_MysteryBoxUi)->SetCurentBindBoxId(AnotherBoxItem->get_item_id());
		}
		GET_UI(MysteryBoxUi,WCT_MysteryBoxUi)->SetCurentBoxId(item->get_item_id());
		GET_UI(MysteryBoxUi,WCT_MysteryBoxUi)->SetIsYuanBox(false);
		return;
	}
	else if(PIT_MysteryYuanBao == eItemType)
	{
		OPEN_UI(WCT_MysteryBoxUi);
		f_item* AnotherBoxItem = NULL;
		if(item->get_item_bind_status())
		{
			AnotherBoxItem =PackageManager::getInstance()->getUnBindItem(EICT_Bag,1102256);
		}
		else
		{
			AnotherBoxItem =PackageManager::getInstance()->getBindItem(EICT_Bag,1102256);
		}
		if(AnotherBoxItem != NULL)
		{
			GET_UI(MysteryBoxUi,WCT_MysteryBoxUi)->SetCurentBindBoxId(AnotherBoxItem->get_item_id());
		}
		GET_UI(MysteryBoxUi,WCT_MysteryBoxUi)->SetCurentBoxId(item->get_item_id());
		GET_UI(MysteryBoxUi,WCT_MysteryBoxUi)->SetIsYuanBox(true);
		return;
	}
	else if(PIT_SKILLBOOK == eItemType)
	{
		//技能书先获得技能大ID
		NET_SIC_learn_skill msg;
		msg.dwSkillID = typeData.special_value_1;//gx moidfy
		msg.n64ItemID = item->get_item_id();
		msg.dwNPCID = INVALID;
		TCP_CLIENT->send_net_cmd(&msg, NP_NORMAL, false);
	}
	else if(PIT_LuckYou == eItemType) //使用祝福油
	{
		use_one_oil(item->get_item_id());
	}
	else if(PIT_Repair == eItemType)//使用修复神水
	{
		NET_SIC_abrase_stone msg;
		msg.n64AbraserSerial = item->get_item_id();
		TCP_CLIENT->send_net_cmd(&msg, NP_IDLE, false);
	}
	else if (PIT_ChangeName == eItemType)//改名卡使用
	{
		//打开改名卡UI
		InputSerialUi::getInstace()->open();
		InputSerialUi::getInstace()->setChangeName(1);
		InputSerialUi::getInstace()->setTitle(STRING_TABLE["Role_newName"]);
	}
	else if (pIT_ChangeGuildName == eItemType)//行会改名卡使用
	{
		InputSerialUi::getInstace()->open();
		InputSerialUi::getInstace()->setChangeName(2);
		InputSerialUi::getInstace()->setTitle(STRING_TABLE["Guild_newName"]);
	}
	else if (PIT_Kungfu == eItemType || eItemType == PIT_KungfuExp)
	{
		//do nothing
	}
	else if (PIT_Box == eItemType)//宝箱
	{
		//		openKenXiang(item);				//【Ji：】
	}
	else if (PIT_Box_ForSure == eItemType)//确定类宝箱
	{
		//		OpenBoxForSure(item);			//【Ji：】
	}
	else
	{
		if (PIT_SuiJiShi == eItemType)
		{
			AudioPlayer::getSigletonPtr()->playerSoundSceneEffect(SCENE_CHUANSONG);
		}
		else if (PIT_LiHua == eItemType)
		{
			unsigned int LiHuaEffect = AudioPlayer::getSigletonPtr()->playerSoundSceneEffect(SCENE_FIREWORKS,true);
			AudioPlayer::getSigletonPtr()->setNoStopAudio(LiHuaEffect);
		}
		if(_canUseItem)
		{
			NET_SIC_use_item cmd;
			LocalPlayer *role = RoleManager::getInstance()->getLocalPlayer();
			CCPoint pos = role->getPosition();
			cmd.vSrcPos[0] = pos.x;
			cmd.vSrcPos[2] = pos.y;
			cmd.dwTargetRoleID = role->getId();
			cmd.n64ItemID = item->get_item_id();
			cmd.byUseType = 0;
			TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);

			_canUseItem = false;
		}
	}
	//改为通用,不需要在这里关闭界面
	// 	if (ItemAutoUseDaojuTip::getInstace()->isOpen())
	// 	{
	// 		if (item->get_item_id() == (ItemAutoUseDaojuTip::getInstace()->getMapFront()->item->get_item_id()))
	// 		{
	// 			ItemAutoUseDaojuTip::getInstace()->close();
	// 		}
	// 	}
}

bool PackageManager::use_one_oil(INT64 id)
{
	//首先判断是否装备了武器
	PackageManager::ItemMap *itemMap = PackageManager::getInstance()->getItemMap(EICT_Equip);
	f_item *pItemWepon = PackageManager::getInstance()->getItem(*itemMap, (short)EEP_RightHand);
	if (!pItemWepon)
	{
		ToolTip::getInstance()->push(GET_STR(2122));
		return false;
	}
	f_equipment *pEquip = dynamic_cast<f_equipment*>(pItemWepon);
	if (!pEquip)
		return false;

	if (pEquip->m_equipex.byLuck >= 7)
	{
		ToolTip::getInstance()->push(GET_STR(2123));
		return false;
	}

	NET_SIC_use_luck_you msg;
	msg.n64Item = id;
	msg.byType = 0; //单个使用
	TCP_CLIENT->send_net_cmd(&msg, NP_CRITICAL, false);

	return true;
}

unsigned int PackageManager::onItemRemove( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_item_remove"))
	{
		NET_SIS_item_remove *msg = (NET_SIS_item_remove*)cmd;

		if (getUiNodeByTag<kuaijieshiyongUiLayer>(WCT_ItemAutoUseDaojuTip))
			getUiNodeByTag<kuaijieshiyongUiLayer>(WCT_ItemAutoUseDaojuTip)->onUseItem( msg->n64_serial );

		ItemMap* pItemCon = getItemMap(msg->eConType);
		if(pItemCon != NULL)
		{
			f_item* pItem = getItem(*pItemCon ,msg->n16Index);
			if(pItem == NULL)
			{
				return NULL;
			}
			unsigned int dw_data_id = pItem->get_item_type_id();
			if(pItem != NULL && msg->n64_serial == pItem->get_item_id())
			{
				//int nQuantity = pItem->get_item_number() - msg->n16Num;

				if(msg->n16Num > 0)
				{
					//如果是可多次使用的物品，n16Num是可使用的次数
					const ItemTypeData &typeData = getItemTypeData(dw_data_id);
					if(typeData.useTime > 1)
					{
						pItem->set_item_use_times(msg->n16Num);
						//nQuantity = 0;
					}
					else
					{
						pItem->set_item_number(msg->n16Num);
					}

					checkFusionItemUpdateifNess(pItem);
					checkSBKEquipUpdateIfNess(pItem);

					item_num_change evt;
					evt.item_type_id = pItem->get_item_type_id();
					SEND_EVENT(&evt);
				}
				else
				{
					removeItem(*pItemCon, pItem->get_pos());
				}

				onPackageItemChanged(dw_data_id, false);
			}

			if(msg->eConType == EICT_Bag)
			{
				unLockItem(m_bindingItemData.eConType,m_bindingItemData.src);
				unLockItem(m_bindingItemData.destEConType,m_bindingItemData.dest);
				GET_UI(Package, WCT_PACKAGEUI)->updateData();
				GET_UI(ShortCutUi, WCT_ShorCutUi)->updateUsedItem();
				EquipTipUiLayer* pNode = (EquipTipUiLayer*)World::getInstance()->getScene()->getChildByTag(WCT_EQUIP_TIPS_UI_TAG);
				if(pNode)
					pNode->close();
				InstanceMgr::getInstance()->onChangeTLItemNums(dw_data_id);//在天牢副本中获得道具需要改变界面显示
			}
			else if(msg->eConType == EICT_KungfuBag)
			{
				GET_UI(WuXueUi,WCT_WUXUEUI)->updateMartialData();
				GET_UI(WuXueUi,WCT_WUXUEUI)->updateEquip();
			}
			else if(msg->eConType == EICT_KungfuTemp)
			{
				GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp(msg->n16Index);
			}
			else if(msg->eConType == EICT_StallItem)
			{
				GET_UI(NewStallUi, WCT_NEW_STALLUI)->DelStallItem(msg->n16Index, false);
			}
			else if(msg->eConType == EICT_RoleWare)
			{
				unLockItem(m_bindingItemData.eConType,m_bindingItemData.src);
				unLockItem(m_bindingItemData.destEConType,m_bindingItemData.dest);
				//更新ui
				updateUiWithConType(EICT_RoleWare);
				//updateUiWithConTypeEx(msg->eConTypeDst2, msg->n16PosDst2);
			}
			INT64 nTempBoxId = 0;
			INT64 nTempBindBoxId = 0;
			MysteryBoxUi* ui = GET_UI(MysteryBoxUi, WCT_MysteryBoxUi);
			if(ui != NULL)
			{
				nTempBoxId = ui->GetCurentBoxId();
				nTempBindBoxId = ui->GetCurentBindBoxId();
				if(msg->n64_serial == nTempBoxId || msg->n64_serial == nTempBindBoxId )
				{
					ui->InitFrame();
				}
			}

		}
	}

	return 0;
}

unsigned int PackageManager::onItemPutDown( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_role_putdown_item"))
	{
		NET_SIS_role_putdown_item *msg = (NET_SIS_role_putdown_item*)cmd;
		if(msg->id != E_Success)
		{
			unLockItem(EICT_Bag, msg->n64_serial);
			unLockItem(EICT_KungfuBag, msg->n64_serial);
		}
	}
	return 0;
}

void PackageManager::putDownBagItem( short index )
{
	

	ItemMap *itemMap = getItemMap(EICT_Bag);
	CC_ASSERT(itemMap != NULL);
	f_item *item = getItem(*itemMap, index);
	if(item != NULL)
	{
		ItemTypeData data = PackageManager::getInstance()->getItemTypeData(item->get_item_type_id());
		const EquipTypeData* equipTypeData = PackageManager::getInstance()->getEquipTypeData(item->get_item_type_id());
		if (PIT_Equip == data.type && equipTypeData && equipTypeData->explodeId != -1)
		{
			
			std::function<void(bool)> func = [item,index](bool isSuccess){
				if (isSuccess)
				{
					PackageManager::getInstance()->lockItem(EICT_Bag, index);
					NET_SIC_Decompose_begin send;
					send.decomposeid[0] = item->get_item_id();
					TCP_CLIENT->send_net_cmd(&send, NP_NORMAL, false);
				}
			};
			SecondVerifyMgr::getInstance()->try_request_safe_verify(func);
		}
		else
		{
			std::function<void(bool)> func = [item,index](bool isSuccess){
				if (isSuccess)
				{
					PackageManager::getInstance()->lockItem(EICT_Bag, index);
					NET_SIC_role_putdown_item msg;
					msg.by_type = 0;
					msg.n64_serial = item->get_item_id();
					TCP_CLIENT->send_net_cmd(&msg, NP_NORMAL, false);
				}
			};
			SecondVerifyMgr::getInstance()->try_request_safe_verify(func);
		}	
	}
}

void PackageManager::DropGongfaItem(short index)
{
	lockItem(EICT_Bag, index);

	ItemMap *itemMap = getItemMap(EICT_KungfuBag);
	CC_ASSERT(itemMap != NULL);
	f_item *item = getItem(*itemMap, index);
	
	if(item != NULL)
	{
		NET_SIC_role_putdown_item msg;
		msg.by_type = 2;
		msg.n64_serial = item->get_item_id();
		ItemTypeData data = getItemTypeData(item->get_item_type_id());
		if (data.byQuality < 3 || data.type == PIT_KungfuExp)//紫色
		{
			TCP_CLIENT->send_net_cmd(&msg, NP_NORMAL, false);
		}
		else
		{
			std::function<void(bool)> func = [msg](bool isSuccess){
				if (isSuccess)
				{
					TCP_CLIENT->send_net_cmd(&msg, NP_NORMAL, false);
				}
			};
			SecondVerifyMgr::getInstance()->try_request_safe_verify(func);
		}
	}
}

const ItemTypeData & PackageManager::getItemTypeData( unsigned int typeId )
{
	ItemData::iterator iter = _itemData.find(typeId);
	if(iter != _itemData.end())
	{
		const ItemTypeData &data = iter->second;
		return data;
	}
	else{
		return ItemTypeData::INVALID_TYPE_DATA;
	}
}

const EquipTypeData* PackageManager::getEquipTypeDataPointer( unsigned int typeId )
{
	EquipTypeData* pdata = NULL;
	EquipData::iterator iter = _equipData.find(typeId);
	if(iter != _equipData.end())
	{
		pdata = &iter->second;
	}
	return pdata;
}

const EquipTypeData* PackageManager::getEquipTypeData( unsigned int typeId )const
{
	auto iter = _equipData.find(typeId);
	//CC_ASSERT(iter != _equipData.end());
	if (iter == _equipData.end())
	{
		//CC_ASSERT(false);
		return NULL;
	}
	//const EquipTypeData &data = iter->second;
	return &iter->second;

// 	EquipTypeData equipData;
// 修改完成 	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM EquipData WHERE typeId = ?1");
// 	cmd->set_integer32(1 , typeId);
// 	c_sql_table* table = c_db_manager::getSingleton()->create_table();
// 	while(table->retrieve_row())
// 	{
// 		unsigned int idx = table->get_index("levelUpId");
// 		equipData.levelUpId = table->get_integer32(idx);
// 		for(int i=0;i<LEVEL_UP_MATERIAL_NUMBER;++i){
// 			CCString* id=CCString::createWithFormat("%s%d%s","stuff",i+1,"Id");
// 			CCString* num=CCString::createWithFormat("%s%d%s","stuff",i+1,"Num");
// 			idx=table->get_index(id->getCString());
// 			equipData.stuffId[i]=table->get_integer32(idx);
// 			idx=table->get_index(num->getCString());
// 			equipData.stuffNum[i]=table->get_integer32(idx);
// 		}
// 		idx = table->get_index("Name");
// 		equipData.name = table->get_text(idx);
// 		idx = table->get_index("Profession");
// 		equipData.profession = table->get_text(idx);
// 		idx = table->get_index("Level");
// 		equipData.level = table->get_integer32(idx);
// 
// 		idx = table->get_index("jewel_limit");
// 		equipData.jewel_limit = table->get_integer32(idx);
// 
// 		idx = table->get_index("Durability");
// 		equipData.durability = table->get_integer32(idx);
// 		idx = table->get_index("Pos");
// 		equipData.pos = table->get_text(idx);
// 		idx = table->get_index("PosIndex");
// 		equipData.posIndex = (EEquipPos)table->get_integer32(idx);
// 		idx = table->get_index("Sex");
// 		equipData.bySex = table->get_integer32(idx);
// 		idx = table->get_index("Luck");
// 		equipData.luck = table->get_integer32(idx);
// 		idx = table->get_index("Desc");
// 		equipData.equipDesc = table->get_text(idx);
// 		idx = table->get_index("quality");
// 		equipData.equipQuality = (EItemQuality)(table->get_integer32(idx));
// 		idx = table->get_index("explodeId");
// 		equipData.explodeId = table->get_integer32(idx);
// 		idx = table->get_index("Profession2");
// 		equipData.profession2 = table->get_integer32(idx);
// 		for(int i=0;i<LEVEL_NAME;++i){
// 			CCString* id=CCString::createWithFormat("%s%d","starName",(i+1));
// 			idx=table->get_index(id->getCString());
// 			equipData.LevelName[i]=table->get_text(idx);
// 		}
// 		idx = table->get_index("gemHole");
// 		equipData.gemHole = table->get_integer32(idx);
// 		idx = table->get_index("isautoExplode");
// 		equipData.isAutoExplode = table->get_integer32(idx);
// 		idx = table->get_index("use_level_min");
// 		equipData.minUseLevel = table->get_integer32(idx);
// 		idx = table->get_index("use_level_max");
// 		equipData.maxUseLevel = table->get_integer32(idx);
// 		idx = table->get_index("showTest");
// 		equipData.showTest = table->get_integer32(idx);
// 		idx = table->get_index("equipSign");
// 		equipData.equipSign = table->get_integer32(idx);
// 		idx = table->get_index("suitId");
// 		equipData.suit_id = table->get_integer32(idx);
// 	}
// 	c_db_manager::getSingleton()->destroy_table(table);
// 	c_db_manager::getSingleton()->end_operation(cmd);
// 
// 	_equipData[typeId] = equipData;
// 	return _equipData[typeId];
}

EquipBaseAttr PackageManager::getEquipBaseAttrDB( unsigned int typeId )
{
	EquipBaseAttr equipAttr;
	EquipAttData::iterator iter = _equipAttData.find(typeId);
	if (iter != _equipAttData.end())
	{
		equipAttr = iter->second;
	}
	return equipAttr;
//修改完成 	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM EquipData WHERE typeId = ?1");
// 	cmd->set_integer32(1 , typeId);
// 	c_sql_table* table = c_db_manager::getSingleton()->create_table();
// 	while(table->retrieve_row())
// 	{
// 		unsigned int idx = table->get_index("ZAtcMin");
// 		equipAttr.data[EquipBaseAttr::EBA_ZAtcMin] = table->get_integer32(idx);
// 		idx = table->get_index("ZActMax");
// 		equipAttr.data[EquipBaseAttr::EBA_ZAtcMax] = table->get_integer32(idx);
// 		idx = table->get_index("FAtcMin");
// 		equipAttr.data[EquipBaseAttr::EBA_FAtcMin] = table->get_integer32(idx);
// 		idx = table->get_index("FAtcMax");
// 		equipAttr.data[EquipBaseAttr::EBA_FAtcMax] = table->get_integer32(idx);
// 		idx = table->get_index("DAtcMin");
// 		equipAttr.data[EquipBaseAttr::EBA_DAtcMin] = table->get_integer32(idx);
// 		idx = table->get_index("DAtcMiax");
// 		equipAttr.data[EquipBaseAttr::EBA_DAtcMax] = table->get_integer32(idx);
// 		idx = table->get_index("WFangMax");
// 		equipAttr.data[EquipBaseAttr::EBA_WFangMax] = table->get_integer32(idx);
// 		idx = table->get_index("WFangMin");
// 		equipAttr.data[EquipBaseAttr::EBA_WFangMin] = table->get_integer32(idx);
// 		idx = table->get_index("MFangMax");
// 		equipAttr.data[EquipBaseAttr::EBA_MFangMax] = table->get_integer32(idx);
// 		idx = table->get_index("MFangMin");
// 		equipAttr.data[EquipBaseAttr::EBA_MFangMin] = table->get_integer32(idx);
// 		idx = table->get_index("Life");
// 		equipAttr.data[EquipBaseAttr::EBA_Life] = table->get_integer32(idx);
// 		idx = table->get_index("Mana");
// 		equipAttr.data[EquipBaseAttr::EBA_Mana] = table->get_integer32(idx);
// 		idx = table->get_index("Hit");
// 		equipAttr.data[EquipBaseAttr::EBA_Hit] = table->get_integer32(idx);
// 		idx = table->get_index("Miss");
// 		equipAttr.data[EquipBaseAttr::EBA_Miss] = table->get_integer32(idx);
// 		idx = table->get_index("Baoji");
// 		equipAttr.data[EquipBaseAttr::EBA_Baoji] = table->get_integer32(idx);
// 		idx = table->get_index("Mianbao");
// 		equipAttr.data[EquipBaseAttr::EBA_MianBao] = table->get_integer32(idx);
// 	}
// 	c_db_manager::getSingleton()->destroy_table(table);
// 	c_db_manager::getSingleton()->end_operation(cmd);

	return equipAttr;
}

//使用物品结果
unsigned int PackageManager::onItemUsed( s_net_cmd *cmd )//使用物品结果
{
	if(cmd->id == message_id_crc("NET_SIS_use_item"))//使用物品  协议
	{
		_canUseItem = true;
		NET_SIS_use_item *msg = (NET_SIS_use_item*)cmd;
		if(msg->dw_error_code == E_Success)
		{

			GET_UI(ShortCutUi, WCT_ShorCutUi)->useItem(msg->n64ItemID);
			//signalItemUsed.emit(msg->dw_data_id);
			showSpecialInfoByUseItem(msg->dw_data_id,msg->dwSrcRoleID);//特殊物品使用的提示信息入口
			if (msg->dw_data_id == 1003005)//行会金锭
			{
				int jinQian = 300 * msg->in_data_num;
				ostringstream oss;
				oss<<"\xE4\xBD\xBF\xE7\x94\xA8\xE8\xA1\x8C\xE4\xBC\x9A\xE9\x87\x91\xE9\x94\xAD\xEF\xBC\x8C\xE8\xA1\x8C\xE4\xBC\x9A\xE8\xB5\x84\xE9\x87\x91\xE5\xA2\x9E\xE5\x8A\xA0"<<jinQian;
				ToolTip::getInstance()->push(oss.str());
			}
			if (1002001 == msg->dw_data_id || 1002002 == msg->dw_data_id || 1002003 == msg->dw_data_id ||
				1002004 == msg->dw_data_id || 1002005 == msg->dw_data_id)
			{
				/////停止自动寻路
				LocalPlayer *player = RoleManager::getInstance()->getLocalPlayer();
				if (player)
				{
					player->setAutoRunState(false);
					MessageDispatcher::Instance()->DispatchMsg(-1.0, NULL, player, M_LpStand, NULL);
				}	
				if (AutoActionMgr::getInstance()->Get_Auto_Action())//gx add
				{
					AutoActionMgr::getInstance()->Set_Auto_Action(false);
				}
			}
			ItemTypeData data = getItemTypeData(msg->dw_data_id);
			if(data.type == PIT_GoodManCard)
			{
				ToolTip::getInstance()->push(GET_STR(7147).c_str());
			}
			else if(data.type == PIT_MaPai)
			{
				if (0==RoleManager::getInstance()->getLocalPlayer()->getMaPaiLevel())
				{
					RoleManager::getInstance()->syncRideData();
					OPEN_UI(WCT_MountUi);
					GET_UI(MountUi,WCT_MountUi)->setMaPaiAction();
				}
				else
				{
					ToolTip::getInstance()->push(STRING_TABLE["mul_use_mapai"]);
				}
			}
		}
		//show error infomation
		else
		{
			showErrorInfoByUseItem(msg->dw_error_code,msg->n64ItemID);//gx add
		}
	}
	return 0;
}

//是否自动使用道具条件判断
bool PackageManager::isAutoUseDaoju(unsigned int typeID)
{
	//特殊处理  非新手引导需要技能不再弹出立即学习，新手引导技能学习 1003229战士技能书  1003233 法师技能书  1003237道士技能书
	//更改特殊处理，换为通用处理 by tanligao
	// 	if (1003229 == typeID || 1003233 == typeID || 1003237 == typeID)  //只有新手引导的技能书才弹出
	// 	{
	ItemTypeData itemData = getItemTypeData(typeID);
	LocalPlayer *localPlayer = RoleManager::getInstance()->getLocalPlayer();
	if (itemData.type == PIT_SKILLBOOK)
	{
		//加技能书与当前玩家职业判断
		SkillData *skilldata;
		for (int i = 0; i < 9; i++)  //技能分1~9级，同一技能不同等级id不同
		{
			skilldata = SkillManager::getInstance()->getSkillData(itemData.special_value_1 + i,false);
			if (skilldata)
				break;
		}

		if (skilldata == NULL && localPlayer && localPlayer->getLevel() >= itemData.level)	 //是否已经学习过与玩家等级判断
		{

			if (itemData.profession == 1 << localPlayer->getAttribute(RA_ROLETYPE))        //玩家职业判断,由于制作表中的技能书职业字段与玩家职业字段不符，1和2、2和4、3和8相互对应
			{																			   //不是不不符，而是特地这样设计，通过移位来获得等值，来判断
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	/*	}*/
	//从数据表读出信息，放到一个容器中，使用的时候进行遍历
	// 	int autoUseDaoju = -1;
	// 	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM PackageData WHERE typeId = ?1");
	// 	cmd->set_integer32(1 ,typeID );
	// 	c_sql_table* table = c_db_manager::getSingleton()->create_table();
	// 	while(table->retrieve_row())
	// 	{
	// 		unsigned int idx = table->get_index("tipsBtnIdx");//--------------字符串
	// 		autoUseDaoju = table->get_integer32(idx);   //获得的是5或6							 
	// 	}
	// 	c_db_manager::getSingleton()->destroy_table(table);
	// 	c_db_manager::getSingleton()->end_operation(cmd);

	const ItemTypeData& itemTypeData = PackageManager::getInstance()->getItemTypeData(typeID);
	//判断是否是自动要使用的物品
	if((itemTypeData.byTipsBtnIdx == 5 || itemTypeData.byTipsBtnIdx == 17)
		&& localPlayer && localPlayer->getLevel() >= itemData.level )
	{
		return true;
	}
	else
	{
		return false; // 全部为true，用于测试	
	}

}
unsigned int PackageManager::onAddNewItem( s_net_cmd *cmd )//在背包中添加新物品（杂物等）   网络消息
{
	if(cmd->id == message_id_crc("NET_SIS_new_item_add"))//NET_SIS_new_item_add协议中的结构体
	{
		NET_SIS_new_item_add *msg = (NET_SIS_new_item_add*)cmd;//添加新物品协议
		f_item* pItem = new f_item(msg->Item);//f_item物品类
		unsigned int id = pItem->get_item_type_id();
		if(pItem != NULL)
		{
			std::map<int,int> idList = NumericalIniMgr::getInstance()->getImmediatelyUseTypeList();
			std::map<int,int>::iterator idIter = idList.find(id);
			if(idIter != idList.end())
			{
				AutoUseExpCard(pItem->get_item_id());
				return 0;
			}
			addNewItem(pItem);//调用添加一个新物品  添加到map
			if (pItem->get_item_type_id()==1003222)
			{
				std::stringstream ss;
				ss<<pItem->get_item_number();
				std::string str = replaceStr(GET_STR(7222),"**",ss.str());
				if (!PackageManager::getInstance()->GetBoxTenChoujiangProcessState())
				{
					ToolTip::getInstance()->push(str);
				}
			}
			if (pItem->get_item_type_id()==1102012)//30级完美套装包
			{
				long long id = pItem->get_item_id();
				WanMeiGiftUiMgr::GetInstance()->SetItemId(id);
				//OPEN_UI(WCT_ImmediateEquipUi);
				//GET_UI(ImmediateEquipUi,WCT_ImmediateEquipUi)->setData((f_equipment*)pItem);
				ImmediateEquipUi::getInstance()->open();
				ImmediateEquipUi::getInstance()->setItemData(pItem);
			}
			if(isAutoUseDaoju(id))
			{
				//CCSize winSize = CCDirector::sharedDirector()->getWinSize();//屏幕尺寸
				if(!IS_UI_OPEN(WCT_TradingUI))
				{
					ItemAutoUseDaojuTip::getInstace()->open();//加载道具
					ItemAutoUseDaojuTip::getInstace()->setDataId(pItem,pItem->get_item_number(),true);//传递物品id
				}

			}else{
				//return;      不做任何操作 
			}
			if(pItem->get_container_type() == EICT_Bag)//背包
			{
				GET_UI(Package, WCT_PACKAGEUI)->updateData(pItem->m_data.n16Index);
				signalBagAddNewItem.emit(pItem->m_data.n16Index);
				InstanceMgr::getInstance()->onChangeTLItemNums(pItem->get_item_type_id());//在天牢副本中获得道具需要改变界面显示
			}
			else if(pItem->get_container_type() == EICT_KungfuBag)
			{
				GET_UI(WuXueUi, WCT_WUXUEUI)->updateMartialData();
			}
			else if(pItem->get_container_type() == EICT_KungfuWare)
			{
				GET_UI(WuXueUi, WCT_WUXUEUI)->updateWare();
			}
			else if(pItem->get_container_type() == EICT_KungfuEquip)
			{
				GET_UI(WuXueUi, WCT_WUXUEUI)->updateEquip();
			}
			else if(pItem->get_container_type() == EICT_KungfuTemp)
			{
				GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();
			}
			else if(pItem->get_container_type() == EICT_StallItem)//[bing] 摆摊物品栏
			{
				//[bing] 这是增加物品 初始化时 或者Add一个装备的时候 并不发生在容器间移动
				//GET_UI(NewStallUi, WCT_NEW_STALLUI)->AddStallItem(pItem);

				GET_UI(NewStallUi, WCT_NEW_STALLUI)->UpdateStallItem();
			}

			//!提示一下
			ItemTypeData data = getItemTypeData(pItem->get_item_type_id());
			//若是抽奖得到的，则不在这里进行提示
			//EItemCreateMode eMode = pItem->get_data()->eCreateMode;
			/*if (EICM_Lottery == eMode || EICM_Gift == eMode)
			return 0;*/


			TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
			if (NULL == ui)
			{
				stringstream ss;
				ss<<GET_STR(9264).c_str()<<data.name<<"*"<<pItem->m_data.GetNum();
				ToolTip::getInstance()->push(ss.str());
			}
			else
			{
				if(T_TradingSell != ui->getFrameTag())
				{
					stringstream ss;
					ss<<GET_STR(9264).c_str()<<data.name<<"*"<<pItem->m_data.GetNum();
					ToolTip::getInstance()->push(ss.str());
				}
			}

			s_receive_chat_info info;
			info.send_channel = ESCC_System;

			std::stringstream ss1;
			ss1<<"\xE6\x82\xA8\xE8\x8E\xB7\xE5\xBE\x97\xE7\x89\xA9\xE5\x93\x81"<<data.name<<"*"<<pItem->m_data.GetNum();
			info.chat_text = ss1.str();
			ChatMgr::getInstance()->ShowInfoByChatChannel(info);

		}
	}
	//	Auto_Use_Exp_Card evt;
	//	SEND_EVENT(&evt);
	return 0;
}

unsigned int PackageManager::onAddNewEquitItem( s_net_cmd *cmd )//添加装备（）
{
	if(cmd->id == message_id_crc("NET_SIS_new_equip_add"))//添加装备协议
	{
		NET_SIS_new_equip_add *msg = (NET_SIS_new_equip_add*)cmd;
		f_equipment* pEquip = new f_equipment(msg->Equip);


		if(pEquip != NULL)
		{
			std::map<int,int> idList = NumericalIniMgr::getInstance()->getImmediatelyUseTypeList();
			std::map<int,int>::iterator idIter = idList.find(pEquip->get_item_type_id());
			if(idIter != idList.end())
			{
				AutoUseExpCard(pEquip->get_item_id());
				return 0;
			}
			addNewItem(pEquip);//调用添加一个新物品

			if(pEquip->get_container_type() == EICT_Bag)
			{
				signalBagAddNewItem.emit(pEquip->m_data.n16Index);
				GET_UI(Package, WCT_PACKAGEUI)->updateData(pEquip->m_data.n16Index);
			}
			else if(pEquip->get_container_type() == EICT_KungfuBag)
			{
				GET_UI(WuXueUi, WCT_WUXUEUI)->updateMartialData();
			}
			else if(pEquip->get_container_type() == EICT_KungfuWare)
			{
				GET_UI(WuXueUi, WCT_WUXUEUI)->updateWare();
			}
			else if(pEquip->get_container_type() == EICT_KungfuEquip)
			{
				GET_UI(WuXueUi, WCT_WUXUEUI)->updateEquip();
			}
			else if(pEquip->get_container_type() == EICT_KungfuTemp)
			{								//增加功法特效		【Ji：】
				std::string gongfaEffect="";
				c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM GongfaTipData WHERE typeId = ?1");
				cmd->set_integer32(1 , pEquip->get_item_type_id());
				c_sql_table* table = c_db_manager::getSingleton()->create_table();
				while(table->retrieve_row())
				{
					unsigned int idx = table->get_index("Effect2");
					gongfaEffect = table->get_text(idx);
				}
				c_db_manager::getSingleton()->destroy_table(table);
				c_db_manager::getSingleton()->end_operation(cmd);
				/*
				if (m_bIsGongfaOneKey && (m_nSECount > 0))
				{
				if (1 == m_nSECount)
				{
				m_bIsGongfaOneKey = false;
				_gongfaSEMap[(short)pEquip->m_data.n16Index]=gongfaEffect;
				--m_nSECount;
				GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();	
				for(std::map<short, string>::iterator seIter = _gongfaSEMap.begin(); seIter != _gongfaSEMap.end(); ++seIter)
				{
				GET_UI(CangJingGeUi, WCT_CangJingGeUi)->playSuperEffect(seIter->first, seIter->second);
				}
				_gongfaSEMap.clear();
				}
				else
				{
				_gongfaSEMap[(short)pEquip->m_data.n16Index] = gongfaEffect;
				--m_nSECount;
				}
				}
				else
				{
				GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();			//注：刷新藏经阁容器,让已经得到的功法显示出来(刷新后才播放特效）	【Ji：】
				GET_UI(CangJingGeUi, WCT_CangJingGeUi)->playSuperEffect((short)pEquip->m_data.n16Index, gongfaEffect);
				}
				*/

				GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();			//注：刷新藏经阁容器,让已经得到的功法显示出来(刷新后才播放特效）	【Ji：】
				GET_UI(CangJingGeUi, WCT_CangJingGeUi)->playSuperEffect((short)pEquip->m_data.n16Index, gongfaEffect);

				//GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();
			}
			else if(pEquip->get_container_type() == EICT_StallItem)
			{
				GET_UI(NewStallUi, WCT_NEW_STALLUI)->UpdateStallItem();
			}

			//参与新手引导的装备ID
			//9131013,9130013,9231013,9230013,9331013,9330013
			//9131035,9130035,9231035,9230035,9331035,9330035
			//若是抽奖得到的，则不在这里进行提示
			if (EICM_Lottery == pEquip->get_data()->eCreateMode)
				return 0;
			ItemTypeData data = getItemTypeData(pEquip->get_item_type_id());
			bool isQuest = false;
			//所有的任务奖励装备(不包含功法)都要出现自动换装UI gx add 2013.10.31
			if ((EICM_Quest == pEquip->get_data()->eCreateMode /*|| EICM_Product == pEquip->get_data()->eCreateMode */) && PIT_Equip == data.type)
			{
				if (canAutoEquip(pEquip->get_item_type_id()))//不考虑涉及新手引导的任务奖励装备
				{
					//todo:打开UI
					//需要参数：f_equipment*
					if (isShowEquipUp(pEquip))
					{
						ImmediateEquipUi::getInstance()->open();
						ImmediateEquipUi::getInstance()->setItemData(pEquip);
					}
					//return 0;//无需再进行别的提示
					isQuest = true;
				}
			}

			if ((isQuest == false)&&(data.type == PIT_Equip))
			{
				if (isEquipCanImmediateEquip(pEquip))
				{
					ImmediateEquipUi::getInstance()->open();
					ImmediateEquipUi::getInstance()->setData(pEquip);
				}
			}

			ForgingMgr::getInstance()->judgeDecomposeByEquip(pEquip);

			//!提示一下
			//ItemTypeData data = getItemTypeData(pEquip->get_item_type_id());

			TradingUILayer * ui = getUiNodeByTag<TradingUILayer>(WCT_TradingUI);
			if (NULL == ui)
			{
				stringstream ss;
				ss<<GET_STR(9264).c_str()<<data.name<<"*"<<pEquip->m_data.GetNum();
				ToolTip::getInstance()->push(ss.str());
			}
			else
			{
				if(T_TradingSell != ui->getFrameTag())
				{
					stringstream ss;
					ss<<GET_STR(9264).c_str()<<data.name<<"*"<<pEquip->m_data.GetNum();
					ToolTip::getInstance()->push(ss.str());
				}
			}

			s_receive_chat_info info;
			info.send_channel = ESCC_System;

			std::stringstream ss1;
			ss1<<"\xE6\x82\xA8\xE8\x8E\xB7\xE5\xBE\x97\xE7\x89\xA9\xE5\x93\x81"<<data.name<<"*"<<pEquip->get_data()->GetNum();
			info.chat_text = ss1.str();
			ChatMgr::getInstance()->ShowInfoByChatChannel(info);

		}
	}
	return 0;
}

unsigned int PackageManager::onAddStackItem( s_net_cmd *cmd )//增加堆叠物品（药品等）
{
	if(cmd->id == message_id_crc("NET_SIS_item_add"))//添加堆叠物品协议
	{
		NET_SIS_item_add *msg = (NET_SIS_item_add*)cmd;

		ItemMap *itemMap = getItemMap(msg->eConType);
		f_item *pItem = getItem(*itemMap, msg->n16Index);
		//unsigned int id = pItem->get_item_type_id();
		if(itemMap != NULL)
		{
			if(pItem != NULL)
			{
				unsigned int dw_data_id = pItem->get_item_type_id();
				std::map<int,int> idList = NumericalIniMgr::getInstance()->getImmediatelyUseTypeList();
				std::map<int,int>::iterator idIter = idList.find(dw_data_id);
				if(idIter != idList.end())
				{
					AutoUseExpCard(pItem->get_item_id());
					return 0;
				}
				onPackageItemChanged(dw_data_id);
				int nQuantity = msg->n16Num - pItem->get_item_number();
				//自动道具提示  在前或后判断都行
				if(isAutoUseDaoju(dw_data_id))
				{
					if (!IS_UI_OPEN(WCT_TradingUI))
					{
						ItemAutoUseDaojuTip::getInstace()->open();//加载道具
						ItemAutoUseDaojuTip::getInstace()->setDataId(pItem,nQuantity);//传递物品id,增加的数量
					}
				}
				else
				{
					//return;      不做任何操作 
				}
				pItem->set_item_number(msg->n16Num);
				checkFusionItemUpdateifNess(pItem);

				item_num_change evt;
				evt.item_type_id = pItem->get_item_type_id();
				SEND_EVENT(&evt);

				INT64 medicineId = GET_UI(ShortCutUi, WCT_ShorCutUi)->getMedicineId();
				if (pItem->get_item_id() == medicineId)//药品
				{
					GET_UI(ShortCutUi, WCT_ShorCutUi)->updateUsedItem();
				}
				if (dw_data_id==1003222)//星魂
				{
					std::stringstream ss;
					ss<<nQuantity;
					std::string str = replaceStr(GET_STR(7222),"**",ss.str());
					if (!PackageManager::getInstance()->GetBoxTenChoujiangProcessState())
					{
						ToolTip::getInstance()->push(str);
					}
				}
				if(msg->eConType == EICT_Bag)
				{
					GET_UI(Package, WCT_PACKAGEUI)->updateData(pItem->m_data.n16Index);
					InstanceMgr::getInstance()->onChangeTLItemNums(dw_data_id);//在天牢副本中获得道具需要改变界面显示
				}
				else if(msg->eConType == EICT_KungfuBag)
				{
					GET_UI(WuXueUi, WCT_WUXUEUI)->updateMartialData();
				}
				else if(msg->eConType == EICT_KungfuWare)
				{
					GET_UI(WuXueUi, WCT_WUXUEUI)->updateWare();
				}
				else if(msg->eConType == EICT_KungfuEquip)
				{
					GET_UI(WuXueUi, WCT_WUXUEUI)->updateEquip();
				}
				else if(msg->eConType == EICT_KungfuTemp)
				{
					GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();
				}

				//!提示一下
				if (nQuantity <= 0)
					return 0;
				//若是抽奖得到的，则不在这里进行提示
				/*if (EICM_Lottery == msg->eCreateMode || EICM_Gift == msg->eCreateMode)
				return 0;*/
				//若是绑定与非绑定堆叠,则不在这里进行提示 //add by XSea 2014.12.24
				if( EICM_Stack_Bind_Move == msg->eCreateMode )
				{
					unLockItem(msg->eConType,msg->n16Index);
					return 0;
				}
				ItemTypeData data = getItemTypeData(pItem->get_item_type_id());
				//根据是否是重要物品给予不同的提示方式

				if (!FubenMgr::GetInstance().getIsOneSaodang() && !FubenMgr::GetInstance().getIsTenSaodang())
				{
					stringstream ss;
					ss<<GET_STR(9264).c_str()<<data.name<<"*"<<nQuantity;
					ToolTip::getInstance()->push(ss.str());
				}

				s_receive_chat_info info;
				info.send_channel = ESCC_System;
				std::stringstream ss1;
				ss1<<"\xE6\x82\xA8\xE8\x8E\xB7\xE5\xBE\x97\xE7\x89\xA9\xE5\x93\x81"<<data.name<<"*"<<nQuantity;//药品等消息提示
				info.chat_text = ss1.str();
				ChatMgr::getInstance()->ShowInfoByChatChannel(info);
				//Auto_Use_Exp_Card evt;
				//SEND_EVENT(&evt);
			}
		}

	}
	return 0;
}

unsigned int PackageManager::onEquipItem( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_equip"))
	{
		NET_SIS_equip *msg = (NET_SIS_equip*)cmd;
		switch (msg->dw_error_code)
		{
		case E_Item_ClassLimit://职业限制
			ToolTip::getInstance()->push(GET_STR(2018));
			break;
		case E_Item_LevelLimit://等级限制
			ToolTip::getInstance()->push(GET_STR(2017));
			break;
		case E_Item_SexLimit://性别限制
			ToolTip::getInstance()->push(GET_STR(2019));
			break;
		case E_Equip_InvalidPos://装备的目标位置不正确
			ToolTip::getInstance()->push(GET_STR(2051));
			break;
		}

		if(msg->dw_error_code != E_Success)
		{
			unLockItem(EICT_Bag, msg->n64_serial, true);
			std::map<INT64, EEquipPos>::iterator iter = _tmpEquipData.find(msg->n64_serial);
			if(iter != _tmpEquipData.end())
			{
				unLockItem(EICT_Equip, (short)iter->second);
			}
		}
		else
		{
			RoleEquipUi* roleEquipUi=GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI);
			if(roleEquipUi){
				roleEquipUi->updateEquipment();
			}
			signalEquip.emit(msg->n64_serial);

			wear_change_event event;
			SEND_EVENT(&event);
		}

		_tmpEquipData.erase(msg->n64_serial);
	}

	return 0;
}
unsigned int PackageManager::onEquipKungfu(s_net_cmd *cmd)
{
	NET_SIS_equip_kungfu *msg = (NET_SIS_equip_kungfu*)cmd;
	switch (msg->dw_error_code)
	{
	case E_State_NoCan_ChangeKungfu://摆摊双修等状态下，不能装备功法
		break;
	case E_Item_LevelLimit://等级不足
		break;
	case E_SameKungfu_Cannt_Equip://同一种类的功法不能重复装备
		ToolTip::getInstance()->push(GET_STR(2310));
		break;
	}

	if(msg->dw_error_code != 0)
	{
		unLockItem(EICT_KungfuBag, msg->n64_serial);
	}

	_tmpKungfuData.erase(msg->n64_serial);
	return 0;
}
unsigned int PackageManager::onUnEquipItem( s_net_cmd *cmd )
{
	NET_SIS_unequip *msg = (NET_SIS_unequip*)cmd;
	PackageManager::getInstance()->unLockItem(EICT_Equip, msg->n64_serial);

	wear_change_event event;
	SEND_EVENT(&event);

	return 0;
}
//脱下功法
unsigned int PackageManager::onUnEquipKungfu(s_net_cmd *cmd)
{
	NET_SIS_unequip_kungfu *msg = (NET_SIS_unequip_kungfu*)cmd;
	if (msg->dw_error_code != E_Success)
	{
		PackageManager::getInstance()->unLockItem(EICT_KungfuEquip,msg->n64_serial);
		//当功法脱下失败时有可能会锁定功法包裹内物品 所以刷新一下功法包裹内物品	//[bing] 这么写不是很严谨 因为如果网络延迟会解锁所有背包内锁定的物品 先这样处理
		PackageManager::getInstance()->unLockItem(EICT_KungfuBag);
	}
	return 0;
}
void PackageManager::strengthenEquip( INT64 equipId ,bool isAutoBuy,int nIsWendingStone)
{
	NET_SIC_shengxing msg;
	msg.n64SerialEquip = equipId;
	msg.bIsYuanBao = isAutoBuy; //暂时写死,等格林接客户端
	msg.nIsWendingStone = nIsWendingStone; //暂时写死,等格林接客户端
	TCP_CLIENT->send_net_cmd(&msg, NP_NORMAL, false);
}

unsigned int PackageManager::onEquipStrengthen( s_net_cmd *cmd )
{
	//f_equipment *equip = EquipFusionManager::getInstance()->getEquipment();
	//f_item* pItem = PackageManager::getInstance()->getItem(EICT_Bag,m_TempGoodsInfo.n64_Serial);

	if(cmd->id == message_id_crc("NET_SIS_shengxing"))
	{
		NET_SIS_shengxing *msg = (NET_SIS_shengxing*)cmd;

		f_item* pItem = PackageManager::getInstance()->getItem(EICT_Bag,msg->n64SerialEquip);
		if (pItem == NULL)
		{
			if (msg->n64NewSerialEquip != 0)
			{
				f_item* pItem = PackageManager::getInstance()->getItem(EICT_Bag,msg->n64NewSerialEquip);
				if (pItem == NULL)
				{
					pItem = PackageManager::getInstance()->getItem(EICT_Equip,msg->n64NewSerialEquip);
				}
				f_equipment* _desEquip = dynamic_cast<f_equipment*>(pItem);
				EquipFusionManager::getInstance()->setEquipment(_desEquip);
			}
		}
		int nError_Code = int(msg->dw_error_code); //因传输室DWORD类型,服务器结果为-1=降星,0=不变,1=升星。所以转成int类型
		switch( nError_Code )
		{
		case -1: //降级
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE5\xA4\xB1\xE8\xB4\xA5\xEF\xBC\x8C\xE8\xA3\x85\xE5\xA4\x87\xE5\xBC\xBA\xE5\x8C\x96\xE7\xAD\x89\xE7\xBA\xA7\x2D\x31"); //强化失败，装备强化等级-1
			GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onFailed();		//增加失败后的回调,主要用来播特效	【J】
			break;
		case  0: //不变
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE5\xA4\xB1\xE8\xB4\xA5\xEF\xBC\x8C\xE8\xA3\x85\xE5\xA4\x87\xE5\xB9\xB6\xE6\x9C\xAA\xE4\xBA\xA7\xE7\x94\x9F\xE5\x8F\x98\xE5\x8C\x96"); //强化失败，装备并未产生变化
			GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onFailed();
			break;
		case  1: //升级
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE6\x88\x90\xE5\x8A\x9F\xEF\xBC\x8C\xE8\xA3\x85\xE5\xA4\x87\xE5\xBC\xBA\xE5\x8C\x96\xE7\xAD\x89\xE7\xBA\xA7\x2B\x31"); //强化成功，装备强化等级+1
			GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onSuccess(/*msg->n64SerialEquip*/);
			GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI)->updateEquipment();
			break;
		case E_ShengXing_CanNot: //装备不能强化
			ToolTip::getInstance()->push("\xE8\xA3\x85\xE5\xA4\x87\xE4\xB8\x8D\xE8\x83\xBD\xE5\xBC\xBA\xE5\x8C\x96");
			break;
		case E_ShengXingItem_Not_Exit: //强化所需强化石不存在
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE6\x89\x80\xE9\x9C\x80\xE5\xBC\xBA\xE5\x8C\x96\xE7\x9F\xB3\xE4\xB8\x8D\xE5\xAD\x98\xE5\x9C\xA8");
			break;
		case E_ShengXing_Abort: //强化失败
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE5\xA4\xB1\xE8\xB4\xA5");
			break;	
		case E_ShengXing_Item_Error: //强化石不符合要求
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE7\x9F\xB3\xE4\xB8\x8D\xE7\xAC\xA6\xE5\x90\x88\xE8\xA6\x81\xE6\xB1\x82");
			break;
		case E_ShengXing_Param_Not_Find: //强化参数未找到
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE5\x8F\x82\xE6\x95\xB0\xE6\x9C\xAA\xE6\x89\xBE\xE5\x88\xB0");
			break;
		case E_ShengXing_NotEnough_Money: //强化金钱不足
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE9\x87\x91\xE9\x92\xB1\xE4\xB8\x8D\xE8\xB6\xB3");
			break;
		case E_ShengXing_BingNot: //强化石与绑定类型不符
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE7\x9F\xB3\xE4\xB8\x8E\xE7\xBB\x91\xE5\xAE\x9A\xE7\xB1\xBB\xE5\x9E\x8B\xE4\xB8\x8D\xE7\xAC\xA6");
			break;
		case E_ShengXing_NumError:	//强化石数量不符
			ToolTip::getInstance()->push(GET_STR(249).c_str());
			break;
		case E_ShengXing_Type_Error:	//强化石类型不符
			ToolTip::getInstance()->push("\xE5\xBC\xBA\xE5\x8C\x96\xE7\x9F\xB3\xE7\xB1\xBB\xE5\x9E\x8B\xE4\xB8\x8D\xE7\xAC\xA6");
			break;
		case E_ShengXing_Not_YuanBao:	//元宝不足
		case E_ShengXing_WendingStone_Money_Not_Enougth:
			//ToolTip::getInstance()->push("\xE5\x85\x83\xE5\xAE\x9D\xE4\xB8\x8D\xE8\xB6\xB3");
			//add by vvv 2014.11.05
			//messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,GET_STR(7024).c_str(), TEXT_UTF8_RECHARGE, TEXT_UTF8_QUXIAO);//充值，取消
			//messageBox->signalOkBtnPressed.connect(this, &PackageManager::noticeRecharge);
			//World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
			RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
			break;
		case E_ShengXing_Not_Silver:	//金币不足
			ToolTip::getInstance()->push("\xE9\x87\x91\xE5\xB8\x81\xE4\xB8\x8D\xE8\xB6\xB3");
			break;
		case E_ShengXing_Bag_Not_Enough:	//背包不足1个空间
			ToolTip::getInstance()->push("\xE8\x83\x8C\xE5\x8C\x85\xE4\xB8\x8D\xE8\xB6\xB3\x31\xE4\xB8\xAA\xE7\xA9\xBA\xE9\x97\xB4");
			break;
		case E_ShengXing_Fail_Use_WendingStone:
			{
				ToolTip::getInstance()->push(GET_STR(7171));
				GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onFailed();
				nError_Code = 0;
			}
			break;
		case E_ShengXing_WendingStone_Not_Enougth:
			{
				ToolTip::getInstance()->push(GET_STR(7219));
				nError_Code = E_ShengXing_WendingStone_Not_Enougth;
			}
			break;
		}
		if(nError_Code > 1)
			GET_UI(StrengthenUi, WCT_STRENGTHENUI)->setPermission(false);
		/*if(nError_Code == 0)
		{ //强化成功
		GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onSuccess(msg->n64SerialEquip);
		}
		else if(nError_Code == E_ShengXing_Abort)
		{//强化失败
		GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onFailed(msg->n64SerialEquip);
		}
		else if (E_ShengXing_CanNot == nError_Code)
		{
		GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onFailed(msg->n64SerialEquip);
		ToolTip::getInstance()->push(GET_STR(247));
		}
		else if (E_ShengXing_Item_Error == nError_Code)
		{
		GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onFailed(msg->n64SerialEquip);
		ToolTip::getInstance()->push(GET_STR(248));
		}
		else if (E_ShengXing_NumError == nError_Code)
		{
		GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onFailed(msg->n64SerialEquip);
		ToolTip::getInstance()->push(GET_STR(249));
		}
		else if (E_ShengXing_CanNot == nError_Code)//时装翅膀不能强化
		{
		GET_UI(StrengthenUi, WCT_STRENGTHENUI)->onFailed(msg->n64SerialEquip);
		ToolTip::getInstance()->push(GET_STR(2114));
		}
		else
		{
		//do nothing
		}*/

	}
	return 0;
}
void PackageManager::noticeRecharge()
{
	AudioPlayer::getSigletonPtr()->playerSoundUIEffect(SOUND_4);
	OPEN_UI(WCT_ChongZhiActivityFarmeUI);
}
unsigned int PackageManager::onEquipAttrChange( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_equip_change"))
	{
		NET_SIS_equip_change *msg = (NET_SIS_equip_change*)cmd;
		f_equipment *equip = dynamic_cast<f_equipment*>(getItem(msg->n64_serial));
		bool isRefreshUI = false;
		if (equip->m_equipex.byQuality <= msg->equipSpec.byQuality)
		{
			isRefreshUI = true;
		}
		if(equip != NULL)
		{
			//[bing] 发生改变这是融合操作
			if(equip->get_container_type() == EICT_KungfuEquip
				|| equip->get_container_type() == EICT_KungfuTemp
				|| equip->get_container_type() == EICT_KungfuBag)
			{
				equip->unlock();
				if(msg->equipSpec.nLevel>equip->m_equipex.nLevel)
				{
					//记一下升级的魔魂，以供播放特效用
					GambleMgr::getInstance()->m_leveUpEquipt.push_back(equip);
				}
			}

			memcpy(&equip->m_equipex, &msg->equipSpec, sizeof(tagEquipSpec));



			if (isRefreshUI)
			{
				//根据装备所在位置更新对应ui
				switch(equip->get_container_type())
				{
				case EICT_Bag:
					{
						if (IS_UI_OPEN(WCT_PACKAGEUI))
						{
							PackageUi *tempPackegeUi = GET_UI(Package, WCT_PACKAGEUI)->getUiLayer();
							if (tempPackegeUi)
							{
								tempPackegeUi->updateEquipItem(equip);
							}
						}
						break;
					}
				case EICT_Equip:
					{
						if (IS_UI_OPEN(WCT_ROLEEQUIPUI))
						{
							RoleEquipUi *tempRoleEquipUi = GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI);
							if (tempRoleEquipUi)
							{
								tempRoleEquipUi->updateEquipment();
								// 								EquipAddUpdate evt;
								// 								evt.equip=equip;
								// 								SEND_EVENT(&evt);
							}
						}
						else if(IS_UI_OPEN(WCT_ROLERINGUI))
						{
							RoleRingUi *tempRoleRingUi = GET_UI(RoleRingUi, WCT_ROLERINGUI);
							if (tempRoleRingUi)
							{
								tempRoleRingUi->updateEquipment();
							}
						}
						break;
					}
				default:
					break;

				}
			}
		}
	}
	return 0;
}

void PackageManager::indentifyEquip( INT64 equipId, INT64 indentifyStuffId )
{
	NET_SIC_identify_equip cmd;
	cmd.n64SerialEquip = equipId;
	cmd.n64SerialReel  =indentifyStuffId;
	TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, false);
}

unsigned int PackageManager::onEquipIndentify( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_identify_equip"))
	{
		NET_SIS_identify_equip *msg = (NET_SIS_identify_equip*)cmd;
		if(msg->dw_error_code == 0)
		{
			GET_UI(IndifityUi, WCT_IndifityUi)->onIndentifySuccess(msg->n64_serial);
		}
		else
		{
			if (E_Compose_Equip_Not_identify == msg->dw_error_code)
			{
				ToolTip::getInstance()->push(GET_STR(2115));
			}
			GET_UI(IndifityUi, WCT_IndifityUi)->onIndentifyFailed(msg->n64_serial);
		}
	}
	return 0;
}

int PackageManager::getBlankCount( EItemConType con/* = EICT_Bag*/ )
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap == NULL)
		return 0;

	if(con == EICT_Bag)
		return getConSize(EICT_Bag) - itemMap->size();
	else
		return getConSize(con) - itemMap->size();
}
//gx modify 不需要打孔石
void PackageManager::chiselEquip( INT64 equipId )
{
	//首先判断玩家元宝或礼券是否足够
	if (PackageManager::getInstance()->getYuanBao() < EAUIP_CHISE_NEED_YUANBAO && 
		PackageManager::getInstance()->getDiamond() < EAUIP_CHISE_NEED_YUANBAO)
	{
		/*MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,GET_STR(164).c_str(), TEXT_UTF8_CHONGZHI, TEXT_UTF8_QUXIAO);
		World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
		messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::ToCharge);*/
		RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
		return;
	}
	NET_SIC_chisel msg;
	msg.n64SrcItemID = equipId;
	//首先查找是否有打孔石
	/*f_item *item = PackageManager::getInstance()->getItem(EICT_Bag, (unsigned int)DAKONGSHITYPEID);
	if(item != NULL)
	{
	msg.n64StuffID = item->get_item_id();
	}
	else*/
	{
		msg.n64StuffID = -1;
	}
	TCP_CLIENT->send_net_cmd(&msg, NP_IDLE, false);
}

unsigned int PackageManager::onEquipChisel( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_chisel"))
	{
		NET_SIS_chisel *msg = (NET_SIS_chisel*)cmd;
		if(msg->dw_error_code == 0)
		{
			GET_UI(InlayUi, WCT_InlayUi)->onServerChisel(true);
		}
		else
		{
			GET_UI(InlayUi, WCT_InlayUi)->onServerChisel(false);
			switch(msg->dw_error_code)
			{
			case E_Consolidate_NotEquipment:
				ToolTip::getInstance()->push(GET_STR(250));
				break;
			case E_Consolidate_NotIdentified:
				ToolTip::getInstance()->push(GET_STR(250));
				break;
			case E_Consolidate_Equip_Hole_Full:
				ToolTip::getInstance()->push(GET_STR(251));
				break;
			case E_Consolidate_Chisel_Not_Exit:
				ToolTip::getInstance()->push(GET_STR(252));
				break;
			case E_Consolidate_Shipingqu_Not:
				ToolTip::getInstance()->push(GET_STR(2116));
				break;
			case E_Hole_NotEnough_Money:
				RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
				break;
			}
		}
	}
	return 0;
}

void PackageManager::unbesetEquip( INT64 equipId, unsigned char index )
{
	NET_SIC_unbeset msg;
	msg.n64SerialEquip = equipId;
	msg.byUnBesetPos = index;
	TCP_CLIENT->send_net_cmd(&msg, NP_IDLE, false);
}

void PackageManager::inlayEquip( INT64 equipId, INT64 *stoneId )
{
	NET_SIC_inlay msg;
	msg.n64DstItemID = equipId;
	memcpy(msg.n64SrcItemID, stoneId, sizeof(INT64) * MAX_EQUIPHOLE_NUM);
	TCP_CLIENT->send_net_cmd(&msg, NP_IDLE, false);
}

unsigned int PackageManager::onEquipInlay( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_inlay"))
	{
		NET_SIS_inlay *msg = (NET_SIS_inlay*)cmd;
		if(msg->dw_error_code == 0)
		{
			GET_UI(InlayUi, WCT_InlayUi)->onServerInlay(true);
			GET_UI(InlayUi, WCT_InlayUi)->runInlayEffect();
			ToolTip::getInstance()->push("\xE5\xAE\x9D\xE7\x9F\xB3\xE9\x95\xB6\xE5\xB5\x8C\xE6\x88\x90\xE5\x8A\x9F"); //宝石镶嵌成功
			PackageUi* layer = getUiNodeByTag<PackageUi>(WCT_PACKAGEUI);
			if (NULL != layer)
			{
				layer->updatePackage();
			}

			if(NULL != GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI))
				GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI)->updateEquipment();

		}
		else
		{
			switch (msg->dw_error_code)
			{
			case E_Consolidate_EquipCanNotInlay:
				ToolTip::getInstance()->push(GET_STR(2008));
				break;
			case E_Consolidate_Gem_Not_Hole:
				ToolTip::getInstance()->push(GET_STR(2010));
				break;
			case E_Consolidate_Shipingqu_Not:
				ToolTip::getInstance()->push(GET_STR(2117));
				break ;
			case E_Consolidate_Gem_level_not:
				ToolTip::getInstance()->push(GET_STR(2118));
				break;
			default:
				break;
			}
			GET_UI(InlayUi, WCT_InlayUi)->onServerInlay(false);
		}
	}

	return 0;
}

void PackageManager::equipLevelUp( INT64 equipId, unsigned int *stuffId )
{
	NET_SIC_equip_type_change msg;
	msg.n64EquipID = equipId;
	msg.n64Item1 = stuffId[0];
	msg.n64Item2 = stuffId[1];
	msg.n64Item3 = stuffId[2];
	TCP_CLIENT->send_net_cmd(&msg, NP_IDLE, false);
}

unsigned int PackageManager::onEquipLevelUp( s_net_cmd *cmd )
{
	if(cmd->id == message_id_crc("NET_SIS_equip_type_change"))
	{
		NET_SIS_equip_type_change* msg = (NET_SIS_equip_type_change*)cmd;
		if(msg->dw_error_code == 0)
		{
			f_equipment* newEquip = (f_equipment*)(this->getItem(msg->n64EquipID));
			//			CC_ASSERT(newEquip != NULL);
			if(newEquip != NULL)
				EquipLevelUpUiMgr::getInstance()->setEquipment(newEquip);
			else
				EquipLevelUpUiMgr::getInstance()->setLevelupPotency(false);
			GET_UI(EquipLevelUpUi, WCT_EquipLevelUpUi)->onServerResult(true);
		}
		else
		{
			switch( msg->dw_error_code )
			{
			case E_Compose_Bag_Full: //背包已满
				ToolTip::getInstance()->push("\xE8\x83\x8C\xE5\x8C\x85\xE5\xB7\xB2\xE6\xBB\xA1\xEF\xBC\x8C\xE8\xAF\xB7\xE6\xB8\x85\xE7\x90\x86\xE5\x90\x8E\xE5\x86\x8D\xE8\xBF\x9B\xE8\xA1\x8C\xE8\xA3\x85\xE5\xA4\x87\xE5\x8D\x87\xE7\xBA\xA7");
				break;;
			case E_LvUp_Bag_Not_Enough: //背包不足2个空间
				ToolTip::getInstance()->push("\xE8\x83\x8C\xE5\x8C\x85\xE4\xB8\x8D\xE8\xB6\xB3\x32\xE4\xB8\xAA\xE7\xA9\xBA\xE9\x97\xB4");
				break;
			case E_LvUp_Bag_Not_Silver: //金币不足
				ToolTip::getInstance()->push("\xE9\x87\x91\xE5\xB8\x81\xE4\xB8\x8D\xE8\xB6\xB3");
				break;
			case E_LvUp_Equip_Not_LvUp:
				ToolTip::getInstance()->push("\xE6\xAD\xA4\xE8\xA3\x85\xE5\xA4\x87\xE5\xB7\xB2\xE8\xBE\xBE\xE5\x88\xB0\xE6\x9C\x80\xE9\xAB\x98\xE7\xBA\xA7");
				break;
				/*
				default:
				GET_UI(EquipLevelUpUi, WCT_EquipLevelUpUi)->onServerResult(false);*/
				break;
			}
		}

		CCLOG("onEquipLevelUp");
		if(NewPlayerGuider::getInstance()->GetIsGuide())
		{
			NewPlayerGuider::getInstance()->RunNewPlayerGuilde();
		}


	}
	return 0;
}

void PackageManager::getSellAll(std::vector<const tagItem*>& vec)
{
	ItemMap::iterator it = _pocket.begin();
	for (; it != _pocket.end(); ++ it)
	{
		const tagItem* pItem = it->second->get_data();
		if (pItem != NULL)
		{
			ItemTypeData pItemProto = getItemTypeData(pItem->dw_data_id);
			if (pItemProto.bAutoSell != 0)
			{
				vec.push_back(pItem);
			}
		}
	}
}

unsigned int PackageManager::onNewessChanged( s_net_cmd *cmd )
{
	NET_SIS_newess_change *msg = (NET_SIS_newess_change*)cmd;
	f_item *item = getItem(msg->n64EquipSerial);
	if(item != NULL)
	{
		item->set_item_use_times(msg->nAttackTimes);

		EEquipPos equipPosIndex;
		int equipDurability = 0;
		std::string equipName("");

		EquipData::iterator iter = _equipData.find(item->get_item_type_id());
		if (iter != _equipData.end())
		{
			equipDurability = iter->second.durability;
			equipPosIndex = iter->second.posIndex;
			equipName = iter->second.name;
		}

//修改完成 		c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM EquipData WHERE typeId = ?1");
// 		cmd->set_integer32(1 , item->get_item_type_id());
// 		c_sql_table* table = c_db_manager::getSingleton()->create_table();
// 		while(table->retrieve_row())
// 		{
// 			unsigned int idx = table->get_index("Durability");
// 			equipDurability = table->get_integer32(idx);
// 			idx = table->get_index("PosIndex");
// 			equipPosIndex = (EEquipPos)table->get_integer32(idx);
// 
// 			idx = table->get_index("Name");
// 			equipName = table->get_text(idx);
// 		}
// 		c_db_manager::getSingleton()->destroy_table(table);
// 		c_db_manager::getSingleton()->end_operation(cmd);
		//修改为一件装备耐久下降到原来的30%时，以后每次耐久减少1点出现提示 //add by XSea 2015.02.03
		if(GetEquipNewness(equipPosIndex, msg->nAttackTimes, equipDurability) <= 0.3*equipDurability)//耐久不足30%给提示
		{
			std::string outStr = replaceStr(GET_STR(2053),"**",equipName);
			ToolTip::getInstance()->push(outStr);
		}

		wear_change_event event;
		SEND_EVENT(&event);
	}
	return 0;
}

void PackageManager::extendPackage(int num, int type)
{
	NET_SIC_bag_extend cmd;
	//cmd.n64ItemSerial = itemId;
	cmd.n32_num = num;
	cmd.n32_type = type;
	TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);
}

void PackageManager::useItemToExpendPackage()
{
	f_item *item = getItem(EICT_Bag, (unsigned int)PACKAGE_EXTEND_ITEM);
	if(item != NULL)
	{
		//extendPackage(item->get_item_id(), 0);
	}
}

void PackageManager::useYuanbaoToExpendPackage()
{
	extendPackage(_addNum, 0);
}

unsigned int PackageManager::onBagExtend( s_net_cmd *cmd )
{
	NET_SIS_bag_extend *msg = (NET_SIS_bag_extend*)cmd;
	if (msg->dw_error_code == 0)
	{
		if(msg->n32_type == 0)
		{//包裹
			_conSize[EICT_Bag] = msg->n16BagNum;
			GET_UI(Package, WCT_PACKAGEUI)->updateData();
		}
		else if(msg->n32_type == 1)
		{//仓库
			_conSize[EICT_RoleWare] = msg->n16BagNum;
			GET_UI(Storage, WCT_StorageUi)->updateData();
		}
	}
	return 0;
}

//扩展背包 背包扩展 扩展仓库 仓库扩展
void PackageManager::doAddBlank( int type, int addNum)
{
	if(!isInit())
		return;

	if(getUiNode(WCT_MessageBox) != NULL)
		return;

	if(type == 0)
	{//包裹
		int curCount = _conSize[EICT_Bag];
		int minNum = curCount - 29;
		int maxNum = curCount + addNum - 30;
		int needItemCount = ( minNum + maxNum ) * ( addNum ) / 2;
		f_item *item = PackageManager::getInstance()->getItem(EICT_Bag, (unsigned int)PACKAGE_EXTEND_ITEM);
		if(item != NULL && item->get_item_number() >= needItemCount)
		{
			std::ostringstream ostr;
			ostr << needItemCount;
			const ItemTypeData &itemData = PackageManager::getInstance()->getItemTypeData(PACKAGE_EXTEND_ITEM);
			std::string str = replaceStr(GET_STR(74), "***", ostr.str());
			str = replaceStr(str, "**", itemData.name);
			MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
			messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::useItemToExpendPackage);
		}
		else
		{
			INT64 n64Diamond = getDiamond(); //获取钻石
			INT64 n64YuanBao = getYuanBao(); //获取元宝
			//if(n64Diamond >= needItemCount)//优先考虑钻石
			//{
			//	std::ostringstream ostr;
			//	ostr << needItemCount;
			//	std::string str = replaceStr(GET_STR(74), "***", ostr.str());
			//	MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			//	World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
			//	messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::useYuanbaoToExpendPackage);
			//}
			//else if(n64YuanBao >= needItemCount)//再考虑元宝
			//{
			//	std::ostringstream ostr;
			//	ostr << needItemCount;
			//	std::string str = replaceStr(GET_STR(74), "***", ostr.str());
			//	MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			//	World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
			//	messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::useYuanbaoToExpendPackage);
			//}
			if (n64Diamond + n64YuanBao >= needItemCount)
			{
				_addNum = addNum;
				std::ostringstream ostr;
				ostr << needItemCount;
				std::string str = replaceStr(GET_STR(74), "***", ostr.str());
				MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
				World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
				messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::useYuanbaoToExpendPackage);
			}
			else//元宝与礼券不足
			{
				std::ostringstream ostr;
				ostr << needItemCount;
				std::string str = replaceStr(GET_STR(74), "***", ostr.str());
				std::ostringstream ostr1;
				ostr1 << str << GET_STR(164);
				/*MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,ostr1.str().c_str(), TEXT_UTF8_CHONGZHI, TEXT_UTF8_QUXIAO);
				World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
				messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::ToCharge);*/
				RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
			}
		}
	}
	else if(type == 1)
	{//仓库
		int curCount = getConSize(EICT_RoleWare);
		int minNum = curCount - 29;
		int maxNum = curCount + addNum - 30;
		int needItemCount = ( minNum + maxNum ) * ( addNum ) / 2;
		f_item *item = PackageManager::getInstance()->getItem(EICT_RoleWare, (unsigned int)PACKAGE_EXTEND_ITEM);
		if(item != NULL && item->get_item_number() >= needItemCount)
		{
			std::ostringstream ostr;
			ostr << needItemCount;
			const ItemTypeData &itemData = PackageManager::getInstance()->getItemTypeData(PACKAGE_EXTEND_ITEM);
			std::string str = replaceStr(GET_STR(74), "***", ostr.str());
			str = replaceStr(str, "**", itemData.name);
			MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
			messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::useItemToExpendStorage);
		}
		else
		{
			INT64 n64Diamond = getDiamond(); //获取钻石
			INT64 n64YuanBao = getYuanBao(); //获取元宝
			//if(n64Diamond >= needItemCount)//优先考虑钻石
			//{
			//	std::ostringstream ostr;
			//	ostr << needItemCount;
			//	std::string str = replaceStr(GET_STR(74), "***", ostr.str());
			//	MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			//	World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
			//	messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::useYuanbaoToExpendStorage);
			//}
			//else if(n64YuanBao >= needItemCount)//再考虑元宝
			//{
			//	std::ostringstream ostr;
			//	ostr << needItemCount;
			//	std::string str = replaceStr(GET_STR(74), "***", ostr.str());
			//	MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			//	World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
			//	messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::useYuanbaoToExpendStorage);
			//}
			if (n64Diamond + n64YuanBao >= needItemCount)
			{
				_addNum = addNum;
				std::ostringstream ostr;
				ostr << needItemCount;
				std::string str = replaceStr(GET_STR(74), "***", ostr.str());
				MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, str.c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
				World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
				messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::useYuanbaoToExpendStorage);
			}

			else//元宝与礼券不足
			{
				std::ostringstream ostr;
				ostr << needItemCount;
				std::string str = replaceStr(GET_STR(74), "***", ostr.str());
				std::ostringstream ostr1;
				ostr1 << str << GET_STR(164);
				/*MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,ostr1.str().c_str(), TEXT_UTF8_CHONGZHI, TEXT_UTF8_QUXIAO);
				World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
				messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::ToCharge);*/
				RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
			}
		}
	}
}

int PackageManager::getFitIndex(EItemConType con)
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		int size = getConSize(con);
		for (int index = 0;index < size; ++index)
		{
			ItemMap::iterator iter = itemMap->find(index);
			if (iter == itemMap->end())
			{
				return index;
			}
		}
	}
	return -1;
}

void PackageManager::useItemToExpendStorage()
{
	f_item *item = getItem(EICT_Bag, (unsigned int)PACKAGE_EXTEND_ITEM);
	if(item != NULL)
	{
		//extendPackage(item->get_item_id(), 1);
	}
}

void PackageManager::useYuanbaoToExpendStorage()
{
	extendPackage(-1, 1);
}

// unsigned int PackageManager::onRongYuChange( s_net_cmd *cmd )
// {
// 	NET_SIS_exploits* msg = (NET_SIS_exploits*)cmd;
// 	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 	if(!ploc)
// 		return 0;
// 	ploc->setAttribute(RA_RONGYU_POINT,msg->n32CurExploits);
// 	//TODO:调用UI刷新
// 	GET_UI(StoreUi,WCT_STOREUI)->updateRongyu();
// 	//给提示
// 	{
// 		s_receive_chat_info info;
// 		info.send_channel = ESCC_System;
// 		std::stringstream ss;
// 		std::string str;
// 		//获得荣誉点
// 		if (msg->n32ChangeExploits >= 0)
// 		{
// 			ss<<msg->n32ChangeExploits;
// 			str = replaceStr(GET_STR(2125),"**",ss.str());
// 		}
// 		//失去
// 		else
// 		{
// 			ss<<(-msg->n32ChangeExploits);
// 			str = replaceStr(GET_STR(2127),"**",ss.str());
// 		}
// 		info.chat_text = str;
// 		ChatMgr::getInstance()->ShowInfoByChatChannel(info);
// 	}
// 	return 0;
// }

unsigned int PackageManager::onKeyInfo( s_net_cmd *cmd )
{
	// 	NET_SIS_key_info *msg = (NET_SIS_key_info*)cmd;
	// 	//GET_UI(ShortCutUi, WCT_ShorCutUi)->setMedicineId(msg->stKeyInfo.hpID);
	// 	//GET_UI(ShortCutUi, WCT_ShorCutUi)->setRandTransId(msg->stKeyInfo.traID);
	// 
	return 0;
}

void PackageManager::sendShortKeyInfo()
{
	NET_SIC_modify_key_info cmd;
	cmd.stKeyInfo.hpID = GET_UI(ShortCutUi, WCT_ShorCutUi)->getMedicineId();
	cmd.stKeyInfo.traID = GET_UI(ShortCutUi, WCT_ShorCutUi)->getRandTransId();
	TCP_CLIENT->send_net_cmd(&cmd, NP_INSIGNIFICANT, true);
}

int PackageManager::getBlankSpace( EItemConType con )
{
	ItemMap *itemMap = getItemMap(con);
	if(itemMap != NULL)
	{
		int bagSize = getConSize(con); //这里不知道为啥写死用背包大小去检查所有容器 EICT_Bag add by XSea 2014.10.07
		for(int i = 0; i < bagSize; i ++)
		{
			ItemMap::iterator iter = itemMap->find(i);
			if(iter == itemMap->end())
				return i;
		}
	}
	return -1;
}

unsigned int PackageManager::onUnBeset( s_net_cmd *cmd )
{
	NET_SIS_unbeset *msg = (NET_SIS_unbeset*)cmd;
	if (0 == msg->dw_error_code)
	{
		GET_UI(InlayUi, WCT_InlayUi)->onServerUnInlay(msg->dw_error_code == 0);
	}
	else
	{
		if (E_Unbeset_Not_bag_free == msg->dw_error_code)
		{
			ToolTip::getInstance()->push(GET_STR(161));
			GET_UI(InlayUi, WCT_InlayUi)->onServerUnInlay(false);
		}
	}
	return 0;
}

void PackageManager::lockItem( EItemConType conType, short index, bool u )
{
	f_item *item = getItem(conType, index);
	if(item != NULL)
	{
		item->lock();
	}

	if(u)
	{
		updateUiWithConType(conType);
	}
}

void PackageManager::lockItem( EItemConType conType, INT64 id, bool u /*= true*/ )
{
	f_item *item = getItem(conType, id);
	if(item != NULL)
	{
		item->lock();
	}
	if(u)
	{
		updateUiWithConType(conType);
	}
}

void PackageManager::lockItem( EItemConType conType, bool u )
{
	ItemMap *itemMap = getItemMap(conType);
	if(itemMap != NULL)
	{
		for(ItemMap::iterator iter = itemMap->begin(); iter != itemMap->end(); ++ iter)
		{
			f_item *item = iter->second;
			if(item != NULL)
				item->lock();
		}
		if(u)
			updateUiWithConType(conType);

		_CurrentLockedConType = conType;
	}
}

void PackageManager::unLockItem( EItemConType conType, short index, bool u )
{
	f_item *item = getItem(conType, index);
	if(item != NULL)
	{
		item->unlock();
	}

	if(u)
	{
		updateUiWithConType(conType);
	}
}

void PackageManager::unLockItem( EItemConType conType, INT64 id, bool u /*= true*/ )
{
	f_item *item = getItem(conType, id);
	if(item != NULL)
	{
		item->unlock();
	}

	if(u)
	{
		updateUiWithConType(conType);
	}
}

void PackageManager::unLockItem( EItemConType conType /*= EICT_Bag*/, bool u )
{
	ItemMap *itemMap = getItemMap(conType);
	if(itemMap != NULL)
	{
		for(ItemMap::iterator iter = itemMap->begin(); iter != itemMap->end(); ++ iter)
		{
			f_item *item = iter->second;
			if(item != NULL)
			{
				item->unlock();
			}
		}
		if(u)
			updateUiWithConType(conType);

		_CurrentLockedConType = EICT_Null;
	}
}

void PackageManager::updateUiWithConType( EItemConType conType )
{
	switch(conType)
	{
	case EICT_Bag:
		GET_UI(Package, WCT_PACKAGEUI)->updateData();
		break;
	case EICT_RoleWare:
		GET_UI(Storage, WCT_StorageUi)->updateData();
		break;
	case EICT_Equip:
		GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI)->updateEquipment();
		GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI)->updateDisplay();
		GET_UI(RoleRingUi,WCT_ROLERINGUI)->updateEquipment();
		GET_UI(RoleRingUi,WCT_ROLERINGUI)->updateDisplay();
		GET_UI(MountUi, WCT_MountUi)->updateData();
		break;
	case EICT_KungfuWare:
		//UI刷新
		GET_UI(WuXueUi,WCT_WUXUEUI)->updateWare();
		break;
	case EICT_KungfuTemp:
		//UI刷新
		GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();
		break;
	case EICT_KungfuBag:
		//UI刷新
		GET_UI(WuXueUi,WCT_WUXUEUI)->updateMartialData();
		break;
	case EICT_KungfuEquip:
		//UI刷新
		GET_UI(WuXueUi,WCT_WUXUEUI)->updateEquip();
		break;
	case EICT_StallItem:
		//UI刷新
		GET_UI(NewStallUi,WCT_NEW_STALLUI)->UpdateStallItem();
		break;
	}
}

bool PackageManager::hasLockItem( EItemConType conType )
{
	ItemMap *itemMap = getItemMap(conType);
	if(itemMap != NULL)
	{
		for(ItemMap::iterator iter = itemMap->begin(); iter != itemMap->end(); ++iter)
		{
			f_item *item = iter->second;
			CC_ASSERT(item != NULL);
			if(item->is_locked())
				return true;
		}
	}

	return false;
}

void PackageManager::destoryCon( EItemConType conType )
{
	ItemMap *itemMap = getItemMap(conType);
	if(itemMap != NULL)
	{
		for(ItemMap::iterator iter = itemMap->begin(); iter != itemMap->end(); ++iter)
		{
			//delete iter->second;
			CC_SAFE_DELETE(iter->second);
		}
		itemMap->clear();
	}
}

void PackageManager::showErrorInfoByUseItem( unsigned int dwerror_code, INT64 n64ItemID )
{
	if (1000 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2058));
	}
	else if (1001 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2059));
	}
	else if (1002 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2060));
	}
	else if (1003 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2061));
	}
	else if (1004 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2062));
	}
	else if (1005 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2063));
	}
	else if (1006 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2064));
	}
	else if (1007 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2065));
	}
	else if (1008 == dwerror_code)//公会限制
	{
		ToolTip::getInstance()->push(GET_STR(2090));
	}
	else if (1009 == dwerror_code)//您正处于多倍经验状态中
	{
		//ToolTip::getInstance()->push(GET_STR(2097));
		setLastUseItem(n64ItemID);
		CCScene* scene = World::getInstance()->getScene();
		if (scene)
		{
			MessageBoxUi *msgUi = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,STRING_TABLE["Is_CoerceUse"], TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO);
			scene->addChild(msgUi, WZ_MESSAGEBOX);
			msgUi->signalOkBtnPressed.connect(this, &PackageManager::confirmCoerceUseItem);
		}

	}
	else if (1010 == dwerror_code)//背包空间不足
	{
		ToolTip::getInstance()->push(GET_STR(161));
	}
	else if (1011 == dwerror_code)//两个或两个以上宝石才能够进行高级合成
	{
		ToolTip::getInstance()->push(GET_STR(2104));
	}
	else if (1012 == dwerror_code)//VIP道具重复使用
	{
		ToolTip::getInstance()->push(GET_STR(2105));
	}
	else if (1013 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2106));
	}
	else if (1014 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2107));
	}
	else if (1015 == dwerror_code)//技能书
	{
		ToolTip::getInstance()->push(GET_STR(2111));
	}
	else if (1016 == dwerror_code)//技能书
	{
		ToolTip::getInstance()->push(GET_STR(2112));
	}
	else if (1017 == dwerror_code)//道具场景限制
	{
		ToolTip::getInstance()->push(GET_STR(2113));
	}
	else if (1018 == dwerror_code)//好人卡
	{
		ToolTip::getInstance()->push(GET_STR(7152));
	}
	else if (1020 == dwerror_code)//行会回城卷
	{
		ToolTip::getInstance()->push(GET_STR(2154));
	}
	else if (1021 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2171));
	}
	else if (1022 == dwerror_code)//抱歉，您现在没有伴侣，不能传送
	{
		ToolTip::getInstance()->push(GET_STR(2180));
	}
	else if (1023 == dwerror_code)//您的伴侣目前不在线，不能飞到他的身边
	{
		ToolTip::getInstance()->push(GET_STR(2181));
	}
	else if (1024 == dwerror_code)//抱歉，您伴侣所在地图，不支持传送功能
	{
		ToolTip::getInstance()->push(GET_STR(2182));
	}
	else if (1025 == dwerror_code)//您的坐骑已经到达满级了，无法喂养
	{
		ToolTip::getInstance()->push(GET_STR(2197));
	}
	else if (1026 == dwerror_code)//该地图禁止使用传送功能
	{
		ToolTip::getInstance()->push(GET_STR(2208));
	}
	else if (1027 == dwerror_code)//元宝不足，请充值购买钥匙	
	{
		//ToolTip::getInstance()->push(GET_STR(2211));
		RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
	}
	else if (1028 == dwerror_code)//元宝或礼券不足，请充值购买钥匙	
	{
		ToolTip::getInstance()->push(GET_STR(2212));
	}
	else if (1029 == dwerror_code)//请前往指定地图，召唤BOSS
	{
		ToolTip::getInstance()->push(GET_STR(2213));
	}
	else if (1030 == dwerror_code)//开启宝箱，空间不足
	{
		ToolTip::getInstance()->push(GET_STR(2223));
	}
	else if (1031 == dwerror_code)//大力丸提示
	{
		ToolTip::getInstance()->push(GET_STR(2227));
	}
	else if (1032 == dwerror_code)//饲料
	{
		ToolTip::getInstance()->push(GET_STR(2232));
	}
	else if (1033 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2108));
	}
	else if (1034 == dwerror_code)
	{
		//ToolTip::getInstance()->push(GET_STR(2339));
		RechargeNewUiMgr::GetInstance()->openRechargeNewUi();
	}
	else if (1035 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2349));//11个格子
	}
	else if (1036 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2350));//12个格子
	}
	else if (1037 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2351));//13个格子
	}
	else if (1038 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2352));//14个格子
	}
	else if (1039 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2353));//15个格子
	}
	//称号
	else if (1040 == dwerror_code)
	{
		ToolTip::getInstance()->push(GET_STR(2364));//称号重复
	}
	else if( 1041 == dwerror_code ) //功法
	{
		ToolTip::getInstance()->push(GET_STR(7134));//功法背包空间不足
	}
	else if (32 == dwerror_code)//该物品不可使用
	{
		ToolTip::getInstance()->push(GET_STR(2066));
	}
	else if (33 == dwerror_code)//冷却时间未到
	{
		ToolTip::getInstance()->push(GET_STR(2067));
	}
	else if (38 == dwerror_code)//人物死亡或在骑乘中
	{
		ToolTip::getInstance()->push(GET_STR(2068));
	}
	else if (34 == dwerror_code)//性别不满足，无法使用
	{
		ToolTip::getInstance()->push(GET_STR(2069));
	}
	else if (35 == dwerror_code)//等级不满足，无法使用
	{
		ToolTip::getInstance()->push(GET_STR(2070));
	}
	else if (44 == dwerror_code)//角色状态受限，
	{
		ToolTip::getInstance()->push(GET_STR(2068));
	}
	else if (39 == dwerror_code)//角色状态受限，
	{
		ToolTip::getInstance()->push(GET_STR(2067));
	}
	else if (1041 == dwerror_code)//职业不符合，不能使用此道具。
	{
		ToolTip::getInstance()->push(GET_STR(7006));
	}
	else if (1042 == dwerror_code)//您已经学会此技能。
	{
		ToolTip::getInstance()->push(GET_STR(7007));
	}
	else if (47 == dwerror_code)//无法在该地图使用道具。
	{
		ToolTip::getInstance()->push(GET_STR(7242));
	}
	else if (2151 == dwerror_code)//无法在该地图使用道具。
	{
		ToolTip::getInstance()->push(GET_STR(2151));
	}	
	else if (77 == dwerror_code)
	{
		ToolTip::getInstance()->push(STRING_TABLE["xzdd_item_limit"]);
	}
	else if(78 == dwerror_code)
	{
		ToolTip::getInstance()->push(STRING_TABLE["xzdd_item_limit_trans"]);
	}
	else 
	{
		ToolTip::getInstance()->push(GET_STR(dwerror_code));
	}
}

void PackageManager::ToCharge()
{
	//#ifndef WIN32
	//	WzolJni::getInstance()->payJni();
	//#endif
	OPEN_UI(WCT_ChongZhiActivityFarmeUI);
}

void PackageManager::showSpecialInfoByUseItem(unsigned int typeID,unsigned int roleID)
{
	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
	if(!ploc)
		return;
	//仅对本地玩家使用的物品给予提示
	if (roleID != ploc->getId())
		return;

	switch(typeID)
	{
	case 1400061://玉如意
		ToolTip::getInstance()->push(GET_STR(2110));
		break;
	case ZZZTITLEZHAN:
	case ZZZTITLEFA:
	case ZZZTITLEDAO:  
	case ZZZFLYDRAGON:
	case ZZZMANOR:
	case ZZZSIGN:    //主宰者特殊道具
		{
			ZZZAcquireLayer* node = ZZZAcquireLayer::getInstance()->open();
			node->setData(typeID);
		}
		break;
	default:
		break;
	}
}

//使用祝福油结果
unsigned int PackageManager::onEquipLuckChange( s_net_cmd *cmd )
{
	NET_SIS_use_luck_you* msg = (NET_SIS_use_luck_you*)cmd;

	use_oil_return_event event;
	event.is_success = (0 == msg->dw_error_code);
	SEND_EVENT(&event);

	if (0 != msg->dw_error_code)
		return 0;
	int index = 0;
	std::string str = "";
	if (1 == msg->ch_ChangeLuck)//幸运增加
	{
		index = 2132;
		std::ostringstream ss;
		ss<<(int)msg->ch_CurLuck;
		str = replaceStr(GET_STR(index),"**",ss.str());
	}
	else if (0 == msg->ch_ChangeLuck)//幸运不变
	{
		index = 2133;
		str = GET_STR(index);
	}
	else if (-1 == msg->ch_ChangeLuck)//幸运减少
	{
		index = 2134;
		std::ostringstream ss;
		ss<<(int)msg->ch_CurLuck;
		str = replaceStr(GET_STR(index),"**",ss.str());
	}
	else
	{
		return 0;
	}
	ToolTip::getInstance()->push(str);
	return 0;
}

bool PackageManager::isValidItem( unsigned int typeId )
{
	const ItemTypeData &itemTypeData = getItemTypeData(typeId);
	if(itemTypeData.type == PIT_INVALID)
		return false;

	return true;
}

unsigned int PackageManager::onLeranSkillInfo( s_net_cmd *cmd )
{
	NET_SIS_learn_skill* msg = (NET_SIS_learn_skill*)cmd;
	if (0 == msg->dw_error_code)
	{

		OPEN_UI(WCT_SKILLUI);
		std::string str = GET_STR(2153)+SkillManager::getInstance()->getSkillNameByID(msg->dwSkillID);
		ToolTip::getInstance()->push(str);
	}
	else
	{
		switch (msg->dw_error_code)
		{
		case E_Item_LevelLimit://等级不符，高或低
			ToolTip::getInstance()->push(GET_STR(2149));
			break;
		case E_LearnSkill_Existed://技能已存在
			ToolTip::getInstance()->push(GET_STR(2150));
			break;
			//case E_LearnSkill_NeedMoreLevel://等级不足
			//	break;
		case E_LearnSkill_ClassLimit://职业不符
			ToolTip::getInstance()->push(GET_STR(2151));
			break;
		case E_LearnSkill_NoPreSkill://前置技能
			ToolTip::getInstance()->push(GET_STR(2416));
			break;
		}

		SkillManager::getInstance()->SetCurIndex(0);
	}
	return 0;
}

void PackageManager::roleGetEquip( f_equipment* equip ,int posIndex)
{
	if (!equip)
		return;
	_srcEquip = equip;
	if(MIsEquipment(_srcEquip->get_item_type_id()))
	{
		//如果是戒指或护腕，则找到一个空位或低级别的替换
		if(posIndex == EEP_Finger1 || posIndex == EEP_Wrist1)
		{
			f_item *equipItem1 = PackageManager::getInstance()->getItem(EICT_Equip, (short)posIndex);
			f_item *equipItem2 = PackageManager::getInstance()->getItem(EICT_Equip, (short)(posIndex + 1));
			if(equipItem1 != NULL)
			{
				if(equipItem2 == NULL)
				{
					posIndex += 1;
				}
				else
				{
					f_equipment* equipTypeData1 = dynamic_cast<f_equipment*>(equipItem1);
					f_equipment* equipTypeData2 = dynamic_cast<f_equipment*>(equipItem2);
					if(equipTypeData1->get_equip()->nRating > equipTypeData2->get_equip()->nRating)
						posIndex += 1;
				}
			}
		}
		_descEquip = dynamic_cast<f_equipment*>(getItem(EICT_Equip, (short)posIndex));//身上相应位置的装备
		replace_jewel(_srcEquip,_descEquip);
// 		if(MIsEquipment(equip->get_item_type_id()))
// 		{
// 			if((_descEquip != NULL)&&(_descEquip->get_equip_gem_num() > 0)&&(_srcEquip->get_equip_gem_num() == 0)&&(_srcEquip->get_equip_max_hole_num() != 0))
// 			{
// 				const EquipTypeData&srcEquipData = getEquipTypeData(_srcEquip->get_item_type_id());
// 				const EquipTypeData&descEquipData = getEquipTypeData(_descEquip->get_item_type_id());
// 				string srcProfession = srcEquipData.profession.substr(0, srcEquipData.profession.size() - 6);//这里减6是因为只有减6才能够成功判断职业
// 				string descProfession = descEquipData.profession.substr(0, descEquipData.profession.size() - 6);
// 				if((srcEquipData.posIndex == descEquipData.posIndex) && (srcProfession == descProfession))//职业相同则替换，职业不同则不替换
// 				{
// 					bool canInlay = false;
// 					for(int i = 0; i < _descEquip->get_equip_max_hole_num(); ++i)//判断目标装备上是否有合适的宝石，如果有则镶嵌，否则不镶嵌
// 					{
// 						unsigned int typeId = _descEquip->get_equip_hold_gem_id(i);
// 						const ItemTypeData& gem = getItemTypeData(typeId);
// 						if(gem.special_value_1 <= srcEquipData.jewel_limit)
// 						{
// 							canInlay = true;
// 							break;
// 						}
// 					}
// 					if(canInlay)
// 					{
// 						MessageBoxUi *repairSignUI = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, TEXT_UTF8_REPLACETEXT, TEXT_UTF8_REPLACE,TEXT_UTF8_NOREPLACE);
// 						World::getInstance()->getScene()->addChild(repairSignUI, WZ_MESSAGEBOX);
// 						repairSignUI->signalOkBtnPressed.connect(this,&PackageManager::replaceGem);
// 						repairSignUI->signalCancelBtnPressed.connect(this,&PackageManager::changePositionForDressEquip);
// 					}
// 					else
// 					{
// 						changePositionForDressEquip();
// 					}
// 				}
// 			}
// 			else
// 			{
// 				changePositionForDressEquip();
// 			}
// 		}
	}
	if (PackageManager::getInstance()->GetIsImmediateEqui())
	{
		PackageManager::getInstance()->SetIsImmediateEqui(false);
	}
}

bool PackageManager::canAutoEquip( unsigned int typeID )
{
	for (size_t i = 0;i < autoequipidarr.size();i++)
	{
		if (typeID == autoequipidarr[i])
		{
			return true;
		}
	}
	return false;
}

void PackageManager::equipRide( INT64 equipId )
{
	f_item *item = getItem(EICT_Bag, equipId);
	if(item != NULL && !item->is_locked())
	{
		LocalPlayer *lp = RoleManager::getInstance()->getLocalPlayer();
		RoleManager::RideModeData rideModeData = RoleManager::getInstance()->getRideModeData(item->get_item_type_id(), lp->getAttribute(RA_SEX));
		if(rideModeData.lvl > lp->getRideLv())
		{
			int nStep,nGrade;
			VLevel2StepGrade(rideModeData.lvl,nStep,nGrade);
			std::ostringstream ostr;
			ostr.str("");
			ostr << nStep;
			std::string strBasic = replaceStr(GET_STR(2202),"**",ostr.str());
			ToolTip::getInstance()->push(strBasic, 1);
			return;
		}

		NET_SIC_Equip_ride cmd;
		cmd.n64RideSerial = equipId;
		TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, true);
		lockItem(EICT_Bag, equipId, true);
	}
}

void PackageManager::unEquipRide( INT64 equipId )
{
	f_item *item = getItem(EICT_Equip, equipId);
	if(item != NULL && !item->is_locked())
	{
		NET_SIC_UnEquip_ride cmd;
		cmd.n64RideSerial = equipId;
		TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, true);
		lockItem(EICT_Equip, equipId, true);
		RoleManager::getInstance()->syncRideData();
	}
}

unsigned int PackageManager::onEquipRide( s_net_cmd *cmd )
{
	//NET_SIS_Equip_ride *msg = (NET_SIS_Equip_ride*)cmd;
	updateUiWithConType(EICT_Bag);
	updateUiWithConType(EICT_Equip);
	return 0;
}

unsigned int PackageManager::onUnEquipRide( s_net_cmd *cmd )
{
	//NET_SIS_UnEquip_ride *msg = (NET_SIS_UnEquip_ride*)cmd;
	updateUiWithConType(EICT_Bag);
	updateUiWithConType(EICT_Equip);
	return 0;
}
//bAuto为true代表自动开宝箱，不需要提示
// bool PackageManager::openKenXiang(f_item *item,bool bAuto /* = false */)
// {
// 	if (!item)
// 		return true;
// 	bool bKen = false;
// 	int n_NeedYuanbao = 0;//开启宝箱需要的元宝数
// 	int n_NeedLiQuan = 0;//开启宝箱需要的礼券数
// 	unsigned int n_NeedItemTypeID = (unsigned int)INVALID;//开启宝箱需要的钥匙类型
// 	if(_canUseItem)
// 	{
// 		if (1300036 == item->get_item_type_id())//木匣子
// 		{
// 			n_NeedYuanbao = 10;
// 			n_NeedLiQuan = 10;
// 			n_NeedItemTypeID = (unsigned int)INVALID;
// 			bKen = true;
// 		}
// 		else if (1300022 == item->get_item_type_id())//铜宝箱
// 		{
// 			n_NeedYuanbao = 10;
// 			n_NeedItemTypeID = (unsigned int)BOX_KEY_COPPER;//铜钥匙
// 			bKen = true;
// 		}
// 		else if (1300023 == item->get_item_type_id())//银宝箱
// 		{
// 			n_NeedYuanbao = 20;
// 			n_NeedItemTypeID = (unsigned int)BOX_KEY_SLIVER;//银钥匙
// 			bKen = true;
// 		}
// 		else if (1300024 == item->get_item_type_id())//金宝箱
// 		{
// 			n_NeedYuanbao = 30;
// 			n_NeedItemTypeID = (unsigned int)BOX_KEY_GOLD;//金钥匙
// 			bKen = true;
// 		}
// 		else if (1300037 == item->get_item_type_id())//至尊宝箱
// 		{
// 			n_NeedYuanbao = 50;
// 			n_NeedItemTypeID = (unsigned int)BOX_KEY_SUPER;//至尊钥匙
// 			bKen = true;
// 		}
// 		else
// 		{
// 			bKen = false;
// 			return bKen;
// 		}
// 		if (n_NeedLiQuan > 0)//若是可以礼券开启的
// 		{
// 			if (((getBangDingYuanBao() < n_NeedLiQuan)) && (getYuanBao() < n_NeedYuanbao))
// 			{
// 				MessageBoxUi *ui = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,GET_STR(2365).c_str(), TEXT_UTF8_CHONGZHI,TEXT_UTF8_QUXIAO);
// 				World::getInstance()->getScene()->addChild(ui, WZ_MESSAGEBOX);
// 				ui->signalOkBtnPressed.connect(this, &PackageManager::ToCharge);
// 				ui->signalCancelBtnPressed.connect(this,&PackageManager::ToCancel);
// 				return bKen;
// 			}
// 		}
// 		else //仅可以元宝开启,在这里才会体现钥匙的作用
// 		{
// 			
// 			int keyNum = getItemNumber(EICT_Bag,n_NeedItemTypeID);//首先获得玩家背包中对应钥匙的数量
// 			if ((getYuanBao() < n_NeedYuanbao) && (keyNum <= 0))//元宝不足，同时钥匙也没有
// 			{
// 				ostringstream oss;
// 				oss<< n_NeedYuanbao;
// 				std::string strTmp = replaceStr(GET_STR(2366),"**",oss.str());
// 				MessageBoxUi *ui = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,strTmp.c_str(), TEXT_UTF8_CHONGZHI,TEXT_UTF8_QUXIAO);
// 				World::getInstance()->getScene()->addChild(ui, WZ_MESSAGEBOX);
// 				ui->signalOkBtnPressed.connect(this, &PackageManager::ToCharge);
// 				ui->signalCancelBtnPressed.connect(this,&PackageManager::ToCancel);
// 				return bKen;
// 			}
// 		}
// 		_TempItem = item;
// 		LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 		if(!ploc)
// 			return bKen;
// 		unsigned int roleID = ploc->getId();
// 		std::stringstream ss;
// 		ss<<"set"<<"_"<<roleID;
// 		//玩家元宝或礼券足够，要给消费二次确认
// 		if (1300036 == item->get_item_type_id())//木匣子
// 		{
// 			int tip = ClientCfg::getInstance()->getInt(ss.str(), "mxzTip", 0);
// 			if (tip != 0)
// 			{
// 				normalUseBagItem();
// 			}
// 			else 
// 			{
// 				MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtnWithCheck(GET_STR(2214).c_str(), GET_STR(98).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO, false);
// 				messageBox->signalOkBtnPressed.connect(this, &PackageManager::normalUseBagItem);
// 				messageBox->signalCheckStateChange.connect(this, &PackageManager::togMxzTip);
// 				messageBox->signalCancelBtnPressed.connect(this,&PackageManager::ToCancel);
// 				World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 			}
// 		}
// 		else if (1300022 == item->get_item_type_id())//铜宝箱
// 		{
// 			//自动开宝箱不需要给提示的
// 			if (bAuto)
// 			{
// 				normalUseBagItem();
// 			}
// 			else
// 			{
// 				int tip = ClientCfg::getInstance()->getInt(ss.str(), "tbxTip", 0);
// 				if (tip != 0)
// 				{
// 					normalUseBagItem();
// 				}
// 				else
// 				{
// 					MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtnWithCheck(GET_STR(2215).c_str(), GET_STR(98).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO, false);
// 					messageBox->signalOkBtnPressed.connect(this, &PackageManager::normalUseBagItem);
// 					messageBox->signalCheckStateChange.connect(this, &PackageManager::togTbxTip);
// 					messageBox->signalCancelBtnPressed.connect(this,&PackageManager::ToCancel);
// 					World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 				}
// 			}
// 		}
// 		else if (1300023 == item->get_item_type_id())//银宝箱
// 		{
// 			if (bAuto)
// 			{
// 				normalUseBagItem();
// 			}
// 			else
// 			{
// 				int tip = ClientCfg::getInstance()->getInt(ss.str(), "ybxTip", 0);
// 				if (tip != 0)
// 				{
// 					normalUseBagItem();
// 				}
// 				else
// 				{
// 					MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtnWithCheck(GET_STR(2216).c_str(), GET_STR(98).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO, false);
// 					messageBox->signalOkBtnPressed.connect(this, &PackageManager::normalUseBagItem);
// 					messageBox->signalCheckStateChange.connect(this, &PackageManager::togYbxTip);
// 					messageBox->signalCancelBtnPressed.connect(this,&PackageManager::ToCancel);
// 					World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 				}
// 			}
// 		}
// 		else if (1300024 == item->get_item_type_id())//金宝箱
// 		{
// 			if (bAuto)
// 			{
// 				normalUseBagItem();
// 			}
// 			else
// 			{
// 				int tip = ClientCfg::getInstance()->getInt(ss.str(), "jbxTip", 0);
// 				if (tip != 0)
// 				{
// 					normalUseBagItem();
// 				}
// 				else
// 				{
// 					MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtnWithCheck(GET_STR(2217).c_str(), GET_STR(98).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO, false);
// 					messageBox->signalOkBtnPressed.connect(this, &PackageManager::normalUseBagItem);
// 					messageBox->signalCheckStateChange.connect(this, &PackageManager::togJbxTip);
// 					messageBox->signalCancelBtnPressed.connect(this,&PackageManager::ToCancel);
// 					World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 				}
// 			}
// 			
// 		}
// 		else if (1300037 == item->get_item_type_id())//至尊宝箱
// 		{
// 			if (bAuto)
// 			{
// 				normalUseBagItem();
// 			}
// 			else
// 			{
// 				int tip = ClientCfg::getInstance()->getInt(ss.str(), "zzbxTip", 0);
// 				if (tip != 0)
// 				{
// 					normalUseBagItem();
// 				}
// 				else
// 				{
// 					MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtnWithCheck(GET_STR(2218).c_str(), GET_STR(98).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO, false);
// 					messageBox->signalOkBtnPressed.connect(this, &PackageManager::normalUseBagItem);
// 					messageBox->signalCheckStateChange.connect(this, &PackageManager::togZzbxTip);
// 					messageBox->signalCancelBtnPressed.connect(this,&PackageManager::ToCancel);
// 					World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 				}
// 			}
// 		}
// 		else
// 		{
// 			return bKen;
// 		}
// 		
// 	}
// 	return bKen;
// }
// void PackageManager::OpenBoxForSure(f_item* pItem)
// {
// 	if(!pItem)
// 		return;
// 	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 	if(!ploc)
// 		return;
// 	unsigned int roleID = ploc->getId();
// 	std::stringstream ss;
// 	ss<<"set"<<"_"<<roleID;
// 	unsigned int typeID = pItem->get_item_type_id();
// 	if (1400153 == typeID)//100倍返利礼包
// 	{
// 		//先检查元宝
// 		if (getYuanBao() < 1)
// 		{
// 			ostringstream oss;
// 			oss<< 1;
// 			std::string strTmp = replaceStr(GET_STR(2367),"**",oss.str());
// 			MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,strTmp.c_str(), TEXT_UTF8_CHONGZHI, TEXT_UTF8_QUXIAO);
// 			World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 			messageBox->signalOkBtnPressed.connect(PackageManager::getInstance(), &PackageManager::ToCharge);
// 			return;
// 		}
// 		_TempItem = pItem;
// 		int tip = ClientCfg::getInstance()->getInt(ss.str(), "boxsureTip", 0);
// 		if (tip != 0)
// 		{
// 			normalUseBagItem();
// 		}
// 		else
// 		{
// 			MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtnWithCheck(GET_STR(2348).c_str(), GET_STR(98).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO, false);
// 			messageBox->signalOkBtnPressed.connect(this, &PackageManager::normalUseBagItem);
// 			messageBox->signalCheckStateChange.connect(this, &PackageManager::togBoxForSureTip);
// 			World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
// 		}
// 	}
// 	else 
// 	{
// 		//do nothing
// 	}
// }
// void PackageManager::togMxzTip( bool state )
// {
// 	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 	if(!ploc)
// 		return ;
// 	unsigned int roleID = ploc->getId();
// 	std::stringstream ss;
// 	ss<<"set"<<"_"<<roleID;
// 	ClientCfg::getInstance()->setInt(ss.str(), "mxzTip", state ? 1 : 0);
// }

// void PackageManager::togTbxTip( bool state )
// {
// 	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 	if(!ploc)
// 		return ;
// 	unsigned int roleID = ploc->getId();
// 	std::stringstream ss;
// 	ss<<"set"<<"_"<<roleID;
// 	ClientCfg::getInstance()->setInt(ss.str(), "tbxTip", state ? 1 : 0);
// }

// void PackageManager::togYbxTip( bool state )
// {
// 	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 	if(!ploc)
// 		return ;
// 	unsigned int roleID = ploc->getId();
// 	std::stringstream ss;
// 	ss<<"set"<<"_"<<roleID;
// 	ClientCfg::getInstance()->setInt(ss.str(), "ybxTip", state ? 1 : 0);
// }

// void PackageManager::togJbxTip( bool state )
// {
// 	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 	if(!ploc)
// 		return ;
// 	unsigned int roleID = ploc->getId();
// 	std::stringstream ss;
// 	ss<<"set"<<"_"<<roleID;
// 	ClientCfg::getInstance()->setInt(ss.str(), "jbxTip", state ? 1 : 0);
// }

// void PackageManager::togZzbxTip( bool state )
// {
// 	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 	if(!ploc)
// 		return ;
// 	unsigned int roleID = ploc->getId();
// 	std::stringstream ss;
// 	ss<<"set"<<"_"<<roleID;
// 	ClientCfg::getInstance()->setInt(ss.str(), "zzbxTip", state ? 1 : 0);
// }
// void PackageManager::togBoxForSureTip(bool state)
// {
// 	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
// 	if(!ploc)
// 		return ;
// 	unsigned int roleID = ploc->getId();
// 	std::stringstream ss;
// 	ss<<"set"<<"_"<<roleID;
// 	ClientCfg::getInstance()->setInt(ss.str(), "boxsureTip", state ? 1 : 0);
// }
//单次功法融合二次提示,从背包到功法装备栏
void PackageManager::toSignleMergeTIp(bool bState)
{
	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
	if(!ploc)
		return ;
	unsigned int roleID = ploc->getId();
	std::stringstream ss;
	ss<<"set"<<"_"<<roleID;
	ClientCfg::getInstance()->setInt(ss.str(), "b2ekfmTip", bState ? 1 : 0);
}
void PackageManager::toSignleMergeInBagTip(bool bState)
{
	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
	if(!ploc)
		return ;
	unsigned int roleID = ploc->getId();
	std::stringstream ss;
	ss<<"set"<<"_"<<roleID;
	ClientCfg::getInstance()->setInt(ss.str(), "b2bkfmTip", bState ? 1 : 0);
}
//功法自动融合的二次提示
void PackageManager::toAutoMergeTip(bool bState)
{
	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
	if(!ploc)
		return ;
	unsigned int roleID = ploc->getId();
	std::stringstream ss;
	ss<<"set"<<"_"<<roleID;
	ClientCfg::getInstance()->setInt(ss.str(), "akfmTip", bState ? 1 : 0);
}
void PackageManager::normalUseBagItem()
{
	if (_canUseItem)
	{
		if(!_TempItem)
			return;
		NET_SIC_use_item cmd;
		LocalPlayer *role = RoleManager::getInstance()->getLocalPlayer();
		if (!role)
			return;
		CCPoint pos = role->getPosition();
		cmd.vSrcPos[0] = pos.x;
		cmd.vSrcPos[2] = pos.y;
		cmd.dwTargetRoleID = role->getId();
		cmd.n64ItemID = _TempItem->get_item_id();
		cmd.byUseType = 0;
		TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);
		_canUseItem = false;
		//		m_CurBoxGamle_TypeID = _TempItem->get_item_type_id();//2014.3.18			【J】宝箱方案更改，注掉2014.11.17

		_TempItem = NULL;
	}
}
//gx add 2013.11.27
void PackageManager::useDrugItem_AutoProtece( f_item *item )
{
	if(!item)
		return;
	NET_SIC_use_item cmd;
	LocalPlayer *role = RoleManager::getInstance()->getLocalPlayer();
	if(!role)
		return;
	CCPoint pos = role->getPosition();
	cmd.vSrcPos[0] = pos.x;
	cmd.vSrcPos[2] = pos.y;
	cmd.dwTargetRoleID = role->getId();
	cmd.n64ItemID = item->get_item_id();
	cmd.byUseType = 0;
	TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);
	return;
}
//功法升级
void PackageManager::kungfuAddExp( INT64 n64_kungfu_main,INT64 n64_kungfu_back )
{
	//需要的预判断
	/*
	是否是装备
	是否是功法
	该功法的等级是否已满
	*/
	f_item *pItem = getItem(_pocket,n64_kungfu_main);
	if(!pItem)
		return;
	ItemTypeData data = getItemTypeData(pItem->get_item_type_id());
	if(data.type != PIT_Kungfu)
	{
		ToolTip::getInstance()->push(GET_STR(2303));
		return;
	}
	f_equipment *pKungfu = (f_equipment *)pItem;
	if (!pKungfu)
		return;
	if (pKungfu->m_equipex.nLevel >= MAX_KUNGFU_EQUIP_LEVEL)
	{
		ToolTip::getInstance()->push(GET_STR(2304));
	}
	pItem = getItem(_pocket,n64_kungfu_back);
	if(!pItem)
		return;
	data = getItemTypeData(pItem->get_item_type_id());
	if(data.type != PIT_Kungfu)
	{
		ToolTip::getInstance()->push(GET_STR(2305));
		return;
	}
	NET_SIC_Kungfu_Exp_Up send;
	send.n64KungfuSerial_main = n64_kungfu_main;
	send.n64KungfuSerial_back = n64_kungfu_back;
	TCP_CLIENT->send_net_cmd(&send, NP_IDLE, false);
	return;
}

//一键融合功法
void PackageManager::confirmAutoKungfuMergeInBag()
{
	//首先遍历背包，获得优先品质最高然后是等级最高的功法作为目标融合功法
	bool bInit = false;
	f_item* pMaxKungfu = NULL;
	_tmpKungfuIDMap.clear();//先清空
	for(ItemMap::iterator iter = _pocket.begin(); iter != _pocket.end(); ++iter)
	{
		//
		unsigned char byQualityMax = 0;
		unsigned char byQualityCurrent = 0;
		//记录两个功法的权重,品质占权重为2，功法等级占权重为1
		unsigned char byImportant_Max = 0;
		unsigned char byImportant_Current = 0;

		f_item *item = iter->second;
		if(!item)
			continue;
		ItemTypeData data = getItemTypeData(item->get_item_type_id());
		if(data.type != PIT_Kungfu || data.type != PIT_KungfuExp)//只考虑功法
			continue;

		if (!bInit)//若是首次碰到功法
		{
			pMaxKungfu = item;
			f_equipment* pKungfu = (f_equipment*)pMaxKungfu;
			if (!pKungfu)
				return;
			if (pKungfu->m_equipex.nLevel < MAX_KUNGFU_EQUIP_LEVEL)//已经是满级的功法不能作为目标融合功法
			{
				bInit = true;
				_tmpKungfuIDMap.insert(make_pair(item->get_item_id(),item->get_item_id()));
			}
		}
		else
		{
			if (pMaxKungfu)
			{
				byQualityMax = pMaxKungfu->get_item_type_id() / 100 % 10;
				byQualityCurrent = item->get_item_type_id() / 100 % 10;
				//(byQualityMax >= byQualityCurrent)?(byImportant_Max+=2):(byImportant_Current+=2);
				if (byQualityMax > byQualityCurrent)
				{
					byImportant_Max += 2;
				}
				else if (byQualityCurrent > byQualityMax)
				{
					byImportant_Current += 2;
				}
				else
				{
					//do nothing
				}
				f_equipment* pKungfu_Max = (f_equipment*)pMaxKungfu;
				f_equipment* pKungfu_Cur = (f_equipment*)item;
				if(!pKungfu_Max || !pKungfu_Cur)
					continue;
				//(pKungfu_Max->m_equipex.nLevel >= pKungfu_Cur->m_equipex.nLevel)?(byImportant_Max++):(byImportant_Current++);
				if (pKungfu_Max->m_equipex.nLevel > pKungfu_Cur->m_equipex.nLevel)
				{
					byImportant_Max++;
				}
				else if (pKungfu_Max->m_equipex.nLevel < pKungfu_Cur->m_equipex.nLevel)
				{
					byImportant_Current++;
				}
				else
				{
					//do nothing
				}
				if (byImportant_Current > byImportant_Max)//碰到更牛的功法啦,不应该加上等号
				{
					//检查已进插入的目标功法是否符合被一键融合的要求
					if (pMaxKungfu)
					{
						if (pMaxKungfu->get_item_type_id() / 100 % 10 > 2)
						{
							UniqueIDMap::iterator iter1 = _tmpKungfuIDMap.find(pMaxKungfu->get_item_id());
							if (iter1 != _tmpKungfuIDMap.end())
							{
								_tmpKungfuIDMap.erase(iter1);
							}
						}
					}
					pMaxKungfu = item;
					//始终将目标功法插入容器中
					_tmpKungfuIDMap.insert(make_pair(pMaxKungfu->get_item_id(),pMaxKungfu->get_item_id()));
				}
				else
				{
					if (byQualityCurrent > 2)//仅一键融合品质为1,2的功法
						continue;
					//符合条件的可以被融合的功法加入容器中
					_tmpKungfuIDMap.insert(make_pair(pKungfu_Cur->get_item_id(),pKungfu_Cur->get_item_id()));
				}
			}
			else
			{
				_tmpKungfuIDMap.clear();
				return;
			}
		}
	}//end for
	if (!pMaxKungfu)//说明背包中没有功法
	{
		//给提示
		ToolTip::getInstance()->push(GET_STR(2308));
		_tmpKungfuIDMap.clear();
		return;
	}
	//将最终拣选出的目标功法从容器中剔除
	UniqueIDMap::iterator iter = _tmpKungfuIDMap.find(pMaxKungfu->get_item_id());
	if (iter != _tmpKungfuIDMap.end())
	{
		_tmpKungfuIDMap.erase(iter);
	}
	if (_tmpKungfuIDMap.empty())
	{
		//背包中没有需要一键融合的功法
		ToolTip::getInstance()->push(GET_STR(2309));
		return;
	}
	//经验珠不能作为一键融合的目标
	if (0 == pMaxKungfu->get_item_type_id()/100%10)
	{
		ToolTip::getInstance()->push(GET_STR(2314));
		_tmpKungfuIDMap.clear();
		return;
	}
	_tmpKungfu_Main = pMaxKungfu->get_item_id();
	UniqueIDMap::const_iterator iter_first = _tmpKungfuIDMap.begin();
	if (iter_first == _tmpKungfuIDMap.end())
	{
		_tmpKungfuIDMap.clear();
		return;
	}
	NET_SIC_Kungfu_Exp_Up cmd;
	cmd.uType = 0;//背包中融合
	cmd.n64KungfuSerial_main = pMaxKungfu->get_item_id();
	cmd.n64KungfuSerial_back = iter_first->first;
	TCP_CLIENT->send_net_cmd(&cmd, NP_IDLE, false);

	lockItem(EICT_Bag,cmd.n64KungfuSerial_main);//背包
	lockItem(EICT_Bag,cmd.n64KungfuSerial_back);//背包
}
//功法一键升级
void PackageManager::auto_kungfuMergeInBag()
{
	if (!_tmpKungfuIDMap.empty())
	{
		//正在进行一键融合，不能继续融合
		return ;
	}

	LocalPlayer *ploc = RoleManager::getInstance()->getLocalPlayer();
	if(!ploc)
		return;
	unsigned int roleID = ploc->getId();
	std::stringstream ss;
	ss<<"set"<<"_"<<roleID;
	int tip = ClientCfg::getInstance()->getInt(ss.str(), "akfmTip", 0);
	if (tip != 0)
	{
		confirmAutoKungfuMergeInBag();//背包中的功法一键融合
	}
	else 
	{
		MessageBoxUi *messageBox = MessageBoxUi::createWithTwoBtnWithCheck(GET_STR(2315).c_str(), GET_STR(98).c_str(), TEXT_UTF8_QUEDING, TEXT_UTF8_QUXIAO, false);
		messageBox->signalOkBtnPressed.connect(this, &PackageManager::confirmAutoKungfuMergeInBag);
		messageBox->signalCheckStateChange.connect(this, &PackageManager::toAutoMergeTip);
		//messageBox->signalCancelBtnPressed.connect(this,&PackageManager::missKungfuMerge);
		World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
	}
}
//type:0代表熔炼1,2品质的功法，1代表熔炼3,4品质的功法
void PackageManager::collectAutoUpKungfuID(unsigned int typeID,unsigned char type)
{
	_tmpKungfuIDMap.clear();
	//需要遍历背包
	//代码重复，但是可以提高些效率
	if (0 == type)//1,2级品质的仅吞噬小于等于该品质的一级功法
	{
		for(ItemMap::iterator iter = _pocket.begin(); iter != _pocket.end(); ++iter)
		{
			f_item *item = iter->second;
			if(!item)
				continue;
			ItemTypeData data = getItemTypeData(item->get_item_type_id());
			if(data.type != PIT_Kungfu || data.type != PIT_KungfuExp)//只考虑功法
				continue;
			int nTypeMain = typeID % 10;//目标功法的品质,1,2,3,4
			int nTypeBack = item->get_item_type_id() % 10;//被吞噬功法的品质 (这个真心不知道是个什么鬼 最好别用)
			if (nTypeMain >= nTypeBack)
			{
				f_equipment* pKungfu = (f_equipment*)item;
				if (pKungfu && (1 == pKungfu->m_equipex.nLevel))
				{
					_tmpKungfuIDMap.insert(make_pair(pKungfu->get_item_id(),pKungfu->get_item_id()));
				}
			}
		}
	}
	else if (1 == type)//3,4级品质的吞噬1,2级品质的所有级别的功法
	{
		for(ItemMap::iterator iter = _pocket.begin(); iter != _pocket.end(); ++iter)
		{
			f_item *item = iter->second;
			if(!item)
				continue;
			ItemTypeData data = getItemTypeData(item->get_item_type_id());
			if(data.type != PIT_Kungfu || data.type != PIT_KungfuExp)//只考虑功法
				continue;
			//int nTypeMain = typeID % 10;//目标功法的品质,1,2,3,4
			int nTypeBack = item->get_item_type_id() % 10;//被吞噬功法的品质 (这个真心不知道是个什么鬼 最好别用)
			if (1 == nTypeBack && 2 == nTypeBack)
			{
				_tmpKungfuIDMap.insert(make_pair(item->get_item_id(),item->get_item_id()));
			}
		}
	}
	else
	{
		return;
	}
}

bool PackageManager::isHavePurpleSwalllowInKungfuBag(EItemConType pType)//检测的入口
{
	if (pType!= EICT_KungfuBag && pType != EICT_KungfuTemp) return false;
	ItemMap& t_ItemMap = pType == EICT_KungfuBag ? _gongfabag : _gongfatmp;
	bool t_isHavePurple = false;
	bool t_isHaveLowThanPurple = false;
	for(ItemMap::iterator iter = t_ItemMap.begin(); iter != t_ItemMap.end(); ++iter)
	{
		f_item *item = iter->second;
		if(!item)
			continue;
		ItemTypeData data = getItemTypeData(item->get_item_type_id());
		if(data.type != PIT_Kungfu && data.type != PIT_KungfuExp)//只考虑功法
			continue;
		f_equipment* t_equip = dynamic_cast<f_equipment*>(item);
		CC_ASSERT(t_equip);
		if (data.byQuality >= EIQ_Quality3 && !t_equip->is_gf_locked() && data.type != PIT_KungfuExp)
		{
			t_isHavePurple = true;
		}

		if ( !t_equip->is_gf_locked())
		{
			if(data.type == PIT_KungfuExp)
				t_isHaveLowThanPurple = true;
			else
			{
				if(data.byQuality<EIQ_Quality3) t_isHaveLowThanPurple = true;
			}
				
		}
	}
	return t_isHavePurple && t_isHaveLowThanPurple;
}

unsigned int PackageManager::onKungfuExpChange( s_net_cmd *cmd )
{
	NET_SIS_Kungfu_Exp_Up* msg = (NET_SIS_Kungfu_Exp_Up*)cmd;
	//先对图标解锁
	if (0 == msg->uType)
	{
		unLockItem(EICT_Bag,msg->n64KungfuSerial_main,true);
		unLockItem(EICT_Bag,msg->n64KungfuSerial_back,true);
	}
	else 
	{
		unLockItem(EICT_KungfuEquip,msg->n64KungfuSerial_main,true);
		unLockItem(EICT_Bag,msg->n64KungfuSerial_back,true);
	}
	if (0 == msg->dwErrCode)
	{
		//这里需不需要UI的表现，待定
		UniqueIDMap::iterator iter = _tmpKungfuIDMap.find(msg->n64KungfuSerial_back);
		if (iter != _tmpKungfuIDMap.end())
		{
			_tmpKungfuIDMap.erase(iter);
		}
		if (!_tmpKungfuIDMap.empty())
		{
			UniqueIDMap::const_iterator iter_first = _tmpKungfuIDMap.begin();
			if (iter_first == _tmpKungfuIDMap.end())
			{
				_tmpKungfuIDMap.clear();
				return 0;
			}
			NET_SIC_Kungfu_Exp_Up send;
			send.n64KungfuSerial_main = _tmpKungfu_Main;
			send.n64KungfuSerial_back = iter_first->first;
			TCP_CLIENT->send_net_cmd(&send, NP_IDLE, false);
		}
	}
	else
	{
		//发生了错误，若正处于一键融合中，应立即停止
		_tmpKungfuIDMap.clear();

		if (E_SameKungfu_Cannt_Equip == msg->dwErrCode)
		{
			ToolTip::getInstance()->push(GET_STR(2310));
		}
		else if (E_Kungfu_Level_Max == msg->dwErrCode)
		{
			ToolTip::getInstance()->push(GET_STR(2311));
		}
		else
		{
			ToolTip::getInstance()->push(GET_STR(2306));
		}

	}
	return 0;
}

void PackageManager::KungfuMerge(f_equipment* pEquip_first,f_equipment* pEquip_sencond)
{
	if (!pEquip_first || !pEquip_sencond)
		return;
	//这里仅处理背包中与功法槽上的功法进行融合
	if (pEquip_sencond->get_container_type() != EICT_KungfuEquip)
		return;
	unsigned char byType = 0;//标示是否在背包中融合
	//比较两个功法的高低
	//品质占权重为2，功法等级占权重为1
	unsigned char byQualityFirst = pEquip_first->get_item_type_id()/100%10;
	unsigned char byQualitySecond = pEquip_sencond->get_item_type_id()/100%10;
	//记录两个功法的权重
	unsigned char byImportant_First = 0;
	unsigned char byImportant_Second = 0;
	if (byQualitySecond > byQualityFirst)
	{
		byImportant_Second += 2;
	}
	else if(byQualityFirst > byQualitySecond)
	{
		byImportant_First += 2;
	}
	else
	{

	}
	//比较功法等级
	if (pEquip_sencond->m_equipex.nLevel > pEquip_first->m_equipex.nLevel)
	{
		byImportant_Second += 1;
	}
	else if (pEquip_sencond->m_equipex.nLevel < pEquip_first->m_equipex.nLevel)
	{
		byImportant_First += 1;
	}
	else
	{

	}
	if (byImportant_Second >= byImportant_First)
	{
		if (pEquip_sencond->m_equipex.nLevel >= MAX_KUNGFU_EQUIP_LEVEL)
		{
			ToolTip::getInstance()->push(GET_STR(2304));
			return;
		}
		if (0 == byQualitySecond)
		{
			ToolTip::getInstance()->push(GET_STR(2314));
			return ;
		}
		byType = 1;//功法槽融合背包中的功法
	}
	else
	{
		if (pEquip_first->m_equipex.nLevel >= MAX_KUNGFU_EQUIP_LEVEL)
		{
			ToolTip::getInstance()->push(GET_STR(2304));
			return;
		}
		if (0 == byQualityFirst)
		{
			ToolTip::getInstance()->push(GET_STR(2314));
			return ;
		}
		byType = 2;//功法槽的被背包中的融合
	}
	//这里要给二次确认提示
	_TempKungfuItemID_Dest = pEquip_sencond->get_item_id();
	_TempKungfuItemID_Src = pEquip_first->get_item_id();
	_TempKungfuMergeType = byType;
	const KunfuTypeData& kungfuData_first = getKungfuTypeData(pEquip_first->get_item_type_id());
	const KunfuTypeData& kungfuData_second = getKungfuTypeData(pEquip_sencond->get_item_type_id());
	std::string str_1 = "";
	std::string str_2 = "";
	int nAddExp = 0;
	if (1 == byType)//目标是main
	{
		str_1 = replaceStr(GET_STR(2332),"*",kungfuData_second.kungfuName);
		str_2 = replaceStr(str_1,"**",kungfuData_first.kungfuName);
		nAddExp = GetKungfuExp(pEquip_first,kungfuData_first);
	}
	else//目标是back
	{
		str_1 = replaceStr(GET_STR(2332),"*",kungfuData_first.kungfuName);
		str_2 = replaceStr(str_1,"**",kungfuData_second.kungfuName);
		nAddExp = GetKungfuExp(pEquip_sencond,kungfuData_second);
	}
	std::ostringstream oss;
	oss << nAddExp;
	std::string str_3 = replaceStr(str_2,"***",oss.str());
	MessageBoxUi *ui = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,str_3.c_str(), TEXT_UTF8_QUEDING,TEXT_UTF8_QUXIAO);
	World::getInstance()->getScene()->addChild(ui, WZ_MESSAGEBOX);
	ui->signalOkBtnPressed.connect(this, &PackageManager::ConfirmMerge);

	//end by gx
	//NET_SIC_Kungfu_Exp_Up cmd;
	//cmd.uType = byType;
	//cmd.n64KungfuSerial_main = pEquip_sencond->get_item_id();
	//cmd.n64KungfuSerial_back = pEquip_first->get_item_id();
	//TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);

	//lockItem(EICT_Bag,pEquip_first->get_item_id());//背包
	//lockItem(EICT_KungfuEquip,pEquip_sencond->get_item_id());//功法装备栏
}
void PackageManager::ConfirmMerge()
{
	NET_SIC_Kungfu_Exp_Up cmd;
	cmd.uType = _TempKungfuMergeType;
	cmd.n64KungfuSerial_main = _TempKungfuItemID_Dest;
	cmd.n64KungfuSerial_back = _TempKungfuItemID_Src;
	TCP_CLIENT->send_net_cmd(&cmd, NP_IDLE, false);

	lockItem(EICT_Bag,_TempKungfuItemID_Src);//背包
	lockItem(EICT_KungfuEquip,_TempKungfuItemID_Dest);//功法装备栏
	return;
}
void PackageManager::kungfuMergeInBag(f_equipment* pEquip_first,f_equipment* pEquip_sencond)
{
	/*f_equipment* pEquip_first = (f_equipment*)_TempKungfuItem_Frist;
	f_equipment* pEquip_sencond = (f_equipment*)_TempKungfuItem_Second;*/
	if (!pEquip_first || !pEquip_sencond)
		return;
	//比较两个功法的高低
	//品质占权重为2，功法等级占权重为1
	unsigned char byQualityFirst = pEquip_first->get_item_type_id()/100%10;
	unsigned char byQualitySecond = pEquip_sencond->get_item_type_id()/100%10;
	//记录两个功法的权重
	unsigned char byImportant_First = 0;
	unsigned char byImportant_Second = 0;
	if (byQualitySecond > byQualityFirst)
	{
		byImportant_Second += 2;
	}
	else if(byQualityFirst > byQualitySecond)
	{
		byImportant_First += 2;
	}
	else
	{

	}
	//比较功法等级
	if (pEquip_sencond->m_equipex.nLevel > pEquip_first->m_equipex.nLevel)
	{
		byImportant_Second += 1;
	}
	else if(pEquip_sencond->m_equipex.nLevel < pEquip_first->m_equipex.nLevel)
	{
		byImportant_First += 1;
	}
	else
	{

	}
	//两个经验珠不能融合
	if (byImportant_Second >= byImportant_First)
	{
		if (pEquip_sencond->m_equipex.nLevel >= MAX_KUNGFU_EQUIP_LEVEL)
		{
			ToolTip::getInstance()->push(GET_STR(2304));
			return;
		}
		if (0 == byQualitySecond)
		{
			ToolTip::getInstance()->push(GET_STR(2314));
			return ;
		}
	}
	else
	{
		if (pEquip_first->m_equipex.nLevel >= MAX_KUNGFU_EQUIP_LEVEL)
		{
			ToolTip::getInstance()->push(GET_STR(2304));
			return;
		}
		if (0 == byQualityFirst)
		{
			ToolTip::getInstance()->push(GET_STR(2314));
			return ;
		}
	}
	//end
	//这里要给二次确认提示
	int nAddExp = 0;
	const KunfuTypeData& kungfuData_first = getKungfuTypeData(pEquip_first->get_item_type_id());
	const KunfuTypeData& kungfuData_second = getKungfuTypeData(pEquip_sencond->get_item_type_id());
	std::string str_1 = "";
	std::string str_2 = "";
	if (byImportant_Second >= byImportant_First)
	{
		_TempKungfuItemID_Dest = pEquip_sencond->get_item_id();
		_TempKungfuItemID_Src = pEquip_first->get_item_id();
		nAddExp = GetKungfuExp(pEquip_first,kungfuData_first);

		str_1 = replaceStr(GET_STR(2332),"*",kungfuData_second.kungfuName);
		str_2 = replaceStr(str_1,"**",kungfuData_first.kungfuName);
	}
	else
	{
		_TempKungfuItemID_Dest = pEquip_first->get_item_id();
		_TempKungfuItemID_Src = pEquip_sencond->get_item_id();
		nAddExp = GetKungfuExp(pEquip_sencond,kungfuData_second);

		str_1 = replaceStr(GET_STR(2332),"*",kungfuData_first.kungfuName);
		str_2 = replaceStr(str_1,"**",kungfuData_second.kungfuName);
	}
	_TempKungfuMergeType = 0;
	std::ostringstream oss;
	oss << nAddExp;
	std::string str_3 = replaceStr(str_2,"***",oss.str());
	MessageBoxUi *ui = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,str_3.c_str(), TEXT_UTF8_QUEDING,TEXT_UTF8_QUXIAO);
	World::getInstance()->getScene()->addChild(ui, WZ_MESSAGEBOX);
	ui->signalOkBtnPressed.connect(this, &PackageManager::ConfirmMergeInBag);
	ui->signalCancelBtnPressed.connect(this, &PackageManager::UnConfirmMerageInBag);
	//end by gx
	//NET_SIC_Kungfu_Exp_Up cmd;
	//cmd.uType = 0;
	//if (byImportant_Second >= byImportant_First)
	//{
	//	cmd.n64KungfuSerial_main = pEquip_sencond->get_item_id();
	//	cmd.n64KungfuSerial_back = pEquip_first->get_item_id();
	//}
	//else
	//{
	//	cmd.n64KungfuSerial_main = pEquip_first->get_item_id();
	//	cmd.n64KungfuSerial_back = pEquip_sencond->get_item_id();
	//}
	//TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);

	//lockItem(EICT_Bag,pEquip_first->get_item_id());//背包
	//lockItem(EICT_Bag,pEquip_sencond->get_item_id());//背包
}
void PackageManager::ConfirmMergeInBag()
{
	NET_SIC_Kungfu_Exp_Up cmd;
	cmd.uType = _TempKungfuMergeType;
	cmd.n64KungfuSerial_main = _TempKungfuItemID_Dest;
	cmd.n64KungfuSerial_back = _TempKungfuItemID_Src;
	TCP_CLIENT->send_net_cmd(&cmd, NP_IDLE, false);

	lockItem(EICT_Bag,_TempKungfuItemID_Dest);//背包
	lockItem(EICT_Bag,_TempKungfuItemID_Src);//背包
}

void PackageManager::UnConfirmMerageInBag()
{
	unLockItem(EICT_Bag, _TempKungfuItemID_Dest);
	unLockItem(EICT_Bag, _TempKungfuItemID_Src);
}

void PackageManager::missKungfuMerge()
{
	//if (_TempKungfuItem_Frist)
	//{
	//	if (EICT_Bag == _TempKungfuItem_Frist->get_container_type())
	//	{
	//		unLockItem(EICT_Bag,_TempKungfuItem_Frist->get_item_id(),true);
	//	}
	//	else if (EICT_KungfuEquip == _TempKungfuItem_Frist->get_container_type())
	//	{
	//		unLockItem(EICT_KungfuEquip,_TempKungfuItem_Frist->get_item_id(),true);
	//	}
	//	else
	//	{
	//		//do nothing
	//	}
	//	_TempKungfuItem_Frist = NULL;
	//}
	//if (_TempKungfuItem_Second)
	//{
	//	if (EICT_Bag == _TempKungfuItem_Second->get_container_type())
	//	{
	//		unLockItem(EICT_Bag,_TempKungfuItem_Second->get_item_id(),true);
	//	}
	//	else if (EICT_KungfuEquip == _TempKungfuItem_Second->get_container_type())
	//	{
	//		unLockItem(EICT_KungfuEquip,_TempKungfuItem_Second->get_item_id(),true);
	//	}
	//	else
	//	{
	//		//do nothing
	//	}
	//	_TempKungfuItem_Second = NULL;
	//}
}

unsigned int PackageManager::onTotalYBConsume( s_net_cmd *cmd )
{
	NET_SIS_totalconsume_yuanbao* msg = (NET_SIS_totalconsume_yuanbao*)cmd;
	SetTotalConsumeYB(msg->nTotalYBConsume);
	//消费返利UI更新;
	GET_UI(ConsumptionUi, WCT_ConsumptionUi)->updateData();
	//消费返利领奖特效更新;
	MiniMapUi *mUi = World::getInstance()->getMiniMapUi();
	if (mUi)
	{
		mUi->updateActivityAnimation();
	}
	return 0;
}

unsigned int PackageManager::onConsumeYBReplyData( s_net_cmd *cmd )
{
	NET_SIS_update_role_script_data* msg = (NET_SIS_update_role_script_data*)cmd;
	LocalPlayer* ploc = RoleManager::getInstance()->getLocalPlayer();
	if(!ploc)
		return 0;
	if (ploc->getId() != msg->dw_role_id)//只考虑自己
		return 0;
	if (CONSUM_REPLY_DATA_FLAG == msg->nindex)
	{
		SetConsumeReplyData(msg->dwvalue);
	}
	else 
	{
		//do nothing
	}
	return 0;
}
bool PackageManager::CanGetConsumeReplyReward(unsigned char byState)
{
	if (byState < 0 || byState > MAX_CONSUME_REPLY_NUM)
		return false;
	//是否领取过
	// 领取标记
	int dwRecv = GetConsumeReplyData();
	// 判断是否领取过
	if (dwRecv & (1 << byState))
		return false;
	//若没领取过，检查是否有资格领取
	if (0 == byState)
	{
		if(this->GetToalConsumeYB() < this->getConsumeRewardNeedCost(0))
			return false;
	}
	else if (1 == byState)
	{
		if (GetToalConsumeYB() < this->getConsumeRewardNeedCost(1))
			return false;
	}
	else if (2 == byState)
	{
		if (GetToalConsumeYB() < this->getConsumeRewardNeedCost(2))
			return false;
	}
	else if (3 == byState)
	{
		if (GetToalConsumeYB() < this->getConsumeRewardNeedCost(3))
			return false;
	}
	else if (4 == byState)
	{
		if (GetToalConsumeYB() < this->getConsumeRewardNeedCost(4))
			return false;
	}
	else
	{
		return false;//异常
	}
	return true;
}

bool PackageManager::IsConsumeEnoughYB( unsigned char byState )
{
	if (byState < 0 || byState > MAX_CONSUME_REPLY_NUM)
		return false;
	//若没领取过，检查是否有资格领取
	if (0 == byState)
	{
		if (GetToalConsumeYB() < 100)
			return false;
	}
	else if (1 == byState)
	{
		if (GetToalConsumeYB() < 500)
			return false;
	}
	else if (2 == byState)
	{
		if (GetToalConsumeYB() < 2000)
			return false;
	}
	else if (3 == byState)
	{
		if (GetToalConsumeYB() < 5000)
			return false;
	}
	else if (4 == byState)
	{
		if (GetToalConsumeYB() < 10000)
			return false;
	}
	else if (5 == byState)
	{
		if (GetToalConsumeYB() < 30000)
			return false;
	}
	else if (6 == byState)
	{
		if (GetToalConsumeYB() < 60000)
			return false;
	}
	else if (7 == byState)
	{
		if (GetToalConsumeYB() < 100000)
			return false;
	}
	else
	{
		return false;//异常
	}
	return true;
}

bool PackageManager::IsGetRewardAlready( unsigned char byState )
{
	if (byState < 0 || byState > MAX_CONSUME_REPLY_NUM)
		return true;
	//是否领取过
	// 领取标记
	int dwRecv = GetConsumeReplyData();
	// 判断是否领取过
	if (dwRecv & (1 << byState))
		return true;
	return false;
}

bool PackageManager::CanGetConsumeReplyReward()
{
	//int state = 0;
	for (int i=0; i<MAX_CONSUME_REPLY_NUM; i++)
	{
		if (CanGetConsumeReplyReward(i) && !IsGetRewardAlready(i))
		{
			return true;
		}
	}
	return false;
}

const KunfuTypeData & PackageManager::getKungfuTypeData( unsigned int typeId )
{
	KungfuData::iterator iter = _kungfuData.find(typeId);
	if(iter != _kungfuData.end())
	{
		const KunfuTypeData &data = iter->second;
		return data;
	}
	KunfuTypeData kungfuTypeData;
	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM GongfaTipData WHERE typeId = ?1");
	cmd->set_integer32(1 , typeId);
	c_sql_table* table = c_db_manager::getSingleton()->create_table();
	while(table->retrieve_row())
	{
		unsigned int idx = table->get_index("name");
		kungfuTypeData.kungfuName = table->get_text(idx);
		idx = table->get_index("typeId");
		kungfuTypeData.typeID = table->get_integer32(idx);
		idx = table->get_index("kungfu_exp");
		kungfuTypeData.nExp = table->get_integer32(idx);

		idx = table->get_index("explevelup1");
		kungfuTypeData.explevelup[0] = table->get_integer32(idx);
		idx = table->get_index("explevelup2");
		kungfuTypeData.explevelup[1] = table->get_integer32(idx);
		idx = table->get_index("explevelup3");
		kungfuTypeData.explevelup[2] = table->get_integer32(idx);
		idx = table->get_index("explevelup4");
		kungfuTypeData.explevelup[3] = table->get_integer32(idx);
		idx = table->get_index("explevelup5");
		kungfuTypeData.explevelup[4] = table->get_integer32(idx);
		idx = table->get_index("explevelup6");
		kungfuTypeData.explevelup[5] = table->get_integer32(idx);
		idx = table->get_index("explevelup7");
		kungfuTypeData.explevelup[6] = table->get_integer32(idx);
		idx = table->get_index("explevelup8");
		kungfuTypeData.explevelup[7] = table->get_integer32(idx);
		idx = table->get_index("explevelup9");
		kungfuTypeData.explevelup[8] = table->get_integer32(idx);
		idx = table->get_index("explevelup10");
		kungfuTypeData.explevelup[9] = table->get_integer32(idx);
		idx = table->get_index("explevelup11");
		kungfuTypeData.explevelup[10] = table->get_integer32(idx);
		idx = table->get_index("explevelup12");
		kungfuTypeData.explevelup[11] = table->get_integer32(idx);
		idx = table->get_index("explevelup13");
		kungfuTypeData.explevelup[12] = table->get_integer32(idx);
		idx = table->get_index("explevelup14");
		kungfuTypeData.explevelup[13] = table->get_integer32(idx);
		idx = table->get_index("explevelup15");
		kungfuTypeData.explevelup[14] = table->get_integer32(idx);
	}
	c_db_manager::getSingleton()->destroy_table(table);
	c_db_manager::getSingleton()->end_operation(cmd);

	_kungfuData[typeId] = kungfuTypeData;
	return _kungfuData[typeId];
}

int PackageManager::GetKungfuExp( f_equipment* pKungfu,const KunfuTypeData& typeData )
{
	if (!pKungfu)
		return 0;
	int nRetValue = 0;

	int kungfuLevel = pKungfu->m_equipex.nLevel;
	if (kungfuLevel > MAX_KUNGFU_EQUIP_LEVEL)
		return 0;
	//首先是该功法的累加经验
	if (kungfuLevel > 1)
	{
		for (int i = 0;i <= kungfuLevel-2;++i)
		{
			if (i >= MAX_KUNGFU_EQUIP_LEVEL - 1)
				break;
			nRetValue += typeData.explevelup[i];
		}
	}
	else
	{
		//1级不累加
	}
	nRetValue += pKungfu->m_equipex.nCurLevelExp;
	nRetValue += typeData.nExp;
	return nRetValue;
}

unsigned int PackageManager::onGetRechargeFeedbackInfo( s_net_cmd *cmd )
{
	NET_SIS_recharge_feedback* msg = (NET_SIS_recharge_feedback*)cmd;
	if (msg)
	{
		SetRecharge_Period(msg->nCurRecharge);
		SetRecharge_Feedback(msg->nCurRechargeFeedback);
		SetFeedback_Times(msg->nFeedback_Times);

		MiniMapUi *mUi = World::getInstance()->getMiniMapUi();
		if (mUi)
		{
			mUi->updateActivityAnimation();///刷新活动特效
			mUi->setBtnHighLight(WCT_CoreTreeUi);//摇钱树叹号
		}
		//给UI预留接口
		// 		GET_UI(CoreTreeUi, WCT_CoreTreeUi)->setReCharge(msg->nCurRecharge);
		// 		GET_UI(CoreTreeUi, WCT_CoreTreeUi)->setLestCount(msg->nFeedback_Times);

	}
	return 0;
}

void PackageManager::closeTip( float dt )
{
	ItemTip::getInstace()->close();
}

unsigned int PackageManager::onGetForingDataInfo( s_net_cmd *cmd )
{
	NET_SIS_Forging_result* msg = (NET_SIS_Forging_result*)cmd;
	if (NULL != msg)
	{
		if(E_Forging_Success == msg->result)
		{
			ForgingDecomUILayer * p_ui = getUiNodeByTag<ForgingDecomUILayer>(WCT_ForgingDecomUI);
			if(NULL != p_ui)
			{
				f_item * newitem = PackageManager::getInstance()->getItem(EICT_Bag,msg->FinalId);
				EquipTipUiLayer* ui = EquipTipUi::create();
				CC_ASSERT(NULL != newitem);
				p_ui->updateForgingRightList(p_ui->GetForgingId());
				p_ui->updateRedPointShow();
				if(IS_UI_OPEN(WCT_ForgingDecomUI))
				{
					ui->showSelfEquip();
					ui->showUi(ccp(0,0),newitem->get_item_type_id());
					ui->setAllButtonOff();
					ui->setEquipVisible(false);
				}						 

				p_ui->scheduleOnce(schedule_selector(PackageManager::closeTip),3.0f);
			}
		}
		else if(E_Forging_Bag_in_fail == msg->result)
			ToolTip::getInstance()->push(GET_STR(7273));

		else if(E_Forging_Role_level_Fail == msg->result)
			ToolTip::getInstance()->push(GET_STR(7274));

		else if(E_Forging_Bag_Stuff_Fail == msg->result)
			ToolTip::getInstance()->push(GET_STR(7275));

		else if(E_Forging_Money_Fail == msg->result)
			ToolTip::getInstance()->push(GET_STR(7276));

		else if(E_Foring_System_Fail == msg->result)
			ToolTip::getInstance()->push(GET_STR(7277));

		else if(E_Forging_DeleteBag_Fail == msg->result)
			ToolTip::getInstance()->push(GET_STR(7277));

		else if(E_Forging_ToBag_Fail == msg->result)
			ToolTip::getInstance()->push(GET_STR(7277));

		else if(E_Forging_Create_Fail == msg->result)
			ToolTip::getInstance()->push(GET_STR(7277));
	}

	return 0;
}

unsigned int PackageManager::onGetDecomPoseDataInfo( s_net_cmd *cmd )
{
	NET_SIS_Decompose_result* msg = (NET_SIS_Decompose_result*)cmd;

	if (NULL != msg)
	{
		if(E_Decompose_Success == msg->errorInfo)
		{
			std::vector<decomposeItem> recvInfo;
			recvInfo.clear();
			size_t size = msg->size - sizeof(s_net_cmd) - sizeof(DWORD);
			for(size_t i = 0; i < size / sizeof(decomposeItem) ; i++)
			{
				recvInfo.push_back( msg->data_infos[i]);
			}

			std::vector<decomposeItem>::iterator iter = recvInfo.begin();
			std::vector<decomposeItem>::iterator iterend = recvInfo.end();
			for(; iter != iterend; iter++) 
			{
				if(0 < iter->itemid && 0 < iter->itemnum)
					ReceiveRewardUiMgr::GetInstance()->setItemData(iter->itemid, iter->itemnum);
			}

			ReceiveRewardUiMgr::GetInstance()->openRewardUi();

			ForgingDecomUILayer * p_ui = getUiNodeByTag<ForgingDecomUILayer>(WCT_ForgingDecomUI);
			if(NULL != p_ui)
			{
				p_ui->updateDecomPackage();
			}
			ForgingMgr::getInstance()->judgeDecomposeByEquip();

			AutoActionMgr* auto_mgr = AutoActionMgr::getInstance();
			if (auto_mgr->Get_Auto_Action())
			{
				LocalPlayer* lp = RoleManager::getInstance()->getLocalPlayer();
				MessageDispatcher::Instance()->DispatchMsg(-1.0, NULL, lp, M_LpStand, NULL);
				auto_mgr->generate_pickup_points();//触发一次拾取
			}

		}
		else if(E_Decompose_NOBag == msg->errorInfo)
			ToolTip::getInstance()->push(GET_STR(7280));

		else if(E_Decompose_NoItem_Fail == msg->errorInfo)
			ToolTip::getInstance()->push(GET_STR(7280));

		else if (E_Unbeset_Not_bag_free == msg->errorInfo)
			ToolTip::getInstance()->push(GET_STR(161));
	}

	return 0;
}

void PackageManager::allUseBagItem( short index )
{
	f_item *item = getItem(_pocket, index);
	allUseBagItem(item);
}

void PackageManager::allUseBagItem( f_item *item )
{
	if(item == NULL)
		return;
	LocalPlayer *role = RoleManager::getInstance()->getLocalPlayer();
	if( role == NULL )
		return;
	//先找物品类别
	const ItemTypeData &typeData = getItemTypeData(item->get_item_type_id());
	ePackageItemType eItemType = typeData.type;
	switch( eItemType )
	{
	case PIT_LuckYou: //批量使用祝福油
		{
			//首先判断是否装备了武器
			PackageManager::ItemMap *itemMap = PackageManager::getInstance()->getItemMap(EICT_Equip);
			f_item *pItemWepon = PackageManager::getInstance()->getItem(*itemMap, (short)EEP_RightHand);
			if (!pItemWepon)
			{
				ToolTip::getInstance()->push(GET_STR(2122));
				return;
			}
			f_equipment *pEquip = dynamic_cast<f_equipment*>(pItemWepon);
			if (!pEquip)
				return;
			if (pEquip->m_equipex.byLuck >= 7)
			{
				ToolTip::getInstance()->push(GET_STR(2123));
				return;
			}

			if(item->get_item_type_id() == oil_type_id)
			{
				OPEN_UI(WCT_USE_OIL_UI);
				return;
			}

			NET_SIC_use_luck_you msg;
			msg.n64Item = item->get_item_id();
			msg.byType = 1; //批量使用
			TCP_CLIENT->send_net_cmd(&msg, NP_CRITICAL, false);
		}
		break;
	case PIT_GoodManCard: //好人卡
		{
			int nPKValue = role->getAttribute(RA_PKVALUE); //获取pk值
			if( nPKValue <= 0 )
			{
				ToolTip::getInstance()->push(GET_STR(7152));
				return;
			}
			NET_SIC_AllUse_Good_Man_Card msg;
			msg.n64Item = item->get_item_id();
			TCP_CLIENT->send_net_cmd(&msg, NP_IDLE, false);
		}
		break;
	default: //走脚本通用的
		if(_canUseItem)
		{
			NET_SIC_use_item cmd;
			CCPoint pos = role->getPosition();
			cmd.vSrcPos[0] = pos.x;
			cmd.vSrcPos[2] = pos.y;
			cmd.dwTargetRoleID = role->getId();
			cmd.n64ItemID = item->get_item_id();
			cmd.byUseType = 1;
			TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);

			_canUseItem = false;
		}
		break;
	}
}

void PackageManager::allUseBagItem( INT64 id )
{
	f_item *item = getItem(_pocket, id);
	allUseBagItem(item);
}

void PackageManager::setGongfaOneKeySE(bool isOneKey, int seCount)
{
	m_nSECount = seCount;
	m_bIsGongfaOneKey = isOneKey;
}

void PackageManager::flushGongfaTempBag( float dt )
{
	GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp();	
}

std::string PackageManager::getSuperEffectName( const char* seName )
{
	CCString* frameStr = CCString::createWithFormat("%s%02d", seName, 1);
	if(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frameStr->getCString()) == NULL)
	{
		std::string sSEDir = CFGReader::instance()->get_profile_string("Art","Effect","");
		frameStr->initWithFormat("%s%s.plist", sSEDir.c_str(), seName);
		CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFramesWithFile(frameStr->getCString());
	}
	return seName;
}
//查找可以洗练的装备
void PackageManager::FindEquipCanClear()
{
	f_equipment* pfEquipItem = NULL;
	f_equipment* pfItem = NULL;
	ItemMap* pItemMap = getItemMap(EICT_Equip);
	ItemMap::iterator IT = pItemMap->begin();
	while(IT != pItemMap->end())
	{
		pfItem = (f_equipment*)IT->second;
		if(pfItem->get_item_quality() > EIQ_Quality0)
		{
			pfEquipItem = pfItem;
			break;
		}
		IT++;
	}
	if(pfEquipItem != NULL)
	{
		EquipFusionManager::getInstance()->setEquipment(pfEquipItem);
		OPEN_UI(WCT_EquipFusionUi);
	}
	else
	{
		ToolTip::getInstance()->push(GET_STR(9631).c_str());
	}
}
void PackageManager::FindEquipWithMVB( Enum_MVB_Item e )
{
	//优先查找身上的
	int nFindVal = 2000000000;
	f_equipment* pfEquipItem = NULL;
	f_equipment* pfItem = NULL;
	ItemMap* pItemMap = getItemMap(EICT_Equip);
	ItemMap::iterator IT = pItemMap->begin();
	while(IT != pItemMap->end())
	{
		pfItem = (f_equipment*)IT->second;

		switch(e)
		{
		case E_MVB_EquipStrongth:
			{
				if(nFindVal > pfItem->get_equip_consolidate_level()
					&& pfItem->get_equip_consolidate_level() < MAX_STRENGTHEN_LEVEL)
				{
					nFindVal = pfItem->get_equip_consolidate_level();
					pfEquipItem = pfItem;
				}
			}
			break;
			// 		case E_MVB_EquipStar:
			// 			{
			// 				if(nFindVal > pfItem->get_star_num()
			// 					&& pfItem->get_star_num() < MAX_STARUP_LEVEL)
			// 				{
			// 					int nSuitID = 0;
			// 					c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT suitId FROM EquipData WHERE typeId = ?1");
			// 					cmd->set_integer32(1 , pfItem->get_item_type_id());
			// 					c_sql_table* table = c_db_manager::getSingleton()->create_table();
			// 					while(table->retrieve_row())
			// 					{
			// 						unsigned int idx = table->get_index("suitId");
			// 						nSuitID = table->get_integer32(idx);
			// 					}
			// 					c_db_manager::getSingleton()->destroy_table(table);
			// 					c_db_manager::getSingleton()->end_operation(cmd);
			// 					if(nSuitID > 0)
			// 					{
			// 						nFindVal = pfItem->get_star_num();
			// 						pfEquipItem = pfItem;
			// 					}
			// 				}
			// 			}
			// 			break;
		case E_MVB_EquipFusion:
			{
				if(nFindVal > pfItem->get_item_quality()
					&& pfItem->get_item_quality() < (int)EIQ_End - 1)
				{
					nFindVal = pfItem->get_item_quality();
					pfEquipItem = pfItem;
				}
			}
			break;
		case E_MVB_Inlay:
			{
				const EquipTypeData* equipData =PackageManager::getInstance()->getEquipTypeData(pfItem->get_item_type_id());
				if (equipData)
				{
					if(equipData->gemHole)
					{
						if(nFindVal > pfItem->get_equip_gem_num())
						{
							nFindVal = pfItem->get_equip_gem_num();
							pfEquipItem = pfItem;
						}
					}
				}
			}
			break;
		case E_MVB_EquipLvUP:
			{
				if(nFindVal > pfItem->get_star_num()&& pfItem->get_star_num() < MAX_STARUP_LEVEL)
				{
					int uplevelTypeId = 0;
					int nMinUseLevel = 0;
// 					c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT Level,levelUpId FROM EquipData WHERE typeId = ?1");
// 					cmd->set_integer32(1 , pfItem->get_item_type_id());
// 					c_sql_table* table = c_db_manager::getSingleton()->create_table();
// 					while(table->retrieve_row())
// 					{
// 						unsigned int idx = table->get_index("Level");
// 						nMinUseLevel = table->get_integer32(idx);
// 						idx = table->get_index("levelUpId");
// 						uplevelTypeId = table->get_integer32(idx);
// 
// 					}
// 					c_db_manager::getSingleton()->destroy_table(table);
// 					c_db_manager::getSingleton()->end_operation(cmd);
					EquipData::iterator iter = _equipData.find(pfItem->get_item_type_id());
					if (iter != _equipData.end())
					{
						nMinUseLevel = iter->second.level;
						uplevelTypeId = iter->second.levelUpId;
					}

					if(uplevelTypeId > 0 && nFindVal > 0)
					{
						nFindVal = nMinUseLevel;
						pfEquipItem = pfItem;
						break;
					}
				}
			}
		}

		IT++;
	}

	//没找到再找背包的
	if(!pfEquipItem)
	{
		pItemMap = getItemMap(EICT_Bag);
		IT = pItemMap->begin();
		while(IT != pItemMap->end())
		{
			if(!MIsEquipment(IT->second->get_item_type_id()))
			{
				IT++;
				continue;
			}

			pfItem = (f_equipment*)IT->second;

			switch(e)
			{
			case E_MVB_EquipStrongth:
				{
					if(nFindVal > pfItem->get_equip_consolidate_level()
						&& pfItem->get_equip_consolidate_level() < MAX_STRENGTHEN_LEVEL)
					{
						nFindVal = pfItem->get_equip_consolidate_level();
						pfEquipItem = pfItem;
					}
				}
				break;
				//case E_MVB_EquipStar:
				//	{
				//		if(nFindVal > pfItem->get_star_num()
				//			&& pfItem->get_star_num() < MAX_STARUP_LEVEL)
				//		{
				// 						int nSuitID = 0;
				// 						c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT suitId FROM EquipData WHERE typeId = ?1");
				// 						cmd->set_integer32(1 , pfItem->get_item_type_id());
				// 						c_sql_table* table = c_db_manager::getSingleton()->create_table();
				// 						while(table->retrieve_row())
				// 						{
				// 							unsigned int idx = table->get_index("suitId");
				// 							nSuitID = table->get_integer32(idx);
				// 						}
				// 						c_db_manager::getSingleton()->destroy_table(table);
				// 						c_db_manager::getSingleton()->end_operation(cmd);
				// 						if(nSuitID > 0)
				// 						{
				// 							nFindVal = pfItem->get_star_num();
				// 							pfEquipItem = pfItem;
				// 						}
				// 					}
				// 				}
				// 				break;
			case E_MVB_EquipFusion:
				{
					if(nFindVal > pfItem->get_item_quality()
						&& pfItem->get_item_quality() < (int)EIQ_End - 1)
					{
						nFindVal = pfItem->get_item_quality();
						pfEquipItem = pfItem;
					}
				}
				break;
			case E_MVB_Inlay:
				{
					const EquipTypeData* equipData =PackageManager::getInstance()->getEquipTypeData(pfItem->get_item_type_id());
					if (equipData)
					{
						if(equipData->gemHole)
						{
							if(nFindVal > pfItem->get_equip_gem_num())
							{
								nFindVal = pfItem->get_equip_gem_num();
								pfEquipItem = pfItem;
							}
						}
					}
				}
				break;
			case E_MVB_EquipLvUP:
				if(nFindVal > pfItem->get_star_num()&& pfItem->get_star_num() < MAX_STARUP_LEVEL)
				{
					int uplevelTypeId = 0;
					int nMinUseLevel = 0;
// 					c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT Level,levelUpId FROM EquipData WHERE typeId = ?1");
// 					cmd->set_integer32(1 , pfItem->get_item_type_id());
// 					c_sql_table* table = c_db_manager::getSingleton()->create_table();
// 					while(table->retrieve_row())
// 					{
// 						unsigned int idx = table->get_index("Level");
// 						nMinUseLevel = table->get_integer32(idx);
// 						idx = table->get_index("levelUpId");
// 						uplevelTypeId = table->get_integer32(idx);
// 
// 					}
// 					c_db_manager::getSingleton()->destroy_table(table);
// 					c_db_manager::getSingleton()->end_operation(cmd);

					EquipData::iterator iter = _equipData.find(pfItem->get_item_type_id());
					if (iter != _equipData.end())
					{
						nMinUseLevel = iter->second.level;
						uplevelTypeId = iter->second.levelUpId;
					}

					if(uplevelTypeId > 0 && nFindVal > 0)
					{
						nFindVal = nMinUseLevel;
						pfEquipItem = pfItem;
						break;
					}
				}
			}
			IT++;
		}
	}

	//找到了做操作
	if(pfEquipItem)
	{
		switch(e)
		{
		case E_MVB_EquipStrongth:
			{
				if(nFindVal < MAX_STRENGTHEN_LEVEL)
				{
					EquipFusionManager::getInstance()->setEquipment(pfEquipItem);
					OPEN_UI(WCT_STRENGTHENUI);
				}
				else
					pfEquipItem = NULL;
			}
			break;
			// 		case E_MVB_EquipStar:
			// 			{
			// 				if(nFindVal < MAX_STARUP_LEVEL)
			// 				{
			// 					int m_nSuitID = 0;
			// 					EEquipPos equipPosIndex = EEP_Null;
			// 					c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT suitId,PosIndex FROM EquipData WHERE typeId = ?1");
			// 					cmd->set_integer32(1 , pfEquipItem->get_item_type_id());
			// 					c_sql_table* table = c_db_manager::getSingleton()->create_table();
			// 					while(table->retrieve_row())
			// 					{
			// 						unsigned int idx = table->get_index("suitId");
			// 						m_nSuitID = table->get_integer32(idx);
			// 						idx = table->get_index("PosIndex");
			// 						equipPosIndex = (EEquipPos)table->get_integer32(idx);
			// 					}
			// 					c_db_manager::getSingleton()->destroy_table(table);
			// 					c_db_manager::getSingleton()->end_operation(cmd);
			// 
			// 					//点击的装备添加到融合管理中[yu]
			// 					EquipUpStarUIMgr::getInstance()->setEquipment(pfEquipItem);
			// 					EquipUpStarUIMgr::getInstance()->setEquipSuitId(m_nSuitID); //将原装备套装id保存
			// 					EquipUpStarUIMgr::getInstance()->setEquipPos(equipPosIndex);		 //将原装备部位保存
			// 
			// 					//发送获取下一级装备数据的请求
			// 					EquipUpStarUIMgr::getInstance()->removeEquipNext();
			// 					WorldPacket C2G_Msg(NET_C2G_REQUEST_EQUIP_STAR_LEVEL_UP);//组装消息头
			// 					C2G_Msg << pfEquipItem->get_item_id();
			// 					TCP_CLIENT->send_net_cmd((const s_net_cmd*)C2G_Msg.contents(), NP_NORMAL, false);//发送
			// 
			// 					OPEN_UI(WCT_EQUIPUPSTARUI);
			// 				}
			// 				else
			// 					pfEquipItem = NULL;
			// 			}
			// 			break;
		case E_MVB_EquipFusion:
			{
				if(nFindVal < (int)EIQ_End - 1)
				{
					EquipFusionManager::getInstance()->setEquipment(pfEquipItem);
					OPEN_UI(WCT_EquipFusionUi);
				}
				else
					pfEquipItem = NULL;
			}
			break;
		case E_MVB_Inlay:
			{
				if(nFindVal < pfEquipItem->get_equip_max_hole_num())
				{
					EquipFusionManager::getInstance()->setEquipment(pfEquipItem);
					OPEN_UI(WCT_InlayUi);
				}
				else
					pfEquipItem = NULL;
			}
			break;
		case E_MVB_EquipLvUP:
			{
				if(pfEquipItem->get_star_num() < 3)
				{
					EquipLevelUpUiMgr::getInstance()->setEquipment(pfEquipItem);
					OPEN_UI(WCT_EquipLevelUpUi);
				}
				else
				{
					pfEquipItem = NULL;
				}
			}
			break;
		}

	}

	if(pfEquipItem == NULL)
	{
		switch(e)
		{
		case E_MVB_EquipStrongth:
			ToolTip::getInstance()->push(GET_STR(9368).c_str());
			break;
			// 		case E_MVB_EquipStar:
			// 			ToolTip::getInstance()->push("\xE6\xB2\xA1\xE6\x9C\x89\xE5\x8F\xAF\xE5\x8D\x87\xE6\x98\x9F\xE8\xA3\x85\xE5\xA4\x87");
			// 			break;
		case E_MVB_EquipFusion:
			ToolTip::getInstance()->push(GET_STR(9370).c_str());
			break;

		case E_MVB_Inlay:
			ToolTip::getInstance()->push(GET_STR(9371).c_str());
			break;
		case E_MVB_EquipLvUP:
			ToolTip::getInstance()->push(GET_STR(9372).c_str());
			break;
		}
	}
}

void PackageManager::updateUiWithConTypeEx( EItemConType conType, short idx )
{
	switch(conType)
	{
	case EICT_Bag:
		GET_UI(Package, WCT_PACKAGEUI)->updateData();
		break;
	case EICT_RoleWare:
		GET_UI(Storage, WCT_StorageUi)->updateData();
		break;
	case EICT_Equip:
		GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI)->updateEquipment();
		GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI)->updateDisplay();
		GET_UI(RoleRingUi,WCT_ROLERINGUI)->updateEquipment();
		GET_UI(RoleRingUi,WCT_ROLERINGUI)->updateDisplay();
		GET_UI(MountUi, WCT_MountUi)->updateData();
		break;
	case EICT_KungfuWare:
		//UI刷新
		GET_UI(WuXueUi,WCT_WUXUEUI)->updateWare();
		break;
	case EICT_KungfuTemp:
		//UI刷新
		GET_UI(CangJingGeUi, WCT_CangJingGeUi)->updateGongFaTemp(idx);
		break;
	case EICT_KungfuBag:
		//UI刷新
		GET_UI(WuXueUi,WCT_WUXUEUI)->updateMartialData();
		break;
	case EICT_KungfuEquip:
		//UI刷新
		GET_UI(WuXueUi,WCT_WUXUEUI)->updateEquip();
		break;
	case EICT_StallItem:
		//UI刷新
		GET_UI(NewStallUi,WCT_NEW_STALLUI)->UpdateStallItem();
		break;
	}
}

int PackageManager::getConsumeRewardNeedCost( int rewardLv )
{
	if(0 > rewardLv || 4 < rewardLv)
		return 10000000;								//错误，返回错误一个较大的值【J】2014.12.12
	//int needCostYB = 0; 

	// 	c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM ConsumeReward WHERE ID = ?1");
	// 	cmd->set_integer32(1 , rewardLv + 1);
	// 	c_sql_table* table = c_db_manager::getSingleton()->create_table();
	// 	while(table->retrieve_row())
	// 	{
	// 		unsigned int idx = table->get_index("YuanBao");
	// 		needCostYB = table->get_integer32(idx);				
	// 	}
	// 	c_db_manager::getSingleton()->destroy_table(table);
	// 	c_db_manager::getSingleton()->end_operation(cmd);

	return mneedCostYBTable[rewardLv];
}

//批量使用
unsigned int PackageManager::onAllUseGoodManCardResult( s_net_cmd *cmd )
{
	NET_SIS_AllUse_Good_Man_Card* msg = (NET_SIS_AllUse_Good_Man_Card*)cmd;
	if (E_Success == msg->dwErrorCode)
	{
		std::stringstream ostr;
		ostr<<msg->dwRedPKValue;
		string str = replaceStr(GET_STR(9428),"*",ostr.str());
		ToolTip::getInstance()->push(str.c_str());
		return 0;
	}
	else
	{
		return 0;
	}
}

//使用修复神水结果
unsigned int PackageManager::onUseRepairWaterResult( s_net_cmd *cmd )
{
	NET_SIS_abrase_stone* msg = (NET_SIS_abrase_stone*)cmd;
	if (E_Success == msg->dw_error_code) //修理成功
	{
		ToolTip::getInstance()->push(GET_STR( 7149 ));
		//刷新人物装备显示
		RoleEquipUi* roleEquipUi=GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI);
		if(roleEquipUi)
		{
			roleEquipUi->updateEquipment();
		}
		return 0;
	}
	else if( E_Equip_Not_Abrase == msg->dw_error_code) //装备未磨损
	{
		ToolTip::getInstance()->push(GET_STR( 7148 ));
		return 0;
	}
	else
	{
		return 0;
	}
}

f_equipment* PackageManager::createEquip(const tagEquip& tmptagEquip)
{
	f_equipment* eq = (f_equipment*)getItem((EItemConType)tmptagEquip.eConType, tmptagEquip.n16Index);
	if (eq)
	{
		eq->update(tmptagEquip);
	}
	else
	{
		eq = new f_equipment(tmptagEquip);
		addNewItem(eq);//调用添加一个新物品
	}
	return eq;
}

bool PackageManager::IsAddItem( f_equipment* pitem )
{
	LocalPlayer *role = RoleManager::getInstance()->getLocalPlayer();
	//f_equipment* equip = dynamic_cast<f_equipment*>(pitem);
	INT itemType = pitem->get_equip()->EquipAttitionalAtt->eRoleAtt;
	if (role->GetRoleData(RA_ROLETYPE) == EV_Warrior)
	{
		if (itemType == ERA_InAttackMin || itemType == ERA_InAttackMax || itemType == ERA_ArmorEx || itemType == ERA_ArmorIn)
		{
			return false;
		}
	}

	if (role->GetRoleData(RA_ROLETYPE) == EV_Mage)
	{
		if (itemType == ERA_ExAttackMin || itemType == ERA_ExAttackMax || itemType == ERA_ArmorEx || itemType == ERA_ArmorIn)
		{
			return false;
		}
	}

	if (role->GetRoleData(RA_ROLETYPE) == EV_Taoist)
	{
		if (itemType == ERA_InAttackMin || itemType == ERA_InAttackMax || itemType == ERA_ExAttackMin || itemType == ERA_ExAttackMax)
		{
			return false;
		}
	}


	return true;

}

bool PackageManager::IsAddItem( int id )
{
	c_sql_command* cmd = NULL;
	c_sql_table* table = NULL;
	INT itemType0 = -1;
	INT itemType1 = -1;
	cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM EnchaseData WHERE id = ?1");
	cmd->set_integer32(1 , id);
	table = c_db_manager::getSingleton()->create_table();
	while(table->retrieve_row())
	{
		unsigned int idx = table->get_index("RoleAtt0");
		itemType0 =  table->get_integer32(idx);
		idx = table->get_index("RoleAtt1");
		itemType1 =  table->get_integer32(idx);
	}

	c_db_manager::getSingleton()->destroy_table(table);
	c_db_manager::getSingleton()->end_operation(cmd);
	LocalPlayer *role = RoleManager::getInstance()->getLocalPlayer();
	if (role->GetRoleData(RA_ROLETYPE) == EV_Warrior)
	{
		if (itemType0 == ERA_InAttackMin || itemType0 == ERA_InAttackMax || itemType0 == ERA_ArmorEx || itemType0 == ERA_ArmorIn)
		{
			return false;
		}
		if (itemType1 == ERA_InAttackMin || itemType1 == ERA_InAttackMax || itemType1 == ERA_ArmorEx || itemType1 == ERA_ArmorIn)
		{
			return false;
		}
	}

	if (role->GetRoleData(RA_ROLETYPE) == EV_Mage)
	{
		if (itemType0 == ERA_ExAttackMin || itemType0 == ERA_ExAttackMax || itemType0 == ERA_ArmorEx || itemType0 == ERA_ArmorIn)
		{
			return false;
		}
		if (itemType1 == ERA_ExAttackMin || itemType1 == ERA_ExAttackMax || itemType1 == ERA_ArmorEx || itemType1 == ERA_ArmorIn)
		{
			return false;
		}
	}

	if (role->GetRoleData(RA_ROLETYPE) == EV_Taoist)
	{
		if (itemType0 == ERA_InAttackMin || itemType0 == ERA_InAttackMax || itemType0 == ERA_ExAttackMin || itemType0 == ERA_ExAttackMax)
		{
			return false;
		}
		if (itemType1 == ERA_InAttackMin || itemType1 == ERA_InAttackMax || itemType1 == ERA_ExAttackMin || itemType1 == ERA_ExAttackMax)
		{
			return false;
		}
	}


	return true;
}

bool PackageManager::isShowEquipUp( f_equipment* pEquip )
{
	if (!pEquip)
	{
		return false;
	}
	const EquipTypeData* equipPtr =PackageManager::getInstance()->getEquipTypeData(pEquip->get_item_type_id());
	CC_ASSERT(equipPtr);
	const EquipTypeData& equipData = *equipPtr;
	int equipRoleType = RT_End;
	if(equipData.profession2 == PROFESSION1 || equipData.profession2 == PROFESSION4 || equipData.profession2 == PROFESSION7)
	{
		equipRoleType = RT_Warrior;
	}
	else if (equipData.profession2 == PROFESSION2 || equipData.profession2 == PROFESSION5 || equipData.profession2 == PROFESSION8)
	{
		equipRoleType = RT_Mage;
	}
	else if (equipData.profession2 == PROFESSION3 || equipData.profession2 == PROFESSION6 || equipData.profession2 == PROFESSION9)
	{
		equipRoleType = RT_Taoist;
	}
	else if (equipData.profession2 == PROFESSION10 || equipData.profession2 == PROFESSION11 || equipData.profession2 == PROFESSION12)
	{
		equipRoleType = RT_End;
	}
	LocalPlayer* localPlayer = RoleManager::getInstance()->getLocalPlayer();
	int roleType = localPlayer->getAttribute(RA_ROLETYPE);
	if (equipRoleType == RT_End)
	{
		equipRoleType = roleType;
	}
	PackageManager::ItemMap* itemMap = PackageManager::getInstance()->getItemMap(EICT_Equip);
	f_equipment* roleEquip;
	int roleFight;
	if (equipData.posIndex == EEP_Wrist1 || equipData.posIndex == EEP_Wrist2 || equipData.posIndex == EEP_Finger1 || equipData.posIndex == EEP_Finger2)
	{
		int roleFightOne;
		int roleFightTwo;
		f_equipment* roleEquipOne;
		f_equipment* roleEquipTwo;
		if (equipData.posIndex == EEP_Wrist1 || equipData.posIndex == EEP_Wrist2)
		{
			roleEquipOne = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)EEP_Wrist1));
			roleEquipTwo = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)EEP_Wrist2));
		}
		else if (equipData.posIndex == EEP_Finger1 || equipData.posIndex == EEP_Finger2)
		{
			roleEquipOne = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)EEP_Finger1));
			roleEquipTwo = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)EEP_Finger2));
		}
		if (roleEquipOne && roleEquipTwo)
		{

			roleFightOne = Rating_Helper::getInstance()->GetNoGemRating(roleEquipOne->get_equip(),equipRoleType - 1);
			roleFightTwo =  Rating_Helper::getInstance()->GetNoGemRating(roleEquipTwo->get_equip(),equipRoleType - 1);
			if (roleFightOne < roleFightTwo)
			{
				roleEquip = roleEquipOne;
				roleFight = roleFightOne;
			}
			else
			{
				roleEquip = roleEquipTwo;
				roleFight = roleFightTwo;
			}
		}
		else
		{
			roleEquip = NULL;
			roleFight = -1;
		}
	}
	else
	{
		roleEquip = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)equipData.posIndex));
		if (roleEquip)
		{
			roleFight = Rating_Helper::getInstance()->GetNoGemRating(roleEquip->get_equip(),equipRoleType - 1);
		}
	}
	if (roleEquip)
	{
		const tagEquipSpec* tes = pEquip->get_equip();
		int fight = Rating_Helper::getInstance()->GetNoGemRating(tes,equipRoleType - 1);
		if (fight > roleFight)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return true;
	}
	return false;
}

void PackageManager::sendItemPositionChange(f_item* item,EItemConType destConType,short pos)
{
	//身上装备合成
	NET_SIC_item_position_change_extend cmd;
	cmd.eConTypeSrc = item->get_container_type();
	cmd.eConTypeDst = destConType;
	cmd.n64Serial1 = item->get_item_id();
	cmd.n16PosDst = pos;
	cmd.dwNPCID = StoreMgr::getInstance()->getNpcServerId();
	TCP_CLIENT->send_net_cmd(&cmd, NP_IDLE, false);
	lockItem(cmd.eConTypeSrc, item->get_pos());
	lockItem(destConType, pos);
}
unsigned int PackageManager::onGemExchange(s_net_cmd*cmd){
	//NET_SIS_gem_exchange* msg=(NET_SIS_gem_exchange*)cmd;
	if(cmd->id == message_id_crc("NET_SIS_gem_exchange"))
	{
		NET_SIS_gem_exchange *msg = (NET_SIS_gem_exchange*)cmd;
		if(msg->dw_error_code == 0)
		{
			GET_UI(InlayUi, WCT_InlayUi)->onServerInlay(true);
			GET_UI(InlayUi, WCT_InlayUi)->runInlayEffect();
			GET_UI(RoleEquipUi, WCT_ROLEEQUIPUI)->updateEquipment();
			//GET_UI(InlayUi, WCT_InlayUi)->getUiLayer()->update();
			ToolTip::getInstance()->push("\xE5\xAE\x9D\xE7\x9F\xB3\xE9\x95\xB6\xE5\xB5\x8C\xE6\x88\x90\xE5\x8A\x9F"); //宝石镶嵌成功
		}
		else
		{
			switch (msg->dw_error_code)
			{
			case E_Consolidate_EquipCanNotInlay:
				ToolTip::getInstance()->push(GET_STR(2008));
				break;
			case E_Consolidate_Gem_Not_Hole:
				ToolTip::getInstance()->push(GET_STR(2010));
				break;
			case E_Consolidate_Shipingqu_Not:
				ToolTip::getInstance()->push(GET_STR(2117));
				break ;
			case E_Consolidate_Gem_level_not:
				ToolTip::getInstance()->push(GET_STR(2118));
				break;
			default:
				break;
			}
			GET_UI(InlayUi, WCT_InlayUi)->onServerInlay(false);
		}
	}

	return 0;
}
PackageManager::ItemMap PackageManager::GetGemList(EItemConType contype){ //获取背包中所有的宝石
	m_GemMap.clear();
	short nidx=0;
	PackageManager::ItemMap* TmpItemMap = PackageManager::getInstance()->getItemMap(contype);
	PackageManager::ItemMap::iterator iter = TmpItemMap->begin();
	while(iter != TmpItemMap->end())
	{
		const ItemTypeData& ItemType = PackageManager::getInstance()->getItemTypeData(iter->second->get_item_type_id());
		if(ItemType.type == PIT_XiangQianMat)
		{
			//当找到是宝石 就把它放到我们自己的map里
			m_GemMap.insert(std::make_pair(nidx++,  (f_item*)iter->second));
		}

		iter++;
	}
	return m_GemMap;
}
void PackageManager::changePositionForDressEquip()
{//穿戴装备相关位置变换
	if (_srcEquip == NULL)
		return;

	LocalPlayer* player = RoleManager::getInstance()->getLocalPlayer();
	if (player == NULL)
		return;

	if (_srcEquip == NULL)
		return;

	const EquipTypeData* srcEquipData = getEquipTypeData(_srcEquip->get_item_type_id());
	CC_ASSERT(srcEquipData);
	if (srcEquipData->minUseLevel > player->getLevel())
	{
		ToolTip::getInstance()->push(GET_STR(2017));
		return;
	}
	INT64 itemId = _srcEquip->get_item_id();
	short dest = changeDest(_srcEquip);
	PackageUi* layer = getUiNodeByTag<PackageUi>(WCT_PACKAGEUI);
	NET_SIC_equip cmd;
	cmd.n64_serial = itemId;
	cmd.ePosDst = (EEquipPos)(dest);
	TCP_CLIENT->send_net_cmd(&cmd, NP_NORMAL, false);
	_tmpEquipData[itemId] = (EEquipPos)dest;
	if(layer == NULL) return;
	int page = layer->GetSelectPage();
	short src = (short)(layer->GetSelectIndex() + page * HORIZONTALCOUNT * VERTICALCOUNT);
	if (GetIsImmediateEqui())
	{
		src = -1;
	}
	lockItem(EICT_Bag, src);
	lockItem(EICT_Equip, dest);
}

void PackageManager::replaceGem(){   //替换装备时宝石替换
	if (_srcEquip && _descEquip)
	{
		NET_SIC_gem_exchange msg;
		msg.src_Equip_Id = _srcEquip->get_item_id();
		msg.desc_Equip_Id = _descEquip->get_item_id();
		TCP_CLIENT->send_net_cmd(&msg, NP_NORMAL, false);
		changePositionForDressEquip();
	}
}
std::string PackageManager::GetNameByLevel(EquipTypeData data,int level){
	string LevelName; //名称的前缀，0级为空，1级为黄金，2级为至尊，3级为传奇
	if(level==0){
		LevelName="";
	}else if(level==1){
		LevelName=data.LevelName[0];
	}else if(level==2){
		LevelName=data.LevelName[1];
	}else{
		LevelName=data.LevelName[2];
	}
	return LevelName;
}
void PackageManager::initCostYB()
{
	// 	if(0 > rewardLv || 4 < rewardLv)
	// 		return 10000000;								//错误，返回错误一个较大的值【J】2014.12.12
	int needCostYB = 0; 

	for (int i = 0; i <=4  ; ++i)
	{
		c_sql_command* cmd = c_db_manager::getSingleton()->begin_operation("SELECT * FROM ConsumeReward WHERE ID = ?1");
		cmd->set_integer32(1 , i + 1);
		c_sql_table* table = c_db_manager::getSingleton()->create_table();
		while(table->retrieve_row())
		{
			unsigned int idx = table->get_index("YuanBao");
			needCostYB = table->get_integer32(idx);
			mneedCostYBTable.push_back(needCostYB);
		}
		c_db_manager::getSingleton()->destroy_table(table);
		c_db_manager::getSingleton()->end_operation(cmd);
	}


	//return mneedCostYBTable;
}

bool PackageManager::isEquipCanImmediateEquip(f_equipment *pEquip)
{
	//当拾取装备时，用于判断是否需要提示立即装备Ui
	if (!pEquip)
	{
		return false;
	}
	const EquipTypeData* equipPtr =PackageManager::getInstance()->getEquipTypeData(pEquip->get_item_type_id());
	CC_ASSERT(equipPtr);
	const EquipTypeData& equipData = *equipPtr;
	int equippSex = equipData.bySex;
	int equipRoleType = RT_End;

	if(equipData.profession2 == PROFESSION1 || equipData.profession2 == PROFESSION4 || equipData.profession2 == PROFESSION7)
	{
		equipRoleType = RT_Warrior;
	}
	else if (equipData.profession2 == PROFESSION2 || equipData.profession2 == PROFESSION5 || equipData.profession2 == PROFESSION8)
	{
		equipRoleType = RT_Mage;

	}
	else if (equipData.profession2 == PROFESSION3 || equipData.profession2 == PROFESSION6 || equipData.profession2 == PROFESSION9)
	{
		equipRoleType = RT_Taoist;
	}
	else if (equipData.profession2 == PROFESSION10 || equipData.profession2 == PROFESSION11 || equipData.profession2 == PROFESSION12)
	{
		equipRoleType = RT_End;
	}
	LocalPlayer* localPlayer = RoleManager::getInstance()->getLocalPlayer();
	int roleType = localPlayer->getAttribute(RA_ROLETYPE);
	int roleSex = localPlayer->getAttribute(RA_SEX);
	if ((equippSex != roleSex) && (equippSex != -1))                            //装备性别与玩家性别判断
	{
		return false;
	}
	if ((roleType == equipRoleType) || (equipRoleType == RT_End))                //装备职业判断
	{
		if ((equipData.minUseLevel) <= (localPlayer->getLevel()))                                  //装备等级与玩家等级判断 
		{
			PackageManager::ItemMap* itemMap = PackageManager::getInstance()->getItemMap(EICT_Equip);
			f_equipment* roleEquip;
			int roleFight;
			if (equipData.posIndex == EEP_Wrist1 || equipData.posIndex == EEP_Wrist2 || equipData.posIndex == EEP_Finger1 || equipData.posIndex == EEP_Finger2)
			{
				int roleFightOne;
				int roleFightTwo;
				f_equipment* roleEquipOne=nullptr;
				f_equipment* roleEquipTwo=nullptr;
				if (equipData.posIndex == EEP_Wrist1 || equipData.posIndex == EEP_Wrist2)
				{
					roleEquipOne = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)EEP_Wrist1));
					roleEquipTwo = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)EEP_Wrist2));
				}
				else if (equipData.posIndex == EEP_Finger1 || equipData.posIndex == EEP_Finger2)
				{
					roleEquipOne = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)EEP_Finger1));
					roleEquipTwo = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)EEP_Finger2));
				}
				if (roleEquipOne && roleEquipTwo)
				{

					roleFightOne = Rating_Helper::getInstance()->GetNoGemRating(roleEquipOne->get_equip(),equipRoleType - 1);
					roleFightTwo =  Rating_Helper::getInstance()->GetNoGemRating(roleEquipTwo->get_equip(),equipRoleType - 1);
					if (roleFightOne < roleFightTwo)
					{
						roleEquip = roleEquipOne;
						roleFight = roleFightOne;
					}
					else
					{
						roleEquip = roleEquipTwo;
						roleFight = roleFightTwo;
					}
				}
				else
				{
					return true;
				}
			}
			else
			{
				roleEquip = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(*itemMap, (short)equipData.posIndex));
				if (roleEquip)
				{
					roleFight = Rating_Helper::getInstance()->GetNoGemRating(roleEquip->get_equip(),equipRoleType - 1);
				}
				else
				{

					return true;
				}
			}

			if (roleEquip)                           
			{
				const tagEquipSpec* tes = pEquip->get_equip();
				int fight = Rating_Helper::getInstance()->GetNoGemRating(tes,equipRoleType - 1);
				if (fight > roleFight)                        //装备战斗力比较
				{
					return true;
				}
				else
				{
					return false;
				}
			}
			return false;

		}
		else
		{
			return false;
		}
	}
	return false;
}

bool PackageManager::wearSBKMasterEquip()
{
	ItemMap *itemMap = getItemMap(EICT_Equip);

	f_item *item = getItem(*itemMap, short(EEP_Fashion));
	if(item == NULL)
		return false;

	return item->get_item_type_id() == 9431003 || item->get_item_type_id() == 9430003;		
}

void PackageManager::delayDestroy()
{
	destroyAllIconFrames();
	destoryCon(EICT_Bag);
	destoryCon(EICT_Equip);
	destoryCon(EICT_RoleWare);
	destoryCon(EICT_KungfuEquip);
	destoryCon(EICT_KungfuBag);
	destoryCon(EICT_KungfuWare);
	destoryCon(EICT_KungfuTemp);
	destoryCon(EICT_StallItem);
	destoryCon(EICT_EquipShow);
	_tmpKungfuIDMap.clear();

	_recharge_period = 0;
	_recharge_feedback = 0;
	_feedback_times = 0;
	m_CurBoxGamle_RewardIdx = 0;
	m_cCurBoxType = NULL;
	m_bIsBoxOK = true;

	_conSize[EICT_KungfuBag] = MAX_KUNGFU_BAG_NUM;
	_conSize[EICT_KungfuTemp] = MAX_KUNFFU_TEMP_NUM;
	_conSize[EICT_KungfuWare] = MAX_KUNGFU_WARE_NUM;
	_conSize[EICT_KungfuEquip] = /*MAX_GONGFA_EQUIP_NUM*/f_formula_helper::get_magic_soul_slot_max_num();
}

void PackageManager::onPackageItemChanged( unsigned int itemId, bool isAdded/* = true */)
{
	ItemTypeData itemType = getItemTypeData(itemId);
	int itemNum = getItemNumber(EICT_Bag, itemId);
	if (itemType.type == PIT_Forging || itemType.type == PIT_UpLevelMat3)
	{
		if (isAdded)
		{
			ForgingMgr::getInstance()->judgeForgingByItem(itemId, itemNum);
		}else
		{
			ForgingMgr::getInstance()->judgeForgingByItem();
			ForgingMgr::getInstance()->judgeDecomposeByEquip();
		}
	}
}

int PackageManager::getRoleMinEquipLevel()
{
	ItemMap *roleEquipMap = getItemMap(EICT_Equip);
	if (!roleEquipMap->empty())
	{
		int equipLevel = 200;
		ItemMap::iterator iter = roleEquipMap->begin();
		for (; iter != roleEquipMap->end(); iter++)
		{
			int t_id = iter->second->get_item_type_id();
			const EquipTypeData* equipData = getEquipTypeData(t_id);
			CC_ASSERT(equipData);
			if (equipLevel > equipData->level)
			{
				equipLevel = equipData->level;
			}
		}
		return equipLevel;
	}
	return -1;
}

void PackageManager::AutoUseExpCard(INT64 itemId)
{
	NET_SIC_use_item cmd;
	LocalPlayer *role = RoleManager::getInstance()->getLocalPlayer();
	CCPoint pos = role->getPosition();
	cmd.vSrcPos[0] = pos.x;
	cmd.vSrcPos[2] = pos.y;
	cmd.dwTargetRoleID = role->getId();
	cmd.n64ItemID = itemId;
	cmd.byUseType = 0;
	TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);
}
bool PackageManager::isItemNumEnough( unsigned int typeId,int needNum,std::vector<INT64>& itemList )
{
	ItemMap* bagMap = getItemMap(EICT_Bag);
	if (bagMap == NULL)
		return false;

	if (bagMap->empty())
		return false;
	int count = 0;
	//优先绑定的道具
	for (ItemMap::iterator iter = bagMap->begin();iter != bagMap->end(); ++iter)
	{
		f_item* item = iter->second;
		if (item == NULL)
			continue;

		if (item->get_item_type_id() != typeId)
			continue;

		if (item->get_item_number() <= 0)
			continue;

		if (item->get_data()->IsBind() == false)
			continue;

		itemList.push_back(item->get_item_id());
		count += item->get_item_number();
		//如果数量足够
		if (count >= needNum)
			return true;
	}

	//非绑定的道具
	for (ItemMap::iterator iter = bagMap->begin();iter != bagMap->end(); ++iter)
	{
		f_item* item = iter->second;
		if (item == NULL)
			continue;

		if (item->get_item_type_id() != typeId)
			continue;

		if (item->get_item_number() <= 0)
			continue;

		if (item->get_data()->IsBind())
			continue;

		itemList.push_back(item->get_item_id());
		count += item->get_item_number();
		//如果数量足够
		if (count >= needNum)
			return true;
	}
	return false;
}

unsigned int PackageManager::onEquipStrengthenResult(s_net_cmd *cmd)
{
	StrengthenUiLayer* layer = GET_UI(StrengthenUi,WCT_STRENGTHENUI)->getUiLayer();
	if(layer != NULL)
	{
		layer->setIsSuccess(true);
		//_strengTimesLabel->setString(CCString::createWithFormat("%d",_stringCurTimes)->getCString());

		PackageManager::getInstance()->onEquipStrengthen(cmd);
		layer->setEquipDataInTable();
		layer->setStrengthenData();
		layer->updateEquipBaseDate();
		layer->updateEquipStrengDate();
		//[bing] 强化结束以后刷新新手引导
		CCLOG("onEquipStrengthenResult");
		NewPlayerGuider::getInstance()->RunNewPlayerGuilde();
	}
	return 0;
}

void PackageManager::checkFusionItemUpdateifNess( f_item* pItem )
{
	if (pItem->get_item_type_id()== FUSION_RANDOM_BOOK)
	{
		UpdateFusionFu evt;
		SEND_EVENT(&evt);
	}
}

void PackageManager::checkSBKEquipUpdateIfNess( f_item* pItem )
{
	bool inEquip = pItem->get_container_type() == EICT_Equip;
	bool inFasionPos  = pItem->get_pos() == (short)EEP_Fashion;
	unsigned int model_id = pItem->get_item_type_id();
	bool need_update= inEquip && inFasionPos &&(model_id == 9431003 || model_id == 9430003);

	if (need_update)
	{
		SBKEquipEffectUpdate evt;
		evt.show = false;
		SEND_EVENT(&evt);
	}
}

void PackageManager::confirmCoerceUseItem()
{
	if (getLastUseItem() == 0)
		return;
	f_item *item = getItem(_pocket, getLastUseItem());//通过id在背包找到物品
	if (item == NULL)
		return;
	LocalPlayer *role = RoleManager::getInstance()->getLocalPlayer();
	if (role == NULL)
		return;

	if(_canUseItem)
	{
		NET_SIC_use_item cmd;
		CCPoint pos = role->getPosition();
		cmd.vSrcPos[0] = pos.x;
		cmd.vSrcPos[2] = pos.y;
		cmd.dwTargetRoleID = role->getId();
		cmd.n64ItemID = item->get_item_id();
		cmd.byUseType = EUIT_CoerceUse;
		TCP_CLIENT->send_net_cmd(&cmd, NP_CRITICAL, false);
		setLastUseItem(0);
		_canUseItem = false;
	}
}

void PackageManager::setLastUseItem( INT64 n64Item )
{
	n64_lastUseItem = n64Item;
}

INT64 PackageManager::getLastUseItem()
{
	return n64_lastUseItem;
}

bool PackageManager::init_recast_data_table()
{
	m_recast_data.clear();

	f_data_set dataset;
	std::list<std::string> fields;
	bool ret =dataset.load("Config/EquipRecast.xml","id",&fields);
	CC_ASSERT(ret);

	std::for_each(fields.begin(),fields.end(),[&](std::string const& one)
	{
		EquipRecastData data;

		data.id = dataset.get_int("id",one.c_str(),0);
		data.src_equip_id = dataset.get_int("oldEquipId",one.c_str(),0);
		data.dest_equip_id = dataset.get_int("newEquipId",one.c_str(),0);
		data.item_id_1 = dataset.get_int("needItem1",one.c_str(),0);
		data.item_id_2 = dataset.get_int("needItem2",one.c_str(),0);
		data.item_num_1 = dataset.get_int("needNum1",one.c_str(),0);
		data.item_num_2 = dataset.get_int("needNum2",one.c_str(),0);
		data.rebate_num = dataset.get_float("discuntPrice",one.c_str(),0.0);
		data.rebate_time = dataset.get_int("discuntTime",one.c_str(),0);
		data.need_lv = dataset.get_int("need_lv",one.c_str(),0);

		m_recast_data.insert(std::make_pair(data.src_equip_id, data));
	});

	return true;
}

bool PackageManager::is_put_in_recast_list(DWORD type_id)
{
	for(map_recast_data::iterator iter = m_recast_data.begin(); iter != m_recast_data.end(); ++iter)
	{
		if(iter->second.src_equip_id == type_id)
		{
			return true;
		}
	}
	return false;
}

bool sort_all_recast_equip(const EquipRecastRebateInfo &info1,const EquipRecastRebateInfo &info2)
{
	f_equipment* equip1 = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(info1.equip_id));
	if(!IS_VALID_PTR(equip1))
		return false;

	f_equipment* equip2 = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(info2.equip_id));
	if(!IS_VALID_PTR(equip2))
		return false;

	EItemConType container_type_1 = equip1->get_container_type();
	EItemConType container_type_2 = equip2->get_container_type();
	if(container_type_1 != container_type_2)
	{
		return container_type_1 == EICT_Equip;
	}

	if(container_type_1 == EICT_Equip)
	{
		const EquipTypeData* equip_type_data1 =PackageManager::getInstance()->getEquipTypeData(equip1->get_item_type_id());
		const EquipTypeData* equip_type_data2 =PackageManager::getInstance()->getEquipTypeData(equip2->get_item_type_id());
		CC_ASSERT(equip_type_data1);
		CC_ASSERT(equip_type_data2);

		return equip_type_data1->posIndex < equip_type_data2->posIndex;
	}
	else if(container_type_1 == EICT_Bag)
	{
		return equip1->get_pos() < equip2->get_pos();
	}

	return true;
}

ItemTypeData const* PackageManager::get_item_proto_ptr( unsigned int model_id ) const
{
	auto iter = _itemData.find(model_id);
	if(iter != _itemData.end())
	{
		return &iter->second;
	}

	return NULL;
}

const EquipRecastData& PackageManager::get_one_recast_data(DWORD equip_type_id)
{
	map_recast_data::iterator iter = m_recast_data.find(equip_type_id);
	if (iter != m_recast_data.end())
	{
		const EquipRecastData& data = iter->second;
		return data;
	}
	const EquipRecastData& temp_data = m_recast_data.begin()->second;
	return temp_data;
}

const EquipRecastRebateInfo& PackageManager::get_one_recast_item_data(INT64 equip_id)
{
	vector_recast_item::iterator iter = m_all_recast_item.begin();
	for(; iter != m_all_recast_item.end(); ++iter)
	{
		if(iter->equip_id == equip_id)
		{
			return *iter;
		}
	}
	return *m_all_recast_item.begin();
}

unsigned int PackageManager::onReciveRecastCondition(s_net_cmd *cmd)
{
	NET_SIS_Equip_Recast_Activity * msg = (NET_SIS_Equip_Recast_Activity*)cmd;
	CC_ASSERT(msg);

	m_recast_need_level = msg->nLevel;
	m_recast_need_recharge = msg->nRecharge;
	m_open_behaviour = (eOpenBehaviour)msg->byBehavior;

	for(int i = 0; i < open_condition_num; ++i)
	{
		m_open_condition[i] = msg->byCondition[i];
		m_open_condition_num[i] = msg->byConditionNum[i];
	}

	m_recast_begin_time = msg->dwStartTime;
	m_recast_end_time = msg->dwEndTime;
	m_is_total_open = msg->isOpen;

	m_is_open_recast = if_open_recast_init();

	set_is_open_recast(e_online);

	return 0;
}

unsigned int PackageManager::onReciveRecastInfo(s_net_cmd *cmd)
{
	NET_SIS_Equip_Recast_Discount * msg = (NET_SIS_Equip_Recast_Discount*)cmd;
	CC_ASSERT(msg);

	//m_all_recast_item.clear();
	m_all_recast_rebate_map.clear();
	for (int i = 0; i < msg->n16Num; i++)
	{
		sEquipRecastDiscount temp1;
		memcpy(&temp1,&msg->info[i],sizeof(sEquipRecastDiscount));
// 		memset(&temp1,0,sizeof(sEquipRecastDiscount));
// 		temp1.dwId = msg->info[i].dwId;
// 		temp1.byDiscunt = msg->info[i].byDiscunt;
// 		temp1.dwStartTime = msg->info[i].dwStartTime;
// 		temp1.dwEndTime = msg->info[i].dwEndTime;
		m_all_recast_rebate_map.insert(std::make_pair(msg->info[i].dwId, temp1));

// 		PackageManager::ItemMap* equip_map = getItemMap(EICT_Equip);
// 		for(ItemMap::iterator iter = equip_map->begin(); iter != equip_map->end(); ++iter)
// 		{
// 			const tagItem* item = iter->second->get_data();
// 			if(item)
// 			{
// 				if(item->dw_data_id == msg->info[i].dwId)
// 				{
// 					EquipRecastRebateInfo temp;
// 					memset(&temp,0,sizeof(EquipRecastRebateInfo));
// 					temp.equip_id = item->n64_serial;
// 					temp.cut_off_num = msg->info[i].byDiscunt;
// 					temp.dwStartTime = msg->info[i].dwStartTime;
// 					temp.dwEndTime = msg->info[i].dwEndTime;
// 
// 					m_all_recast_item.push_back(temp);
// 				}
// 			}
// 		}
// 
// 		PackageManager::ItemMap* bag_map = getItemMap(EICT_Bag);
// 		for(ItemMap::iterator iter = bag_map->begin(); iter != bag_map->end(); ++iter)
// 		{
// 			const tagItem* item = iter->second->get_data();
// 			if(item)
// 			{
// 				if(item->dw_data_id == msg->info[i].dwId)
// 				{
// 					EquipRecastRebateInfo temp;
// 					memset(&temp,0,sizeof(EquipRecastRebateInfo));
// 					temp.equip_id = item->n64_serial;
// 					temp.cut_off_num = msg->info[i].byDiscunt;
// 					temp.dwStartTime = msg->info[i].dwStartTime;
// 					temp.dwEndTime = msg->info[i].dwEndTime;
// 
// 					m_all_recast_item.push_back(temp);
// 				}
// 			}
// 		}
	}

	return 0;
}

void PackageManager::send_get_recast_item_rebate()
{
	NET_SIC_Equip_Recast_Discount send;
	TCP_CLIENT->send_net_cmd(&send,NP_NORMAL,false);
}

void PackageManager::get_recast_item_and_sort()
{
	m_all_recast_item.clear();

	PackageManager::ItemMap* equip_map = getItemMap(EICT_Equip);
	for(ItemMap::iterator iter = equip_map->begin(); iter != equip_map->end(); ++iter)
	{
		try_to_add_to_recast(iter->second);

		/*
		DWORD item_type_id = iter->second->get_item_type_id();
		auto finder = m_all_recast_rebate_map.find(item_type_id);
		if (finder != m_all_recast_rebate_map.end() && finder->second.b_IsOpen)
		{
			EquipRecastRebateInfo temp;
			memset(&temp,0,sizeof(EquipRecastRebateInfo));
			temp.equip_id = iter->second->get_item_id();
			temp.cut_off_num = m_all_recast_rebate_map[item_type_id].byDiscunt;
			temp.dwStartTime = m_all_recast_rebate_map[item_type_id].dwStartTime;
			temp.dwEndTime = m_all_recast_rebate_map[item_type_id].dwEndTime;

			m_all_recast_item.push_back(temp);
		}
		*/
// 		if(m_all_recast_rebate_map.find(item_type_id) != m_all_recast_rebate_map.end())
// 		{
// 			EquipRecastRebateInfo temp;
// 			memset(&temp,0,sizeof(EquipRecastRebateInfo));
// 			temp.equip_id = iter->second->get_item_id();
// 			temp.cut_off_num = m_all_recast_rebate_map[item_type_id].byDiscunt;
// 			temp.dwStartTime = m_all_recast_rebate_map[item_type_id].dwStartTime;
// 			temp.dwEndTime = m_all_recast_rebate_map[item_type_id].dwEndTime;
// 
// 			m_all_recast_item.push_back(temp);
// 		}
	}

	PackageManager::ItemMap* bag_map = getItemMap(EICT_Bag);
	for(ItemMap::iterator iter = bag_map->begin(); iter != bag_map->end(); ++iter)
	{
		DWORD item_type_id = iter->second->get_item_type_id();
		if(MIsEquipment(item_type_id))
		{
			/*
			auto finder = m_all_recast_rebate_map.find(item_type_id);
			if(finder != m_all_recast_rebate_map.end() && )
			{
				EquipRecastRebateInfo temp;
				memset(&temp,0,sizeof(EquipRecastRebateInfo));
				temp.equip_id = iter->second->get_item_id();
				temp.cut_off_num = m_all_recast_rebate_map[item_type_id].byDiscunt;
				temp.dwStartTime = m_all_recast_rebate_map[item_type_id].dwStartTime;
				temp.dwEndTime = m_all_recast_rebate_map[item_type_id].dwEndTime;

				m_all_recast_item.push_back(temp);
			}
			*/

			try_to_add_to_recast(iter->second);
		}
	}

	std::sort(m_all_recast_item.begin(),m_all_recast_item.end(),sort_all_recast_equip);

	receive_recast_item_event event;
	SEND_EVENT(&event);
}

unsigned int PackageManager::onReciveRecastBack(s_net_cmd *cmd)
{
	NET_SIS_Equip_Recast * msg = (NET_SIS_Equip_Recast*)cmd;
	CC_ASSERT(msg);

	if(msg->dwError != 0)
	{
		int temp = int(msg->dwError);
		std::stringstream ss;
		ss<<"recast_error_"<<temp;
		std::string ss_name(ss.str());
		std::string ss_value = STRING_TABLE[ss_name.c_str()];
		if (0 == ss_name.compare("recast_error_759")) //"您的等级不足，该装备需要%d级才可重铸"
		{
			f_equipment* equip = dynamic_cast<f_equipment*>(getItem(msg->n64_serial));
			if (equip) {
				const EquipRecastData& recast_data = get_one_recast_data(equip->get_item_type_id());
				safe_sprintf(ss_value, ss_value.c_str(), recast_data.need_lv);
			}
		}
		ToolTip::getInstance()->push(ss_value);
		return 0;
	}

	for(vector_recast_item::iterator iter = m_all_recast_item.begin(); iter != m_all_recast_item.end(); ++iter)
	{
		if(iter->equip_id == msg->n64_serial)
		{
			m_all_recast_item.erase(iter);
			break;
		}
	}

	f_equipment* equip = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(msg->n64_newSerial));
	if(IS_VALID_PTR(equip))
	{
		if(is_put_in_recast_list(equip->get_item_type_id()))
		{
			try_to_add_to_recast(equip);
// 			all_recast_rebate_map::iterator iter = m_all_recast_rebate_map.find(equip->get_item_type_id());
// 			if (iter != m_all_recast_rebate_map.end())
// 			{
// 				EquipRecastRebateInfo temp;
// 				memset(&temp,0,sizeof(EquipRecastRebateInfo));
// 				temp.equip_id = msg->n64_newSerial;
// 				temp.cut_off_num = iter->second.byDiscunt;
// 				temp.dwStartTime = iter->second.dwStartTime;
// 				temp.dwEndTime = iter->second.dwEndTime;
// 				m_all_recast_item.push_back(temp);
// 			}
		}
	}

	receive_recast_item_event event;
	SEND_EVENT(&event);

	return 0;
}

void PackageManager::set_is_open_recast(eOpenBehaviour behaviour)
{
	if(m_open_behaviour != behaviour)
	{
		return;
	}

	bool is_open_limit = if_open_limit_recast_init();
	set_open_limit_recast(is_open_limit);
}

bool PackageManager::if_open_recast_init()
{
	if(!m_is_total_open)
	{
		return false;
	}

	if(m_recast_begin_time > 0)
	{
		return false;
	}

	if(m_recast_end_time > 0)
	{
		return false;
	}

	return true;
}

bool PackageManager::if_open_limit_recast_init()
{
	if(!m_is_total_open)
	{
		return false;
	}

	if(m_recast_begin_time == INVALID || m_recast_begin_time == 0)
	{
		return false;
	}

	if(m_recast_end_time == INVALID || m_recast_end_time == 0)
	{
		return false;
	}

	unsigned int time_now = ServerTime::getInstance()->cal_current_server_dword_time();
	unsigned int time_1 = CalcTimeDiff(time_now, m_recast_begin_time);
	unsigned int time_2 = CalcTimeDiff(m_recast_end_time, time_now);

	if(!(time_1 > 0))
	{
		return false;
	}

	if(!(time_2 > 0))
	{
		return false;
	}

	int level = RoleManager::getInstance()->getLocalPlayer()->getLevel();
	if(level < m_recast_need_level)
	{
		return false;
	}

	int recharge_num = getTotalChargeYuanBao();
	if(recharge_num < m_recast_need_recharge)
	{
		return false;
	}

	for(int i = 0; i < open_condition_num; ++i)
	{
		if(m_open_condition[i] > 0)
		{
			int num = 0;

			PackageManager::ItemMap* TmpItemMap = getItemMap(EICT_Equip);
			PackageManager::ItemMap::iterator iter = TmpItemMap->begin();
			for(; iter != TmpItemMap->end(); ++iter)
			{
				const tagItem* item = iter->second->get_data();
				if(item)
				{
					const EquipTypeData* data = PackageManager::getInstance()->getEquipTypeData(item->dw_data_id);
					CC_ASSERT(data);
					if(m_open_condition[i] == data->equipSign)
					{
						num++;
					}
				}
			}

			ItemMap* bagMap = getItemMap(EICT_Bag);
			for (ItemMap::iterator iter = bagMap->begin();iter != bagMap->end(); ++iter)
			{
				f_item* item = iter->second;
				if(item)
				{
					if(MIsEquipment(item->get_item_type_id()))
					{
						f_equipment* equip = dynamic_cast<f_equipment*>(PackageManager::getInstance()->getItem(item->get_item_id()));
						if(equip)
						{
							const EquipTypeData* data = PackageManager::getInstance()->getEquipTypeData(item->get_item_type_id());
							CC_ASSERT(data);
							if(m_open_condition[i] == data->equipSign)
							{
								num++;
							}
						}
					}
				}
			}

			if(num < m_open_condition_num[i])
			{
				return false;
			}
		}
	}

	return true;
}

void PackageManager::try_to_move_item_from_bag_to_storage( short pos )
{
	f_item* src_item = getItem(EICT_Bag,pos);
	if (src_item)
	{
		int pos = getFitIndex(EICT_RoleWare);
		if (-1 == pos)
		{
			ToolTip::getInstance()->push(STRING_TABLE["storage_full"]);
		}
		else
		{
			PackageManager::getInstance()->sendItemPositionChange(src_item,EICT_RoleWare,pos);
		}
	}
}

void PackageManager::try_to_move_item_from_storage_to_bag( short pos )
{
	f_item* src_item = getItem(EICT_RoleWare,pos);
	if (src_item)
	{
		int pos = getFitIndex(EICT_Bag);
		if (-1 == pos)
		{
			ToolTip::getInstance()->push(STRING_TABLE["package_full"]);
		}
		else
		{
			PackageManager::getInstance()->sendItemPositionChange(src_item,EICT_Bag,pos);
		}
	}
}

void PackageManager::try_to_lock_or_unlock_kungfu( INT64 item_id )
{
	f_item* item = getItem(item_id);
	CC_ASSERT(item);
	CC_ASSERT(item->get_container_type() == EICT_KungfuBag);

	ItemTypeData const* item_proto =get_item_proto_ptr(item->get_item_type_id());
	CC_ASSERT(item_proto);
	CC_ASSERT(item_proto->type == PIT_Kungfu || item_proto->type == PIT_KungfuExp);

	f_equipment* equip =  dynamic_cast<f_equipment*>(item);
	CC_ASSERT(equip);
	bool lock_state = equip->is_gf_locked();

	NET_SIC_GongFa_Lock cmd;
	cmd.bLock = !lock_state;
	cmd.n64_serial = item_id;
	TCP_CLIENT->send_net_cmd(&cmd,NP_NORMAL,true);
}

unsigned int PackageManager::on_server_gongfa_lock( s_net_cmd* cmd )
{
	NET_SIS_GongFa_Lock* msg = (NET_SIS_GongFa_Lock*)cmd;
	if (msg->dwError ==0)
	{
		f_item* item = getItem(msg->n64_serial);
		CC_ASSERT(item);
		CC_ASSERT(item->get_container_type() == EICT_KungfuBag);

		ItemTypeData const* item_proto =get_item_proto_ptr(item->get_item_type_id());
		CC_ASSERT(item_proto);
		CC_ASSERT(item_proto->type == PIT_Kungfu || item_proto->type == PIT_KungfuExp);

		f_equipment* equip = dynamic_cast<f_equipment*>(item);
		CC_ASSERT(equip);
		equip->m_equipex.byGFLock = msg->byLock;
		//item->m_data.SetBind(EBindStatus(msg->byLock));

		GongfaLockStateUpdate evt;
		evt.item_id = msg->n64_serial;
		evt.b_lock = msg->byLock== EGFLS_GongFa?true:false;
		SEND_EVENT(&evt);
	}
	else
	{
		ToolTip::getInstance()->push(STRING_TABLE["lock_gongfa_error"]);
	}

	return 0;
}

unsigned int PackageManager::onMessageEquipSuitInit(s_net_cmd *cmd)
{
	NET_S2C_Suit_Init_Info* msg = (NET_S2C_Suit_Init_Info*)cmd;
	for(int i = 0; i < (int)msg->nCount; ++i)
	{
		set_suit_data(msg->sSuitNumInfo[i].dwSuitID, (int)msg->sSuitNumInfo[i].n8Num);
	}

	return 0;
}

unsigned int PackageManager::onMessageEquipSuitChange( s_net_cmd* cmd )
{
	NET_SIS_suit_num* msg = (NET_SIS_suit_num*)cmd;
	set_suit_data(msg->dwSuitID, (int)msg->n8Num);

	return 0;
}

void PackageManager::get_item_list( ItemMap* item_map,int state,std::vector<f_item*>& out )
{
	if (item_map->empty())
	{
		return;
	}

	out.clear();

	if (state == 2)
	{
		std::for_each(item_map->begin(),item_map->end(),
			[&](ItemMap::value_type const& kv)
		{
			out.push_back(kv.second);
		});
	}
	else
	{
		std::for_each(item_map->begin(),item_map->end(),
			[&](ItemMap::value_type const& kv)
		{
			if (state ==1)
			{
				f_item* item = kv.second;
				f_equipment* equip = dynamic_cast<f_equipment*>(item);
				if (equip && equip->is_gf_locked())
				{
					out.push_back(kv.second);
				}
			}
			else if (state == 0)
			{
				f_item* item = kv.second;
				f_equipment* equip = dynamic_cast<f_equipment*>(item);
				if (equip && !equip->is_gf_locked())
				{
					out.push_back(kv.second);
				}
			}
	
		});
	}
}

void PackageManager::sort_items( std::vector<f_item*>const& in,sorted_map& out )
{
	std::for_each(in.begin(),in.end(),
		[this,&out](f_item* one)
	{
		out[CalcItemWeight(one)] = one;
	});
// 	std::map<INT64, f_item*> tmpMap;
// 	for(ItemMap::iterator iter = itemMap->begin(); iter != itemMap->end(); ++ iter)
// 	{
// 		f_item *item = iter->second;
// 		//item->set_operable(false);
// 		tmpMap[CalcItemWeight(item)] = item;
// 	}
}

void PackageManager::cal_ex_pair( sorted_map_list const& list,std::vector<tagItemOrder>& out )
{
	short pos=0;
	for (size_t  i=0; i < list.size()  ; ++i)
	{
		sorted_map const& map = list[i];
		
		std::for_each(map.begin(),map.end(),
			[&out,&pos](sorted_map::value_type const& kv)
		{
			f_item* item = kv.second;
			if (item->get_pos() != pos)
			{
				tagItemOrder oder;
				oder.n16NewIndex = pos;
				oder.n16OldIndex = item->get_pos();
				out.push_back(oder);
			}
			++pos;
		});
	}
}

void PackageManager::send_resort_whole_package( sorted_map_list const& list ,size_t total,EItemConType ctn_type)
{
	MAKE_MSG_PACKAGE_AUTO_RELEASE(NET_SIC_item_reorder,short,total);
	switch( ctn_type )
	{
	case EICT_KungfuBag:
		p_send->by_type = 2;
		m_reoderGongFaItem=true;//记录下是否需要排序，服务器没法处理，只好用全局变量记录
		break;
	case EICT_KungfuTemp:
		p_send->by_type = 3;
		m_reoderGongFaItem=true;
		break;
	case EICT_RoleWare:
		p_send->by_type = 4;
		break;
	}
	p_send->dwNPCID = get_npc_id_by_cnt_type(ctn_type);
// 	if(ctn_type == EICT_RoleWare)
// 		p_send->dwNPCID = StoreMgr::getInstance()->getNpcServerId();
// 	else
// 		p_send->dwNPCID = INVALID;

	p_send->n16ItemNum = total;
	
	std::vector<short> new_oder;
	for (size_t  i=0; i < list.size()  ; ++i)
	{
		sorted_map const& map = list[i];
		std::for_each(map.begin(),map.end(),
			[&new_oder](sorted_map::value_type const& kv)
		{
			new_oder.push_back(kv.second->get_pos());
		});
	}

	std::copy(new_oder.begin(),new_oder.end(),&p_send->n16Index[0]);

	TCP_CLIENT->send_net_cmd(p_send,NP_NORMAL,true);
}

void PackageManager::try_to_arrange_package( EItemConType ctn_type )
{
	ItemMap *item_map_now = getItemMap(ctn_type);
	if(item_map_now != NULL)
	{
		if (item_map_now->empty())
		{
			return;
		}

		//size_t nSize = 0;
		//short nPos = 0;
		sorted_map_list need_sync;

		std::vector<tagItemOrder>	change_pairs;
		if (ctn_type  == EICT_KungfuBag)
		{
			//根据锁定和非锁定的分别处理
			sorted_map unbind_item_sort_result_map,bind_item_sort_result_map;
			std::vector<f_item*> need_sort;
			get_item_list(item_map_now,1,need_sort);
			sort_items(need_sort,bind_item_sort_result_map);
			need_sync.push_back(bind_item_sort_result_map);

			need_sort.clear();
			get_item_list(item_map_now,0,need_sort);
			sort_items(need_sort,unbind_item_sort_result_map);
			need_sync.push_back(unbind_item_sort_result_map);
		}
		else
		{
			// 锁定所有物品,并计算物品的权重
			sorted_map tmp_map;
			std::vector<f_item*> need_sort;
			get_item_list(item_map_now,2,need_sort);
			sort_items(need_sort,tmp_map);

			need_sync.push_back(tmp_map);
		}
		cal_ex_pair(need_sync,change_pairs);

		if(change_pairs.empty())// 如果没有数据则不发送排序消息
		{
			unLockItem(ctn_type);

			//delete []pMsg;
			if(ctn_type==EICT_KungfuBag||ctn_type==EICT_KungfuTemp)
			{
				GambleMgr::getInstance()->showOneKeyLevelUpEffect();//功法背包,不需要排序直接显示升级特效
			}
			
			return;
		}

		size_t no_ex_msgpck_size = item_map_now->size()*sizeof(short);
		size_t ex_msgpck_size = change_pairs.size()* sizeof(tagItemOrder);
		if(ex_msgpck_size > no_ex_msgpck_size)
		{
			//使用整包
			send_resort_whole_package(need_sync,item_map_now->size(),ctn_type);
		}
		else
		{
			send_changes(change_pairs,ctn_type);
		}
	}
}

void PackageManager::send_changes( std::vector<tagItemOrder>const& change_pair,EItemConType ctn_type )
{
	size_t total = change_pair.size();
	MAKE_MSG_PACKAGE_AUTO_RELEASE(NET_SIC_item_reorder_extend,tagItemOrder,total);

	switch( ctn_type )
	{
	case EICT_KungfuBag:
		p_send->by_type = 2;
		m_reoderGongFaItem=true;//记录下是否需要排序，服务器没法处理，只好用全局变量记录
		break;
	case EICT_KungfuTemp:
		p_send->by_type = 3;
		m_reoderGongFaItem=true;
		break;
	case EICT_RoleWare:
		p_send->by_type = 4;
		break;
	}

	p_send->dwNPCID = get_npc_id_by_cnt_type(ctn_type);

	p_send->n16ItemNum = total;

	std::copy(change_pair.begin(),change_pair.end(),&p_send->byData[0]);

	TCP_CLIENT->send_net_cmd(p_send,NP_NORMAL,true);
}

bool PackageManager::init_equip_suit_table()
{
	m_equip_suit_data.clear();

	f_data_set dataset;
	std::list<std::string> fields;
	bool ret =dataset.load("Config/equipSuit.xml","id",&fields);
	CC_ASSERT(ret);

	std::for_each(fields.begin(),fields.end(),[&](std::string const& one)
	{
		EquipSuitData data;

		data.id = dataset.get_int("id",one.c_str(),0);
		data.suit_name = dataset.get_string("suit_Name",one.c_str(),"");

		data.need_num[0] = dataset.get_int("need_Num1",one.c_str(),0);
		data.need_num[1] = dataset.get_int("need_Num2",one.c_str(),0);
		data.need_num[2] = dataset.get_int("need_Num3",one.c_str(),0);
		data.need_num[3] = dataset.get_int("need_Num4",one.c_str(),0);
		data.need_num[4] = dataset.get_int("need_Num5",one.c_str(),0);
		data.need_num[5] = dataset.get_int("need_Num6",one.c_str(),0);

		data.suit_dest[0] = dataset.get_string("value1_Test",one.c_str(),"");
		data.suit_dest[1] = dataset.get_string("value2_Test",one.c_str(),"");
		data.suit_dest[2] = dataset.get_string("value3_Test",one.c_str(),"");
		data.suit_dest[3] = dataset.get_string("value4_Test",one.c_str(),"");
		data.suit_dest[4] = dataset.get_string("value5_Test",one.c_str(),"");
		data.suit_dest[5] = dataset.get_string("value6_Test",one.c_str(),"");

		m_equip_suit_data.insert(std::make_pair(data.id, data));
	});

	return true;
}

int PackageManager::get_own_suit_num_by_suit_id(DWORD suit_id)
{
	if(!IS_VALID(suit_id))
		return 0;

	map_suit::iterator iter = m_suit_map.find(suit_id);
	if(iter != m_suit_map.end())
	{
		return iter->second;
	}

	return 0;
}

const EquipSuitData& PackageManager::get_one_suit_data_by_id(DWORD suit_id)
{
	map_equip_suit_data::iterator iter = m_equip_suit_data.find(suit_id);
	if (iter != m_equip_suit_data.end())
	{
		const EquipSuitData& data = iter->second;
		return data;
	}
	const EquipSuitData& temp_data = m_equip_suit_data.begin()->second;
	return temp_data;
}

void PackageManager::set_suit_data(DWORD suit_id, int num)
{
	map_suit::iterator iter = m_suit_map.find(suit_id);
	if(iter != m_suit_map.end())
	{
		iter->second = num;
	}
	else
	{
		m_suit_map.insert(make_pair(suit_id, num));
	}
}

unsigned int PackageManager::get_npc_id_by_cnt_type( EItemConType ctn_type ) const
{
	return (ctn_type == EICT_RoleWare)?\
		StoreMgr::getInstance()->getNpcServerId():INVALID;
}

void PackageManager::replace_jewel( f_equipment* src,f_equipment* dest )
{
	CC_ASSERT(src);
	//CC_ASSERT(dest);

	if((dest != NULL)&&(dest->get_equip_gem_num() > 0)&&(src->get_equip_gem_num() == 0)&&(src->get_equip_max_hole_num() != 0))
	{
		const EquipTypeData* srcEquipData = getEquipTypeData(src->get_item_type_id());
		CC_ASSERT(srcEquipData);
		const EquipTypeData* descEquipData = getEquipTypeData(dest->get_item_type_id());
		CC_ASSERT(descEquipData);
		string srcProfession = srcEquipData->profession.substr(0, srcEquipData->profession.size() - 6);//这里减6是因为只有减6才能够成功判断职业
		string descProfession = descEquipData->profession.substr(0, descEquipData->profession.size() - 6);
		if((srcEquipData->posIndex == descEquipData->posIndex) && (srcProfession == descProfession))//职业相同则替换，职业不同则不替换
		{
			bool canInlay = false;
			for(int i = 0; i < dest->get_equip_max_hole_num(); ++i)//判断目标装备上是否有合适的宝石，如果有则镶嵌，否则不镶嵌
			{
				unsigned int typeId = dest->get_equip_hold_gem_id(i);
				const ItemTypeData& gem = getItemTypeData(typeId);
				if(gem.special_value_1 <= (unsigned int)srcEquipData->jewel_limit)
				{
					canInlay = true;
					break;
				}
			}
			if(canInlay)
			{
				MessageBoxUi *repairSignUI = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI, TEXT_UTF8_REPLACETEXT, TEXT_UTF8_REPLACE,TEXT_UTF8_NOREPLACE);
				World::getInstance()->getScene()->addChild(repairSignUI, WZ_MESSAGEBOX);
				repairSignUI->signalOkBtnPressed.connect(this,&PackageManager::replaceGem);
				repairSignUI->signalCancelBtnPressed.connect(this,&PackageManager::changePositionForDressEquip);
			}
			else
			{
				changePositionForDressEquip();
			}
		}
	}
	else
	{
		changePositionForDressEquip();
	}
}

bool PackageManager::stack_is_full( EItemConType con,unsigned int item_type_id )
{
	ItemTypeData const* item_data = get_item_proto_ptr(item_type_id);
	CC_ASSERT(item_data);

	unsigned int stack_num= getItemNumber_Stack(EICT_Bag,item_type_id);
	int total_num = getItemNumber(EICT_Bag,item_type_id);

	return (unsigned int)total_num == stack_num  *item_data->stackNumber;
}

bool PackageManager::have_enough_space_for_picking( unsigned int type_id )
{
	ItemTypeData const* item_data = get_item_proto_ptr(type_id);
	CC_ASSERT(item_data);

	bool is_soul = (item_data->type == PIT_KungfuExp ||item_data->type == PIT_Kungfu );
	int space=  getBlankCount(is_soul?EICT_KungfuBag : EICT_Bag);

	if(is_soul && 0== space) 
		return false;
	else
	{
		if (0== space && stack_is_full(EICT_Bag,type_id))
			return false;
	}

	return true;
}


// void PackageManager::SendAutoOpenBox( bool bAuto /*= true*/ )
// {
// 	//检查背包空格
// 	if (getBlankCount(EICT_Bag) < 1)
// 	{
// 		ToolTip::getInstance()->push(GET_STR(161));
// 		return;
// 	}
// 	m_tempBoxMap.clear();
// 	//首先检查背包中该类型宝箱的数量
// 	for(ItemMap::iterator iter = _pocket.begin(); iter != _pocket.end(); ++iter)
// 	{
// 		f_item *item = iter->second;
// 		if(!item)
// 			continue;
// 		if (item->get_item_type_id() == m_CurBoxGamle_TypeID)
// 		{
// 			m_tempBoxMap.insert(make_pair(item->get_item_id(),item->get_data()->GetNum()));//存该堆的宝箱个数
// 		}
// 	}
// 	if (0 == m_tempBoxMap.size())
// 	{
// 		//提示没有此类型的宝箱
// 		const ItemTypeData &typeData = getItemTypeData(m_CurBoxGamle_TypeID);//gx add
// 		if (!typeData.name.empty())
// 		{
// 			//2343
// 			std::string str = replaceStr(GET_STR(2343),"**",typeData.name);
// 			ToolTip::getInstance()->push(str);
// 		}
// 		//关闭UI
// 		return;
// 	}
// 	UniqueIDMap::iterator iter_first = m_tempBoxMap.begin();
// 	if (iter_first == m_tempBoxMap.end())
// 	{
// 		m_tempBoxMap.clear();
// 		return;
// 	}
// 	f_item *pItem = getItem(_pocket,iter_first->first);
// 	if(!pItem)
// 		return;
// 	if (!bAuto)//若不是一键开宝箱
// 	{
// 		openKenXiang(pItem);
// 		m_tempBoxMap.clear();
// 	}
// 	else
// 	{	
// 		//要给玩家二次提示
// 		const ItemTypeData &typeData = getItemTypeData(m_CurBoxGamle_TypeID);//gx add
// 		if (typeData.name.empty())
// 		{
// 			m_tempBoxMap.clear();
// 			return;
// 		}
// 		std::string str = replaceStr(GET_STR(2344),"**",typeData.name);
// 		MessageBoxUi *ui = MessageBoxUi::createWithTwoBtn(TEXT_UTF8_TISHI,str.c_str(), TEXT_UTF8_QUEDING,TEXT_UTF8_QUXIAO);
// 		World::getInstance()->getScene()->addChild(ui, WZ_MESSAGEBOX);
// 		ui->signalOkBtnPressed.connect(this, &PackageManager::SendLastBox);
// 		ui->signalCancelBtnPressed.connect(this,&PackageManager::ToCancel);
// 	}
// 	
// }

// void PackageManager::ToCancel()
// {
// 	//关闭宝箱界面UI
// 	//CLOSE_UI(WCT_RewardBoxUi);
// 	m_tempBoxMap.clear();
// }

// unsigned int PackageManager::onServerOpenKenBox( s_net_cmd* cmd )
// {
// 	NET_SIS_Common_get_reward_info* msg = (NET_SIS_Common_get_reward_info*)cmd;
// 	if (!msg)
// 		return 0;
// 	   
// 	if (1300022 == msg->nType || 1300023 == msg->nType || 1300024 == msg->nType || 1300037 == msg->nType)
// 	{
// 		/*
// 		nType
// 		nTypeEx代表抽中的typeid
// 		nValue 若是经验卡是得到的具体经验值
// 		nBig 没有意义
// 		*/
// // 		if (!GET_UI(RewardBoxUi,WCT_RewardBoxUi)->uiIsRun())
// // 		{
// 			OPEN_UI(WCT_MystreyBoxUi);
// //		}
// 		if (0 != msg->nTypeEx)//
// 		{
// 			if (!GET_UI(RewardBoxUi,WCT_MesteryBoxUi)->getUiLayer())
// 				return 0;
// 			GambleMgr::getInstance()->SetBoxGamble_ArrayByHitPrizeID(msg->nType,msg->nTypeEx);
// 			GambleMgr::getInstance()->SetBoxTypeID(msg->nType);
// 			if (msg->nValue > 0)
// 			{
// 				GambleMgr::getInstance()->SetExpByBox(msg->nValue);//抽到了经验，设置经验值
// 				GET_UI(RewardBoxUi,WCT_RewardBoxUi)->getUiLayer()->getExpByBox(true);
// 				GET_UI(RewardBoxUi,WCT_RewardBoxUi)->getUiLayer()->setIsBigPrize(false);
// 			}
// 			else
// 			{
// 				GET_UI(RewardBoxUi,WCT_RewardBoxUi)->getUiLayer()->getExpByBox(false);
// 				GET_UI(RewardBoxUi,WCT_RewardBoxUi)->getUiLayer()->setIsBigPrize(msg->nBig);
// 				GambleMgr::getInstance()->SetExpByBox(0);
// 			}
// 			GET_UI(RewardBoxUi,WCT_RewardBoxUi)->onServerResult(true);
// 		}
// 	}
// 	else
// 	{
// 		//do nothing
// 	}
// 	return 0;
// }

// void PackageManager::SendLastBox()
// {
// 	if (!GET_UI(RewardBoxUi,WCT_RewardBoxUi))
// 	{
// 		m_tempBoxMap.clear();
// 	}
// 	//检查背包空格
// 	if (getBlankCount(EICT_Bag) < 1)
// 	{
// 		m_tempBoxMap.clear();
// 		ToolTip::getInstance()->push(GET_STR(161));
// 		CLOSE_UI(WCT_RewardBoxUi);
// 		return;
// 	}
// 	if (0 == m_tempBoxMap.size())
// 	{
// 		//提示没有此类型的宝箱
// 		const ItemTypeData &typeData = getItemTypeData(m_CurBoxGamle_TypeID);//gx add
// 		if (!typeData.name.empty())
// 		{
// 			//2343
// 			std::string str = replaceStr(GET_STR(2343),"**",typeData.name);
// 			ToolTip::getInstance()->push(str);
// 		}
// 		//关闭UI
// 		return;
// 	}
// 	UniqueIDMap::iterator iter_first = m_tempBoxMap.begin();
// 	if (iter_first == m_tempBoxMap.end())
// 	{
// 		m_tempBoxMap.clear();
// 		return;
// 	}
// 	f_item *pItem = getItem(_pocket,iter_first->first);
// 	if(!pItem)
// 		return;
// 	openKenXiang(pItem,true);
// 	iter_first->second = iter_first->second - 1;
// 	if (iter_first->second <= 0)
// 	{
// 		m_tempBoxMap.erase(iter_first);
// 	}
// }

const PackageManager::Equip_Show_Info* PackageManager::getEquipShowInfo()
{
	if (m_equip_show_info.size()<=0)
	{
		initEquipShowInfo();
	}
	return &m_equip_show_info;
}

const static std::string CFG_ARR[CF_END] = 
{
	"","RecNo","typeId","Name","Profession","Profession1","Level",
	"Durability","Pos","PosIndex","Sex","levelUpId","stuff1Id","stuff1Num",
	"stuff2Id","stuff2Num","stuff3Id","stuff3Num","j33","j34","j35",
	"j36","j37","j38","j12","j13","j14","j15","j8","j10","j16","j17",
	"j19","j21","Luck","Desc","suitId","referLv","quality","taozhuanglv",
	"kind","baoshi1","baoshi2","baoshi3","baoshi4","baoshi5","stronglv",
	"f33","f34","f35",
	"f36","f37","f38","f12","f13","f14","f15","f8","f10","f16","f17",
	"f19","f21","xing",
};

void PackageManager::initEquipShowInfo()
{
	m_equip_show_info.clear();

	f_data_set data;
	std::list<std::string> fields;

	bool ret = data.load("Config/db/EquipZhanshi.xml","typeId",&fields);
	CC_ASSERT(ret);

	std::for_each(fields.begin(),fields.end(),[&](std::string const& one)
	{
		equip_show_info info;
		info.sex = data.get_int("Sex",one.c_str());
		info.profess = data.get_int("Profession1",one.c_str());
		info.taoZhuangLevel = data.get_int("taozhuanglv",one.c_str());
		info.taoZhuangkind = data.get_int("kind",one.c_str());
		info.equip.n16Index = data.get_int("PosIndex",one.c_str());
		info.equip.dw_data_id = data.get_int("typeId",one.c_str());

		int edx = 0;
		for (int i = CF_J33; i <= CF_J21 ;++i)
		{
			int num = data.get_int(CFG_ARR[i].c_str(),one.c_str());
			if (num>0)
			{
				std::string numStr = CFG_ARR[i].substr(1,2);
				info.equip.equipSpec.EquipAttitionalAtt[edx].eRoleAtt = (ERoleAttribute)atoi(numStr.c_str());
				info.equip.equipSpec.EquipAttitionalAtt[edx].nValue = num;
				edx++;
			}
		}
		edx = 12;
		for (int i = CF_F33; i<=CF_F21 ; ++i)
		{
			int num = data.get_int(CFG_ARR[i].c_str(),one.c_str());
			if (num>0 || num == ERA_UNKNOW)
			{
				std::string numStr = CFG_ARR[i].substr(1,2);
				info.equip.equipSpec.EquipAttitionalAtt[edx].eRoleAtt = (ERoleAttribute)atoi(numStr.c_str());
				info.equip.equipSpec.EquipAttitionalAtt[edx].nValue = num;
				edx++;
			}
		}

		edx = 0;
		for (int i = CF_BAOSHI_1; i <= CF_BAOSHI_5 ;++i)
		{
			int num = data.get_int(CFG_ARR[i].c_str(),one.c_str());
			if (num > 0)
			{
				info.equip.equipSpec.dwHoleGemID[edx] = num;
				edx++;
			}
		}

		info.equip.equipSpec.byConsolidateLevel = data.get_int(CFG_ARR[CF_STRONGLV].c_str(),one.c_str());
		info.equip.equipSpec.nStarLv = data.get_int(CFG_ARR[CF_XING].c_str(),one.c_str());
		info.equip.equipSpec.byQuality = data.get_int(CFG_ARR[CF_QUALITY].c_str(),one.c_str());
		info.equip.equipSpec.nRating = Rating_Helper::getInstance()->GetRatingNum(info.equip);

		m_equip_show_info[info.equip.dw_data_id] = info;
	});
}

void PackageManager::try_to_add_to_recast( f_item* item )
{
	unsigned int type_id = item->get_item_type_id();
	auto finder = m_all_recast_rebate_map.find(type_id);
	if (finder != m_all_recast_rebate_map.end() && finder->second.b_IsOpen)
	{
		EquipRecastRebateInfo temp;
		memset(&temp,0,sizeof(EquipRecastRebateInfo));
		temp.equip_id = item->get_item_id();
		temp.cut_off_num = m_all_recast_rebate_map[type_id].byDiscunt;
		temp.dwStartTime = m_all_recast_rebate_map[type_id].dwStartTime;
		temp.dwEndTime = m_all_recast_rebate_map[type_id].dwEndTime;

		m_all_recast_item.push_back(temp);
	}
}

bool PackageManager::is_special_gold_magic_soul_full(int magic_lv, bool need_notice /*= false*/ ) const
{
	int already_equiped = get_special_gold_magic_soul_equiped_num();
	
	int max = f_formula_helper::get_special_gold_magic_soul_limit_num(magic_lv);

	bool ret= already_equiped >= max;

	if (ret && need_notice)
	{
		//提示 特殊功法满了
		ToolTip::getInstance()->push(
			max==0?
			STRING_TABLE["special_gold_magic_soul_limit_0"]
			:STRING_TABLE["special_gold_magic_soul_limit"]);
	}

	return ret;
}

int PackageManager::get_special_gold_magic_soul_equiped_num() const
{
	size_t total = std::count_if(	_kungfu.begin()
									,_kungfu.end()
									,[this](ItemMap::value_type const& kv)->bool
									{
										f_item* one = kv.second;
										EquipTypeData const* data = getEquipTypeData(one->get_item_type_id());
										CC_ASSERT(data);
										
										return data->is_specail_magic_soul();
									});
	return (int)total;
}

bool PackageManager::check_full_special_magic_soul( EItemConType srcConType, EItemConType destConType, short src, short dest )
{
	if (srcConType == EICT_KungfuBag && EICT_KungfuEquip== destConType)
	{
		f_item const* src_item = getItem(srcConType,src);
		CC_ASSERT(src_item);
		EquipTypeData const* equip_proto = getEquipTypeData(src_item->get_item_type_id());
		CC_ASSERT(equip_proto);

		bool src_item_is_special = equip_proto->is_specail_magic_soul();

		bool b_add = false;
		f_item const* dest_item = getItem(destConType,dest);
		if(!dest_item) 
			b_add = src_item_is_special;
// 		else
// 		{
// 			EquipTypeData const* equip_proto = getEquipTypeData(dest_item->get_item_type_id());
// 			CC_ASSERT(equip_proto);
// 
// 			b_add = !equip_proto->is_specail_magic_soul() && src_item_is_special;
// 		}

		if (b_add && is_special_gold_magic_soul_full(GambleMgr::getInstance()->m_curGongFaRealm,true)) 
			return true;
	}

	return false;
}
//ignore_state : 0无需判断容器类型 1需要判断src 2需要判断dest
bool PackageManager::check_absorb( f_equipment const*tempsrcItem, f_equipment const* tempdesItem,std::string& msgFirstName,std::string& msgSecondName,int& firstLv,int& secondLv,unsigned char& ignore_state ) const
{
	ItemTypeData const* src_data = get_item_proto_ptr(tempsrcItem->get_item_type_id());
	CC_ASSERT(src_data);
	ePackageItemType tempSrcType =src_data->type;

	ItemTypeData const* dest_data = get_item_proto_ptr(tempdesItem->get_item_type_id());
	CC_ASSERT(dest_data);
	ePackageItemType tempDesType =dest_data->type;

	ignore_state = 0;

	if((tempsrcItem->get_item_quality() == EIQ_Quality0 && tempdesItem->get_item_quality() == EIQ_Quality0) ||
		(tempSrcType == PIT_KungfuExp && tempDesType == PIT_KungfuExp))
	{//2个都是普通武学或经验珠
		if (tempSrcType == EIT_KungfuExp)
		{//经验珠
			//经验珠之间不能进行融合

			MessageBoxUi *messageBox = MessageBoxUi::createWithOneBtn("",STRING_TABLE["gongfa_string14"], TEXT_UTF8_QUEDING);
			World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
		} 
		else
		{//普通武学
			//普通功法之间不能进行融合
			MessageBoxUi *messageBox = MessageBoxUi::createWithOneBtn("",STRING_TABLE["gongfa_string20"], TEXT_UTF8_QUEDING);
			World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
		}
		return false;
	}
	else if((tempsrcItem->get_item_quality() == EIQ_Quality0 && tempDesType == PIT_KungfuExp) ||
		(tempSrcType == PIT_KungfuExp && tempdesItem->get_item_quality() == EIQ_Quality0))
	{
		//品质普卡武学不能与经验珠融合
		MessageBoxUi *messageBox = MessageBoxUi::createWithOneBtn("",STRING_TABLE["gongfa_string21"], TEXT_UTF8_QUEDING);//普通功法之间不能进行融合
		World::getInstance()->getScene()->addChild(messageBox, WZ_MESSAGEBOX, WCT_MessageBox);
		return false;
	}
	else if((tempsrcItem->get_item_quality() == EIQ_Quality0 && tempdesItem->get_item_quality() != EIQ_Quality0)||
		(tempSrcType == PIT_KungfuExp && tempDesType != PIT_KungfuExp))
	{
		msgSecondName = tempsrcItem->GetItemName();
		msgFirstName = tempdesItem->GetItemName();
		firstLv = tempdesItem->get_equip()->nLevel;
		secondLv = tempsrcItem->get_equip()->nLevel;
	}
	else if((tempsrcItem->get_item_quality() != EIQ_Quality0 && tempdesItem->get_item_quality() == EIQ_Quality0)||
		(tempSrcType != PIT_KungfuExp && tempDesType == PIT_KungfuExp))
	{
		msgFirstName = tempsrcItem->GetItemName();
		msgSecondName = tempdesItem->GetItemName();
		firstLv = tempsrcItem->get_equip()->nLevel;
		secondLv = tempdesItem->get_equip()->nLevel;
	}
	else
	{
		if (tempsrcItem->get_modified_quanlity() < tempdesItem->get_modified_quanlity())//1、判断品质
		{
			msgFirstName = tempdesItem->GetItemName();
			msgSecondName = tempsrcItem->GetItemName();
			firstLv = tempdesItem->get_equip()->nLevel;
			secondLv = tempsrcItem->get_equip()->nLevel;

			ignore_state = 1;
		}
		else if (tempsrcItem->get_modified_quanlity() == tempdesItem->get_modified_quanlity())
		{//品质相等接下来判断物品等级
			if (tempsrcItem->get_equip()->nLevel <= tempdesItem->get_equip()->nLevel)
			{
				msgFirstName = tempdesItem->GetItemName();
				msgSecondName = tempsrcItem->GetItemName();
				firstLv = tempdesItem->get_equip()->nLevel;
				secondLv = tempsrcItem->get_equip()->nLevel;

				ignore_state = 1;
			}
			else
			{
				msgFirstName = tempsrcItem->GetItemName();
				msgSecondName = tempdesItem->GetItemName();
				firstLv = tempsrcItem->get_equip()->nLevel;
				secondLv = tempdesItem->get_equip()->nLevel;

				ignore_state = 2;
			}
		}
		else
		{
			msgFirstName = tempsrcItem->GetItemName();
			msgSecondName = tempdesItem->GetItemName();
			firstLv = tempsrcItem->get_equip()->nLevel;
			secondLv = tempdesItem->get_equip()->nLevel;

			ignore_state = 2;
		}
	}

	return true;
}

bool PackageManager::check_specail_soul_is_full_in_cur_realm() const
{
	int cur= GambleMgr::getInstance()->m_curGongFaRealm;
	return is_special_gold_magic_soul_full(cur,true);
}
